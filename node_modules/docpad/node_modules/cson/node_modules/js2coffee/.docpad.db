{
  "generateStarted": "2014-01-20T02:05:16.726Z",
  "generateEnded": null,
  "models": [
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/bin/js2coffee",
      "relativePath": "bin/js2coffee",
      "basename": "js2coffee",
      "outBasename": "js2coffee",
      "extension": null,
      "outExtension": null,
      "extensions": [],
      "filename": "js2coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/bin",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/bin/js2coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/bin",
      "outFilename": "js2coffee",
      "relativeOutPath": "bin/js2coffee",
      "relativeDirPath": "bin",
      "relativeOutDirPath": "bin",
      "relativeBase": "bin/js2coffee",
      "relativeOutBase": "bin/js2coffee",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:17.757Z",
      "rtime": "2014-01-20T02:05:24.516Z",
      "wtime": "2014-01-20T02:05:25.687Z",
      "exists": true,
      "encoding": "utf8",
      "source": "#!/usr/bin/env node\nrequire('../lib/command').run();",
      "content": "#!/usr/bin/env node\nrequire('../lib/command').run();",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "js2coffee",
      "date": "2014-01-20T02:05:17.757Z",
      "slug": "bin-js2coffee",
      "url": "/bin/js2coffee",
      "urls": [
        "/bin/js2coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "#!/usr/bin/env node\nrequire('../lib/command').run();",
      "rendered": true,
      "contentRendered": "#!/usr/bin/env node\nrequire('../lib/command').run();",
      "contentRenderedWithoutLayouts": "#!/usr/bin/env node\nrequire('../lib/command').run();",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/bin/js2coffee-debug",
      "relativePath": "bin/js2coffee-debug",
      "basename": "js2coffee-debug",
      "outBasename": "js2coffee-debug",
      "extension": null,
      "outExtension": null,
      "extensions": [],
      "filename": "js2coffee-debug",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/bin",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/bin/js2coffee-debug",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/bin",
      "outFilename": "js2coffee-debug",
      "relativeOutPath": "bin/js2coffee-debug",
      "relativeDirPath": "bin",
      "relativeOutDirPath": "bin",
      "relativeBase": "bin/js2coffee-debug",
      "relativeOutBase": "bin/js2coffee-debug",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:17.788Z",
      "rtime": "2014-01-20T02:05:24.521Z",
      "wtime": "2014-01-20T02:05:25.685Z",
      "exists": true,
      "encoding": "utf8",
      "source": "#!/usr/bin/env node\nvar fs   = require('fs');\nvar narc = require('../lib/narcissus_packed');\nvar cmd  = require('../lib/command');\nvar build= require('../lib/js2coffee').build;\n\n// Redefine the command's 'work' function.\nvar work = function(fname){\n\tvar contents = fs.readFileSync(fname, 'utf-8');\n\n\tvar output = narc.parser.parse(contents);\n\toutput = output.inspect();\n\tconsole.log(\"%s\", output);\n\n\tvar built  = build(contents);\n\tconsole.log(\"%s\", built);\n};\n\ncmd.run(work);",
      "content": "#!/usr/bin/env node\nvar fs   = require('fs');\nvar narc = require('../lib/narcissus_packed');\nvar cmd  = require('../lib/command');\nvar build= require('../lib/js2coffee').build;\n\n// Redefine the command's 'work' function.\nvar work = function(fname){\n\tvar contents = fs.readFileSync(fname, 'utf-8');\n\n\tvar output = narc.parser.parse(contents);\n\toutput = output.inspect();\n\tconsole.log(\"%s\", output);\n\n\tvar built  = build(contents);\n\tconsole.log(\"%s\", built);\n};\n\ncmd.run(work);",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "js2coffee-debug",
      "date": "2014-01-20T02:05:17.788Z",
      "slug": "bin-js2coffee-debug",
      "url": "/bin/js2coffee-debug",
      "urls": [
        "/bin/js2coffee-debug"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "#!/usr/bin/env node\nvar fs   = require('fs');\nvar narc = require('../lib/narcissus_packed');\nvar cmd  = require('../lib/command');\nvar build= require('../lib/js2coffee').build;\n\n// Redefine the command's 'work' function.\nvar work = function(fname){\n\tvar contents = fs.readFileSync(fname, 'utf-8');\n\n\tvar output = narc.parser.parse(contents);\n\toutput = output.inspect();\n\tconsole.log(\"%s\", output);\n\n\tvar built  = build(contents);\n\tconsole.log(\"%s\", built);\n};\n\ncmd.run(work);",
      "rendered": true,
      "contentRendered": "#!/usr/bin/env node\nvar fs   = require('fs');\nvar narc = require('../lib/narcissus_packed');\nvar cmd  = require('../lib/command');\nvar build= require('../lib/js2coffee').build;\n\n// Redefine the command's 'work' function.\nvar work = function(fname){\n\tvar contents = fs.readFileSync(fname, 'utf-8');\n\n\tvar output = narc.parser.parse(contents);\n\toutput = output.inspect();\n\tconsole.log(\"%s\", output);\n\n\tvar built  = build(contents);\n\tconsole.log(\"%s\", built);\n};\n\ncmd.run(work);",
      "contentRenderedWithoutLayouts": "#!/usr/bin/env node\nvar fs   = require('fs');\nvar narc = require('../lib/narcissus_packed');\nvar cmd  = require('../lib/command');\nvar build= require('../lib/js2coffee').build;\n\n// Redefine the command's 'work' function.\nvar work = function(fname){\n\tvar contents = fs.readFileSync(fname, 'utf-8');\n\n\tvar output = narc.parser.parse(contents);\n\toutput = output.inspect();\n\tconsole.log(\"%s\", output);\n\n\tvar built  = build(contents);\n\tconsole.log(\"%s\", built);\n};\n\ncmd.run(work);",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/lib/browser.js.eco",
      "relativePath": "lib/browser.js.eco",
      "basename": "browser",
      "outBasename": "browser",
      "extension": "eco",
      "outExtension": "js",
      "extensions": [
        "js",
        "eco"
      ],
      "filename": "browser.js.eco",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/lib",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/lib/browser.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/lib",
      "outFilename": "browser.js",
      "relativeOutPath": "lib/browser.js",
      "relativeDirPath": "lib",
      "relativeOutDirPath": "lib",
      "relativeBase": "lib/browser",
      "relativeOutBase": "lib/browser",
      "contentType": "application/octet-stream",
      "outContentType": "application/javascript",
      "ctime": "2013-12-30T22:08:16.000Z",
      "mtime": "2014-01-20T02:05:18.193Z",
      "rtime": "2014-01-20T02:05:25.606Z",
      "wtime": "2014-01-20T02:05:25.693Z",
      "exists": true,
      "encoding": "utf8",
      "source": "---\nminify: true\n---\n\n<%- @include('./narcissus_packed') %>\n<%- @include('./node_ext') %>\n<%- @include('./helpers') %>\n<%- @include('./js2coffee') %>",
      "content": "<%- @include('./narcissus_packed') %>\n<%- @include('./node_ext') %>\n<%- @include('./helpers') %>\n<%- @include('./js2coffee') %>",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "browser.js",
      "date": "2014-01-20T02:05:18.193Z",
      "slug": "lib-browser",
      "url": "/lib/browser.js",
      "urls": [
        "/lib/browser.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": true,
      "header": "minify: true",
      "parser": "yaml",
      "body": "<%- @include('./narcissus_packed') %>\n<%- @include('./node_ext') %>\n<%- @include('./helpers') %>\n<%- @include('./js2coffee') %>",
      "rendered": true,
      "contentRendered": "/* vim: set sw=4 ts=4 et tw=78: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (typeof module == 'undefined') {\n  this.Narcissus = new Object;\n}\n\nvar Narcissus = {\n    options: {\n        version: 185,\n    },\n    hostGlobal: this\n};\n\nNarcissus.definitions = (function() {\n\n    var tokens = [\n        // End of source.\n        \"END\",\n\n        // Operators and punctuators.  Some pair-wise order matters, e.g. (+, -)\n        // and (UNARY_PLUS, UNARY_MINUS).\n        \"\\n\", \";\",\n        \",\",\n        \"=\",\n        \"?\", \":\", \"CONDITIONAL\",\n        \"||\",\n        \"&&\",\n        \"|\",\n        \"^\",\n        \"&\",\n        \"==\", \"!=\", \"===\", \"!==\",\n        \"<\", \"<=\", \">=\", \">\",\n        \"<<\", \">>\", \">>>\",\n        \"+\", \"-\",\n        \"*\", \"/\", \"%\",\n        \"!\", \"~\", \"UNARY_PLUS\", \"UNARY_MINUS\",\n        \"++\", \"--\",\n        \".\",\n        \"[\", \"]\",\n        \"{\", \"}\",\n        \"(\", \")\",\n\n        // Nonterminal tree node type codes.\n        \"SCRIPT\", \"BLOCK\", \"LABEL\", \"FOR_IN\", \"CALL\", \"NEW_WITH_ARGS\", \"INDEX\",\n        \"ARRAY_INIT\", \"OBJECT_INIT\", \"PROPERTY_INIT\", \"GETTER\", \"SETTER\",\n        \"GROUP\", \"LIST\", \"LET_BLOCK\", \"ARRAY_COMP\", \"GENERATOR\", \"COMP_TAIL\",\n\n        // Terminals.\n        \"IDENTIFIER\", \"NUMBER\", \"STRING\", \"REGEXP\",\n\n        // Keywords.\n        \"break\",\n        \"case\", \"catch\", \"const\", \"continue\",\n        \"debugger\", \"default\", \"delete\", \"do\",\n        \"else\",\n        \"false\", \"finally\", \"for\", \"function\",\n        \"if\", \"in\", \"instanceof\",\n        \"let\",\n        \"new\", \"null\",\n        \"return\",\n        \"switch\",\n        \"this\", \"throw\", \"true\", \"try\", \"typeof\",\n        \"var\", \"void\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    var statementStartTokens = [\n        \"break\",\n        \"const\", \"continue\",\n        \"debugger\", \"do\",\n        \"for\",\n        \"if\",\n        \"return\",\n        \"switch\",\n        \"throw\", \"try\",\n        \"var\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    // Operator and punctuator mapping from token to tree node type name.\n    // NB: because the lexer doesn't backtrack, all token prefixes must themselves\n    // be valid tokens (e.g. !== is acceptable because its prefixes are the valid\n    // tokens != and !).\n    var opTypeNames = {\n        '\\n':   \"NEWLINE\",\n        ';':    \"SEMICOLON\",\n        ',':    \"COMMA\",\n        '?':    \"HOOK\",\n        ':':    \"COLON\",\n        '||':   \"OR\",\n        '&&':   \"AND\",\n        '|':    \"BITWISE_OR\",\n        '^':    \"BITWISE_XOR\",\n        '&':    \"BITWISE_AND\",\n        '===':  \"STRICT_EQ\",\n        '==':   \"EQ\",\n        '=':    \"ASSIGN\",\n        '!==':  \"STRICT_NE\",\n        '!=':   \"NE\",\n        '<<':   \"LSH\",\n        '<=':   \"LE\",\n        '<':    \"LT\",\n        '>>>':  \"URSH\",\n        '>>':   \"RSH\",\n        '>=':   \"GE\",\n        '>':    \"GT\",\n        '++':   \"INCREMENT\",\n        '--':   \"DECREMENT\",\n        '+':    \"PLUS\",\n        '-':    \"MINUS\",\n        '*':    \"MUL\",\n        '/':    \"DIV\",\n        '%':    \"MOD\",\n        '!':    \"NOT\",\n        '~':    \"BITWISE_NOT\",\n        '.':    \"DOT\",\n        '[':    \"LEFT_BRACKET\",\n        ']':    \"RIGHT_BRACKET\",\n        '{':    \"LEFT_CURLY\",\n        '}':    \"RIGHT_CURLY\",\n        '(':    \"LEFT_PAREN\",\n        ')':    \"RIGHT_PAREN\"\n    };\n\n    // Hash of keyword identifier to tokens index.  NB: we must null __proto__ to\n    // avoid toString, etc. namespace pollution.\n    var keywords = {__proto__: null};\n\n    // Define const END, etc., based on the token names.  Also map name to index.\n    var tokenIds = {};\n\n    // Building up a string to be eval'd in different contexts.\n    var consts = \"const \";\n    for (var i = 0, j = tokens.length; i < j; i++) {\n        if (i > 0)\n            consts += \", \";\n        var t = tokens[i];\n        var name;\n        if (/^[a-z]/.test(t)) {\n            name = t.toUpperCase();\n            keywords[t] = i;\n        } else {\n            name = (/^\\W/.test(t) ? opTypeNames[t] : t);\n        }\n        consts += name + \" = \" + i;\n        tokenIds[name] = i;\n        tokens[t] = i;\n    }\n    consts += \";\";\n\n    var isStatementStartCode = {__proto__: null};\n    for (i = 0, j = statementStartTokens.length; i < j; i++)\n        isStatementStartCode[keywords[statementStartTokens[i]]] = true;\n\n    // Map assignment operators to their indexes in the tokens array.\n    var assignOps = ['|', '^', '&', '<<', '>>', '>>>', '+', '-', '*', '/', '%'];\n\n    for (i = 0, j = assignOps.length; i < j; i++) {\n        t = assignOps[i];\n        assignOps[t] = tokens[t];\n    }\n\n    function defineGetter(obj, prop, fn, dontDelete, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { get: fn, configurable: !dontDelete, enumerable: !dontEnum });\n    }\n\n    function defineProperty(obj, prop, val, dontDelete, readOnly, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { value: val, writable: !readOnly, configurable: !dontDelete,\n                                enumerable: !dontEnum });\n    }\n\n    // Returns true if fn is a native function.  (Note: SpiderMonkey specific.)\n    function isNativeCode(fn) {\n        // Relies on the toString method to identify native code.\n        return ((typeof fn) === \"function\") && fn.toString().match(/\\[native code\\]/);\n    }\n\n    function getPropertyDescriptor(obj, name) {\n        while (obj) {\n            if (({}).hasOwnProperty.call(obj, name))\n                return Object.getOwnPropertyDescriptor(obj, name);\n            obj = Object.getPrototypeOf(obj);\n        }\n    }\n\n    function getOwnProperties(obj) {\n        var map = {};\n        for (var name in Object.getOwnPropertyNames(obj))\n            map[name] = Object.getOwnPropertyDescriptor(obj, name);\n        return map;\n    }\n\n    function makePassthruHandler(obj) {\n        // Handler copied from\n        // http://wiki.ecmascript.org/doku.php?id=harmony:proxies&s=proxy%20object#examplea_no-op_forwarding_proxy\n        return {\n            getOwnPropertyDescriptor: function(name) {\n                var desc = Object.getOwnPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getPropertyDescriptor: function(name) {\n                var desc = getPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getOwnPropertyNames: function() {\n                return Object.getOwnPropertyNames(obj);\n            },\n            defineProperty: function(name, desc) {\n                Object.defineProperty(obj, name, desc);\n            },\n            \"delete\": function(name) { return delete obj[name]; },\n            fix: function() {\n                if (Object.isFrozen(obj)) {\n                    return getOwnProperties(obj);\n                }\n\n                // As long as obj is not frozen, the proxy won't allow itself to be fixed.\n                return undefined; // will cause a TypeError to be thrown\n            },\n\n            has: function(name) { return name in obj; },\n            hasOwn: function(name) { return ({}).hasOwnProperty.call(obj, name); },\n            get: function(receiver, name) { return obj[name]; },\n\n            // bad behavior when set fails in non-strict mode\n            set: function(receiver, name, val) { obj[name] = val; return true; },\n            enumerate: function() {\n                var result = [];\n                for (name in obj) { result.push(name); };\n                return result;\n            },\n            keys: function() { return Object.keys(obj); }\n        };\n    }\n\n    // default function used when looking for a property in the global object\n    function noPropFound() { return undefined; }\n\n    var hasOwnProperty = ({}).hasOwnProperty;\n\n    function StringMap() {\n        this.table = Object.create(null, {});\n        this.size = 0;\n    }\n\n    StringMap.prototype = {\n        has: function(x) { return hasOwnProperty.call(this.table, x); },\n        set: function(x, v) {\n            if (!hasOwnProperty.call(this.table, x))\n                this.size++;\n            this.table[x] = v;\n        },\n        get: function(x) { return this.table[x]; },\n        getDef: function(x, thunk) {\n            if (!hasOwnProperty.call(this.table, x)) {\n                this.size++;\n                this.table[x] = thunk();\n            }\n            return this.table[x];\n        },\n        forEach: function(f) {\n            var table = this.table;\n            for (var key in table)\n                f.call(this, key, table[key]);\n        },\n        toString: function() { return \"[object StringMap]\" }\n    };\n\n    // non-destructive stack\n    function Stack(elts) {\n        this.elts = elts || null;\n    }\n\n    Stack.prototype = {\n        push: function(x) {\n            return new Stack({ top: x, rest: this.elts });\n        },\n        top: function() {\n            if (!this.elts)\n                throw new Error(\"empty stack\");\n            return this.elts.top;\n        },\n        isEmpty: function() {\n            return this.top === null;\n        },\n        find: function(test) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                if (test(elts.top))\n                    return elts.top;\n            }\n            return null;\n        },\n        has: function(x) {\n            return Boolean(this.find(function(elt) { return elt === x }));\n        },\n        forEach: function(f) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                f(elts.top);\n            }\n        }\n    };\n\n    return {\n        tokens: tokens,\n        opTypeNames: opTypeNames,\n        keywords: keywords,\n        isStatementStartCode: isStatementStartCode,\n        tokenIds: tokenIds,\n        consts: consts,\n        assignOps: assignOps,\n        defineGetter: defineGetter,\n        defineProperty: defineProperty,\n        isNativeCode: isNativeCode,\n        makePassthruHandler: makePassthruHandler,\n        noPropFound: noPropFound,\n        StringMap: StringMap,\n        Stack: Stack\n    };\n}());\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Lexical scanner.\n */\n\nNarcissus.lexer = (function() {\n\n    var definitions = Narcissus.definitions;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    // Build up a trie of operator tokens.\n    var opTokens = {};\n    for (var op in definitions.opTypeNames) {\n        if (op === '\\n' || op === '.')\n            continue;\n\n        var node = opTokens;\n        for (var i = 0; i < op.length; i++) {\n            var ch = op[i];\n            if (!(ch in node))\n                node[ch] = {};\n            node = node[ch];\n            node.op = op;\n        }\n    }\n\n    /*\n     * Tokenizer :: (source, filename, line number) -> Tokenizer\n     */\n    function Tokenizer(s, f, l) {\n        this.cursor = 0;\n        this.source = String(s);\n        this.tokens = [];\n        this.tokenIndex = 0;\n        this.lookahead = 0;\n        this.scanNewlines = false;\n        this.unexpectedEOF = false;\n        this.filename = f || \"\";\n        this.lineno = l || 1;\n        this.comments = [];\n    }\n\n    Tokenizer.prototype = {\n        get done() {\n            // We need to set scanOperand to true here because the first thing\n            // might be a regexp.\n            return this.peek(true) === END;\n        },\n\n        get token() {\n            return this.tokens[this.tokenIndex];\n        },\n\n        match: function (tt, scanOperand) {\n            return this.get(scanOperand) === tt || this.unget();\n        },\n\n        mustMatch: function (tt) {\n            if (!this.match(tt)) {\n                throw this.newSyntaxError(\"Missing \" +\n                                          definitions.tokens[tt].toLowerCase());\n            }\n            return this.token;\n        },\n\n        peek: function (scanOperand) {\n            var tt, next;\n            if (this.lookahead) {\n                next = this.tokens[(this.tokenIndex + this.lookahead) & 3];\n                tt = (this.scanNewlines && next.lineno !== this.lineno)\n                     ? NEWLINE\n                     : next.type;\n            } else {\n                tt = this.get(scanOperand);\n                this.unget();\n            }\n            return tt;\n        },\n\n        peekOnSameLine: function (scanOperand) {\n            this.scanNewlines = true;\n            var tt = this.peek(scanOperand);\n            this.scanNewlines = false;\n            return tt;\n        },\n\n        // Eat comments and whitespace.\n        // toka: returns list of skipped comments\n        skip: function () {\n            var input = this.source;\n            var cstart;\n            var clineno;\n            var comments = [];\n            var comment;\n            var nlcount = 0;\n\n            for (;;) {\n                var ch = input[this.cursor++];\n                var next = input[this.cursor];\n                if (ch === '\\n' && !this.scanNewlines) {\n                    this.lineno++;\n                    nlcount++;\n                } else if (ch === '/' && next === '*') {\n                    cstart = this.cursor;\n                    clineno = this.lineno;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated comment\");\n\n                        if (ch === '*') {\n                            next = input[this.cursor];\n                            if (next === '/') {\n                                this.cursor++;\n                                comment = {\n                                    type: \"BLOCK_COMMENT\",\n                                    nlcount: nlcount,\n                                    start:cstart-1, end:this.cursor, lineno:clineno, endlineno: this.lineno,\n                                    value: input.substring(cstart+1,this.cursor-2)\n                                }\n                                // comments.push(comment);\n                                this.comments.push(comment);\n                                nlcount = 0;\n                                break;\n                            }\n                        } else if (ch === '\\n') {\n                            this.lineno++;\n                        }\n                    }\n                } else if (ch === '/' && next === '/') {\n                    cstart = this.cursor;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined) {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            // comments.push(comment);\n                            this.comments.push(comment);\n                            return;\n                            // return comments;\n                        }\n                        if (ch === '\\n') {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            //comments.push(  );\n                            this.comments.push(comment);\n                            nlcount = 0;\n                            this.lineno++;\n                            break;\n                        }\n                    }\n                } else if (ch !== ' ' && ch !== '\\t') {\n                    this.cursor--;\n                    // return comments;\n                    return;\n                }\n            }\n        },\n\n        // Lex the exponential part of a number, if present. Return true iff an\n        // exponential part was found.\n        lexExponent: function() {\n            var input = this.source;\n            var next = input[this.cursor];\n            if (next === 'e' || next === 'E') {\n                this.cursor++;\n                ch = input[this.cursor++];\n                if (ch === '+' || ch === '-')\n                    ch = input[this.cursor++];\n\n                if (ch < '0' || ch > '9')\n                    throw this.newSyntaxError(\"Missing exponent\");\n\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                return true;\n            }\n\n            return false;\n        },\n\n        lexZeroNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            ch = input[this.cursor++];\n            if (ch === '.') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n                token.value = parseFloat(token.start, this.cursor);\n            } else if (ch === 'x' || ch === 'X') {\n                do {\n                    ch = input[this.cursor++];\n                } while ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||\n                         (ch >= 'A' && ch <= 'F'));\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else if (ch >= '0' && ch <= '7') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '7');\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else {\n                this.cursor--;\n                this.lexExponent();     // 0E1, &c.\n                token.value = 0;\n            }\n        },\n\n        lexNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            var floating = false;\n            do {\n                ch = input[this.cursor++];\n                if (ch === '.' && !floating) {\n                    floating = true;\n                    ch = input[this.cursor++];\n                }\n            } while (ch >= '0' && ch <= '9');\n\n            this.cursor--;\n\n            var exponent = this.lexExponent();\n            floating = floating || exponent;\n\n            var str = input.substring(token.start, this.cursor);\n            token.value = floating ? parseFloat(str) : parseInt(str);\n        },\n\n        lexDot: function (ch) {\n            var token = this.token, input = this.source;\n            var next = input[this.cursor];\n            if (next >= '0' && next <= '9') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n\n                token.type = NUMBER;\n                token.value = parseFloat(token.start, this.cursor);\n            } else {\n                token.type = DOT;\n                token.assignOp = null;\n                token.value = '.';\n            }\n        },\n\n        lexString: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = STRING;\n\n            var hasEscapes = false;\n            var delim = ch;\n            while ((ch = input[this.cursor++]) !== delim) {\n                // [JS2COFFEE] Fixed to make it work on a browser\n                if (this.cursor >= input.length)\n                    throw this.newSyntaxError(\"Unterminated string literal\");\n                if (ch === '\\\\') {\n                    hasEscapes = true;\n                    if (++this.cursor == input.length)\n                        throw this.newSyntaxError(\"Unterminated string literal\");\n                }\n            }\n\n            token.value = hasEscapes\n                          ? eval(input.substring(token.start, this.cursor))\n                          : input.substring(token.start + 1, this.cursor - 1);\n        },\n\n        lexRegExp: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = REGEXP;\n\n            do {\n                ch = input[this.cursor++];\n                if (ch === '\\\\') {\n                    this.cursor++;\n                } else if (ch === '[') {\n                    do {\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated character class\");\n\n                        if (ch === '\\\\')\n                            this.cursor++;\n\n                        ch = input[this.cursor++];\n                    } while (ch !== ']');\n                } else if (ch === undefined) {\n                    throw this.newSyntaxError(\"Unterminated regex\");\n                }\n            } while (ch !== '/');\n\n            do {\n                ch = input[this.cursor++];\n            } while (ch >= 'a' && ch <= 'z');\n\n            this.cursor--;\n\n            token.value = eval(input.substring(token.start, this.cursor));\n        },\n\n        lexOp: function (ch) {\n            var token = this.token, input = this.source;\n\n            // A bit ugly, but it seems wasteful to write a trie lookup routine\n            // for only 3 characters...\n            var node = opTokens[ch];\n            var next = input[this.cursor];\n            if (next in node) {\n                node = node[next];\n                this.cursor++;\n                next = input[this.cursor];\n                if (next in node) {\n                    node = node[next];\n                    this.cursor++;\n                    next = input[this.cursor];\n                }\n            }\n\n            var op = node.op;\n            if (definitions.assignOps[op] && input[this.cursor] === '=') {\n                this.cursor++;\n                token.type = ASSIGN;\n                token.assignOp = definitions.tokenIds[definitions.opTypeNames[op]];\n                op += '=';\n            } else {\n                token.type = definitions.tokenIds[definitions.opTypeNames[op]];\n                token.assignOp = null;\n            }\n\n            token.value = op;\n        },\n\n        // FIXME: Unicode escape sequences\n        // FIXME: Unicode identifiers\n        lexIdent: function (ch) {\n            var token = this.token, input = this.source;\n\n            do {\n                ch = input[this.cursor++];\n            } while ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n                     (ch >= '0' && ch <= '9') || ch === '$' || ch === '_');\n\n            this.cursor--;  // Put the non-word character back.\n\n            var id = input.substring(token.start, this.cursor);\n            token.type = definitions.keywords[id] || IDENTIFIER;\n            token.value = id;\n        },\n\n        /*\n         * Tokenizer.get :: void -> token type\n         *\n         * Consume input *only* if there is no lookahead.\n         * Dispatch to the appropriate lexing function depending on the input.\n         */\n        get: function (scanOperand) {\n            var token;\n            while (this.lookahead) {\n                --this.lookahead;\n                this.tokenIndex = (this.tokenIndex + 1) & 3;\n                token = this.tokens[this.tokenIndex];\n                if (token.type !== NEWLINE || this.scanNewlines)\n                    return token.type;\n            }\n\n            // var comments =\n            this.skip();\n\n            this.tokenIndex = (this.tokenIndex + 1) & 3;\n            token = this.tokens[this.tokenIndex];\n            if (!token)\n                this.tokens[this.tokenIndex] = token = {};\n\n            var input = this.source;\n            if (this.cursor === input.length)\n                return token.type = END;\n\n            token.start = this.cursor;\n            token.lineno = this.lineno;\n\n            var ch = input[this.cursor++];\n            if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '$' || ch === '_') {\n                this.lexIdent(ch);\n            } else if (scanOperand && ch === '/') {\n                this.lexRegExp(ch);\n            } else if (ch in opTokens) {\n                this.lexOp(ch);\n            } else if (ch === '.') {\n                this.lexDot(ch);\n            } else if (ch >= '1' && ch <= '9') {\n                this.lexNumber(ch);\n            } else if (ch === '0') {\n                this.lexZeroNumber(ch);\n            } else if (ch === '\"' || ch === \"'\") {\n                this.lexString(ch);\n            } else if (this.scanNewlines && ch === '\\n') {\n                token.type = NEWLINE;\n                token.value = '\\n';\n                this.lineno++;\n            } else {\n                throw this.newSyntaxError(\"Illegal token\");\n            }\n\n            token.end = this.cursor;\n            // token.comments = [comments,this.skip()];\n            return token.type;\n        },\n\n        /*\n         * Tokenizer.unget :: void -> undefined\n         *\n         * Match depends on unget returning undefined.\n         */\n        unget: function () {\n            if (++this.lookahead === 4) throw \"PANIC: too much lookahead!\";\n            this.tokenIndex = (this.tokenIndex - 1) & 3;\n        },\n\n        newSyntaxError: function (m) {\n            var e = new SyntaxError(m, this.filename, this.lineno);\n            e.source = this.source;\n            e.cursor = this.lookahead\n                       ? this.tokens[(this.tokenIndex + this.lookahead) & 3].start\n                       : this.cursor;\n            return e;\n        },\n    };\n\n    return { Tokenizer: Tokenizer };\n\n}());\n\n/* -*- Mode: JS; tab-width: 4; indent-tabs-mode: nil; -*-\n * vim: set sw=4 ts=4 et tw=78:\n * ***** BEGIN LICENSE BLOCK *****\n *\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Parser.\n */\n\nNarcissus.parser = (function() {\n\n    var lexer = Narcissus.lexer;\n    var definitions = Narcissus.definitions;\n\n    const StringMap = definitions.StringMap;\n    const Stack = definitions.Stack;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    /*\n     * pushDestructuringVarDecls :: (node, hoisting node) -> void\n     *\n     * Recursively add all destructured declarations to varDecls.\n     */\n    function pushDestructuringVarDecls(n, s) {\n        for (var i in n) {\n            var sub = n[i];\n            if (sub.type === IDENTIFIER) {\n                s.varDecls.push(sub);\n            } else {\n                pushDestructuringVarDecls(sub, s);\n            }\n        }\n    }\n\n    // NESTING_TOP: top-level\n    // NESTING_SHALLOW: nested within static forms such as { ... } or labeled statement\n    // NESTING_DEEP: nested within dynamic forms such as if, loops, etc.\n    const NESTING_TOP = 0, NESTING_SHALLOW = 1, NESTING_DEEP = 2;\n\n    function StaticContext(parentScript, parentBlock, inFunction, inForLoopInit, nesting) {\n        this.parentScript = parentScript;\n        this.parentBlock = parentBlock;\n        this.inFunction = inFunction;\n        this.inForLoopInit = inForLoopInit;\n        this.nesting = nesting;\n        this.allLabels = new Stack();\n        this.currentLabels = new Stack();\n        this.labeledTargets = new Stack();\n        this.defaultTarget = null;\n        Narcissus.options.ecma3OnlyMode && (this.ecma3OnlyMode = true);\n        Narcissus.options.parenFreeMode && (this.parenFreeMode = true);\n    }\n\n    StaticContext.prototype = {\n        ecma3OnlyMode: false,\n        parenFreeMode: false,\n        // non-destructive update via prototype extension\n        update: function(ext) {\n            var desc = {};\n            for (var key in ext) {\n                desc[key] = {\n                    value: ext[key],\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                }\n            }\n            return Object.create(this, desc);\n        },\n        pushLabel: function(label) {\n            return this.update({ currentLabels: this.currentLabels.push(label),\n                                 allLabels: this.allLabels.push(label) });\n        },\n        pushTarget: function(target) {\n            var isDefaultTarget = target.isLoop || target.type === SWITCH;\n\n            if (this.currentLabels.isEmpty()) {\n                return isDefaultTarget\n                     ? this.update({ defaultTarget: target })\n                     : this;\n            }\n\n            target.labels = new StringMap();\n            this.currentLabels.forEach(function(label) {\n                target.labels.set(label, true);\n            });\n            return this.update({ currentLabels: new Stack(),\n                                 labeledTargets: this.labeledTargets.push(target),\n                                 defaultTarget: isDefaultTarget\n                                                ? target\n                                                : this.defaultTarget });\n        },\n        nest: function(atLeast) {\n            var nesting = Math.max(this.nesting, atLeast);\n            return (nesting !== this.nesting)\n                 ? this.update({ nesting: nesting })\n                 : this;\n        }\n    };\n\n    /*\n     * Script :: (tokenizer, boolean) -> node\n     *\n     * Parses the toplevel and function bodies.\n     */\n    function Script(t, inFunction) {\n        var n = new Node(t, scriptInit());\n        var x = new StaticContext(n, n, inFunction, false, NESTING_TOP);\n        Statements(t, x, n);\n        return n;\n    }\n\n    // We extend Array slightly with a top-of-stack method.\n    definitions.defineProperty(Array.prototype, \"top\",\n                               function() {\n                                   return this.length && this[this.length-1];\n                               }, false, false, true);\n\n    /*\n     * Node :: (tokenizer, optional init object) -> node\n     */\n    function Node(t, init) {\n        var token = t.token;\n        if (token) {\n            // If init.type exists it will override token.type.\n            this.type = token.type;\n            this.value = token.value;\n            this.lineno = token.lineno;\n\n            // Start and end are file positions for error handling.\n            this.start = token.start;\n            this.end = token.end;\n\n        } else {\n            this.lineno = t.lineno;\n        }\n\n        // Node uses a tokenizer for debugging (getSource, filename getter).\n        this.tokenizer = t;\n        this.children = [];\n\n        for (var prop in init)\n            this[prop] = init[prop];\n    }\n\n    var Np = Node.prototype = {};\n    Np.constructor = Node;\n    Np.toSource = Object.prototype.toSource;\n\n    // Always use push to add operands to an expression, to update start and end.\n    Np.push = function (kid) {\n        // kid can be null e.g. [1, , 2].\n        if (kid !== null) {\n            if (kid.start < this.start)\n                this.start = kid.start;\n            if (this.end < kid.end)\n                this.end = kid.end;\n        }\n        return this.children.push(kid);\n    }\n\n    Node.indentLevel = 0;\n\n    function tokenString(tt) {\n        var t = definitions.tokens[tt];\n        return /^\\W/.test(t) ? definitions.opTypeNames[t] : t.toUpperCase();\n    }\n\n    Np.toString = function () {\n        var a = [];\n        for (var i in this) {\n            if (this.hasOwnProperty(i) && i !== 'type' && i !== 'target')\n                a.push({id: i, value: this[i]});\n        }\n        a.sort(function (a,b) { return (a.id < b.id) ? -1 : 1; });\n        const INDENTATION = \"    \";\n        var n = ++Node.indentLevel;\n        var s = \"{\\n\" + INDENTATION.repeat(n) + \"type: \" + tokenString(this.type);\n        for (i = 0; i < a.length; i++)\n            s += \",\\n\" + INDENTATION.repeat(n) + a[i].id + \": \" + a[i].value;\n        n = --Node.indentLevel;\n        s += \"\\n\" + INDENTATION.repeat(n) + \"}\";\n        return s;\n    }\n\n    Np.getSource = function () {\n        return this.tokenizer.source.slice(this.start, this.end);\n    };\n\n    /*\n     * Helper init objects for common nodes.\n     */\n\n    const LOOP_INIT = { isLoop: true };\n\n    function blockInit() {\n        return { type: BLOCK, varDecls: [] };\n    }\n\n    function scriptInit() {\n        return { type: SCRIPT,\n                 funDecls: [],\n                 varDecls: [],\n                 modDecls: [],\n                 impDecls: [],\n                 expDecls: [],\n                 loadDeps: [],\n                 hasEmptyReturn: false,\n                 hasReturnWithValue: false,\n                 isGenerator: false };\n    }\n\n    definitions.defineGetter(Np, \"filename\",\n                             function() {\n                                 return this.tokenizer.filename;\n                             });\n\n    definitions.defineGetter(Np, \"length\",\n                             function() {\n                                 throw new Error(\"Node.prototype.length is gone; \" +\n                                                 \"use n.children.length instead\");\n                             });\n\n    definitions.defineProperty(String.prototype, \"repeat\",\n                               function(n) {\n                                   var s = \"\", t = this + s;\n                                   while (--n >= 0)\n                                       s += t;\n                                   return s;\n                               }, false, false, true);\n\n    function MaybeLeftParen(t, x) {\n        if (x.parenFreeMode)\n            return t.match(LEFT_PAREN) ? LEFT_PAREN : END;\n        return t.mustMatch(LEFT_PAREN).type;\n    }\n\n    function MaybeRightParen(t, p) {\n        if (p === LEFT_PAREN)\n            t.mustMatch(RIGHT_PAREN);\n    }\n\n    /*\n     * Statements :: (tokenizer, compiler context, node) -> void\n     *\n     * Parses a sequence of Statements.\n     */\n    function Statements(t, x, n) {\n        try {\n            while (!t.done && t.peek(true) !== RIGHT_CURLY)\n            { n.push(Statement(t, x)); }\n        } catch (e) {\n            if (t.done)\n            { t.unexpectedEOF = true; }\n            throw(e);\n        }\n    }\n\n    function Block(t, x) {\n        t.mustMatch(LEFT_CURLY);\n        var n = new Node(t, blockInit());\n        Statements(t, x.update({ parentBlock: n }).pushTarget(n), n);\n        t.mustMatch(RIGHT_CURLY);\n        return n;\n    }\n\n    const DECLARED_FORM = 0, EXPRESSED_FORM = 1, STATEMENT_FORM = 2;\n\n    /*\n     * Statement :: (tokenizer, compiler context) -> node\n     *\n     * Parses a Statement.\n     */\n    function Statement(t, x) {\n        var i, label, n, n2, p, c, ss, tt = t.get(true), tt2, x2, x3;\n\n        // Cases for statements ending in a right curly return early, avoiding the\n        // common semicolon insertion magic after this switch.\n        switch (tt) {\n          case FUNCTION:\n            // DECLARED_FORM extends funDecls of x, STATEMENT_FORM doesn't.\n            return FunctionDefinition(t, x, true,\n                                      (x.nesting !== NESTING_TOP)\n                                      ? STATEMENT_FORM\n                                      : DECLARED_FORM);\n\n          case LEFT_CURLY:\n            n = new Node(t, blockInit());\n            Statements(t, x.update({ parentBlock: n }).pushTarget(n).nest(NESTING_SHALLOW), n);\n            t.mustMatch(RIGHT_CURLY);\n            return n;\n\n          case IF:\n            n = new Node(t);\n            n.condition = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            n.thenPart = Statement(t, x2);\n            n.elsePart = t.match(ELSE) ? Statement(t, x2) : null;\n            return n;\n\n          case SWITCH:\n            // This allows CASEs after a DEFAULT, which is in the standard.\n            n = new Node(t, { cases: [], defaultIndex: -1 });\n            n.discriminant = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            t.mustMatch(LEFT_CURLY);\n            while ((tt = t.get()) !== RIGHT_CURLY) {\n                switch (tt) {\n                  case DEFAULT:\n                    if (n.defaultIndex >= 0)\n                        throw t.newSyntaxError(\"More than one switch default\");\n                    // FALL THROUGH\n                  case CASE:\n                    n2 = new Node(t);\n                    if (tt === DEFAULT)\n                        n.defaultIndex = n.cases.length;\n                    else\n                        n2.caseLabel = Expression(t, x2, COLON);\n                    break;\n\n                  default:\n                    throw t.newSyntaxError(\"Invalid switch case\");\n                }\n                t.mustMatch(COLON);\n                n2.statements = new Node(t, blockInit());\n                while ((tt=t.peek(true)) !== CASE && tt !== DEFAULT &&\n                        tt !== RIGHT_CURLY)\n                    n2.statements.push(Statement(t, x2));\n                n.cases.push(n2);\n            }\n            return n;\n\n          case FOR:\n            n = new Node(t, LOOP_INIT);\n            if (t.match(IDENTIFIER)) {\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(LEFT_PAREN);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            x3 = x.update({ inForLoopInit: true });\n            if ((tt = t.peek()) !== SEMICOLON) {\n                if (tt === VAR || tt === CONST) {\n                    t.get();\n                    n2 = Variables(t, x3);\n                } else if (tt === LET) {\n                    t.get();\n                    if (t.peek() === LEFT_PAREN) {\n                        n2 = LetBlock(t, x3, false);\n                    } else {\n                        // Let in for head, we need to add an implicit block\n                        // around the rest of the for.\n                        x3.parentBlock = n;\n                        n.varDecls = [];\n                        n2 = Variables(t, x3);\n                    }\n                } else {\n                    n2 = Expression(t, x3);\n                }\n            }\n            if (n2 && t.match(IN)) {\n                n.type = FOR_IN;\n                n.object = Expression(t, x3);\n                if (n2.type === VAR || n2.type === LET) {\n                    c = n2.children;\n\n                    // Destructuring turns one decl into multiples, so either\n                    // there must be only one destructuring or only one\n                    // decl.\n                    if (c.length !== 1 && n2.destructurings.length !== 1) {\n                        throw new SyntaxError(\"Invalid for..in left-hand side\",\n                                              t.filename, n2.lineno);\n                    }\n                    if (n2.destructurings.length > 0) {\n                        n.iterator = n2.destructurings[0];\n                    } else {\n                        n.iterator = c[0];\n                    }\n                    n.varDecl = n2;\n                } else {\n                    if (n2.type === ARRAY_INIT || n2.type === OBJECT_INIT) {\n                        n2.destructuredNames = checkDestructuring(t, x3, n2);\n                    }\n                    n.iterator = n2;\n                }\n            } else {\n                n.setup = n2;\n                t.mustMatch(SEMICOLON);\n                if (n.isEach)\n                    throw t.newSyntaxError(\"Invalid for each..in loop\");\n                n.condition = (t.peek() === SEMICOLON)\n                              ? null\n                              : Expression(t, x3);\n                t.mustMatch(SEMICOLON);\n                tt2 = t.peek();\n                n.update = (x.parenFreeMode\n                            ? tt2 === LEFT_CURLY || definitions.isStatementStartCode[tt2]\n                            : tt2 === RIGHT_PAREN)\n                           ? null\n                           : Expression(t, x3);\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(RIGHT_PAREN);\n            n.body = Statement(t, x2);\n            return n;\n\n          case WHILE:\n            n = new Node(t, { isLoop: true });\n            n.condition = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case DO:\n            n = new Node(t, { isLoop: true });\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            t.mustMatch(WHILE);\n            n.condition = HeadExpression(t, x);\n            if (!x.ecmaStrictMode) {\n                // <script language=\"JavaScript\"> (without version hints) may need\n                // automatic semicolon insertion without a newline after do-while.\n                // See http://bugzilla.mozilla.org/show_bug.cgi?id=238945.\n                t.match(SEMICOLON);\n                return n;\n            }\n            break;\n\n          case BREAK:\n          case CONTINUE:\n            n = new Node(t);\n\n            // handle the |foo: break foo;| corner case\n            x2 = x.pushTarget(n);\n\n            if (t.peekOnSameLine() === IDENTIFIER) {\n                t.get();\n                n.label = t.token.value;\n            }\n\n            n.target = n.label\n                     ? x2.labeledTargets.find(function(target) { return target.labels.has(n.label) })\n                     : x2.defaultTarget;\n\n            if (!n.target)\n                throw t.newSyntaxError(\"Invalid \" + ((tt === BREAK) ? \"break\" : \"continue\"));\n            if (!n.target.isLoop && tt === CONTINUE)\n                throw t.newSyntaxError(\"Invalid continue\");\n\n            break;\n\n          case TRY:\n            n = new Node(t, { catchClauses: [] });\n            n.tryBlock = Block(t, x);\n            while (t.match(CATCH)) {\n                n2 = new Node(t);\n                p = MaybeLeftParen(t, x);\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured catch identifiers.\n                    t.unget();\n                    n2.varName = DestructuringExpression(t, x, true);\n                    break;\n                  case IDENTIFIER:\n                    n2.varName = t.token.value;\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing identifier in catch\");\n                    break;\n                }\n                if (t.match(IF)) {\n                    if (x.ecma3OnlyMode)\n                        throw t.newSyntaxError(\"Illegal catch guard\");\n                    if (n.catchClauses.length && !n.catchClauses.top().guard)\n                        throw t.newSyntaxError(\"Guarded catch after unguarded\");\n                    n2.guard = Expression(t, x);\n                }\n                MaybeRightParen(t, p);\n                n2.block = Block(t, x);\n                n.catchClauses.push(n2);\n            }\n            if (t.match(FINALLY))\n                n.finallyBlock = Block(t, x);\n            if (!n.catchClauses.length && !n.finallyBlock)\n                throw t.newSyntaxError(\"Invalid try statement\");\n            return n;\n\n          case CATCH:\n          case FINALLY:\n            throw t.newSyntaxError(definitions.tokens[tt] + \" without preceding try\");\n\n          case THROW:\n            n = new Node(t);\n            n.exception = Expression(t, x);\n            break;\n\n          case RETURN:\n            n = ReturnOrYield(t, x);\n            break;\n\n          case WITH:\n            n = new Node(t);\n            n.object = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case VAR:\n          case CONST:\n            n = Variables(t, x);\n            break;\n\n          case LET:\n            if (t.peek() === LEFT_PAREN)\n                n = LetBlock(t, x, true);\n            else\n                n = Variables(t, x);\n            break;\n\n          case DEBUGGER:\n            n = new Node(t);\n            break;\n\n          case NEWLINE:\n          case SEMICOLON:\n            n = new Node(t, { type: SEMICOLON });\n            n.expression = null;\n            return n;\n\n          default:\n            if (tt === IDENTIFIER) {\n                tt = t.peek();\n                // Labeled statement.\n                if (tt === COLON) {\n                    label = t.token.value;\n                    if (x.allLabels.has(label))\n                        throw t.newSyntaxError(\"Duplicate label\");\n                    t.get();\n                    n = new Node(t, { type: LABEL, label: label });\n                    n.statement = Statement(t, x.pushLabel(label).nest(NESTING_SHALLOW));\n                    n.target = (n.statement.type === LABEL) ? n.statement.target : n.statement;\n                    return n;\n                }\n            }\n\n            // Expression statement.\n            // We unget the current token to parse the expression as a whole.\n            n = new Node(t, { type: SEMICOLON });\n            t.unget();\n            n.expression = Expression(t, x);\n            n.end = n.expression.end;\n            break;\n        }\n\n        MagicalSemicolon(t);\n        return n;\n    }\n\n    function MagicalSemicolon(t) {\n        var tt;\n        if (t.lineno === t.token.lineno) {\n            tt = t.peekOnSameLine();\n            if (tt !== END && tt !== NEWLINE && tt !== SEMICOLON && tt !== RIGHT_CURLY)\n                throw t.newSyntaxError(\"missing ; before statement\");\n        }\n        t.match(SEMICOLON);\n    }\n\n    function ReturnOrYield(t, x) {\n        var n, b, tt = t.token.type, tt2;\n\n        var parentScript = x.parentScript;\n\n        if (tt === RETURN) {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Return not in function\");\n        } else /* if (tt === YIELD) */ {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Yield not in function\");\n            parentScript.isGenerator = true;\n        }\n        n = new Node(t, { value: undefined });\n\n        tt2 = t.peek(true);\n        if (tt2 !== END && tt2 !== NEWLINE &&\n            tt2 !== SEMICOLON && tt2 !== RIGHT_CURLY\n            && (tt !== YIELD ||\n                (tt2 !== tt && tt2 !== RIGHT_BRACKET && tt2 !== RIGHT_PAREN &&\n                 tt2 !== COLON && tt2 !== COMMA))) {\n            if (tt === RETURN) {\n                n.value = Expression(t, x);\n                parentScript.hasReturnWithValue = true;\n            } else {\n                n.value = AssignExpression(t, x);\n            }\n        } else if (tt === RETURN) {\n            parentScript.hasEmptyReturn = true;\n        }\n\n        // Disallow return v; in generator.\n        if (parentScript.hasReturnWithValue && parentScript.isGenerator)\n            throw t.newSyntaxError(\"Generator returns a value\");\n\n        return n;\n    }\n\n    /*\n     * FunctionDefinition :: (tokenizer, compiler context, boolean,\n     *                        DECLARED_FORM or EXPRESSED_FORM or STATEMENT_FORM)\n     *                    -> node\n     */\n    function FunctionDefinition(t, x, requireName, functionForm) {\n        var tt;\n        var f = new Node(t, { params: [] });\n        if (f.type !== FUNCTION)\n            f.type = (f.value === \"get\") ? GETTER : SETTER;\n        if (t.match(IDENTIFIER))\n            f.name = t.token.value;\n        else if (requireName)\n            throw t.newSyntaxError(\"missing function identifier\");\n\n        var x2 = new StaticContext(null, null, true, false, NESTING_TOP);\n\n        t.mustMatch(LEFT_PAREN);\n        if (!t.match(RIGHT_PAREN)) {\n            do {\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured formal parameters.\n                    t.unget();\n                    f.params.push(DestructuringExpression(t, x2));\n                    break;\n                  case IDENTIFIER:\n                    f.params.push(t.token.value);\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing formal parameter\");\n                    break;\n                }\n            } while (t.match(COMMA));\n            t.mustMatch(RIGHT_PAREN);\n        }\n\n        // Do we have an expression closure or a normal body?\n        tt = t.get();\n        if (tt !== LEFT_CURLY)\n            t.unget();\n\n        if (tt !== LEFT_CURLY) {\n            f.body = AssignExpression(t, x2);\n            if (f.body.isGenerator)\n                throw t.newSyntaxError(\"Generator returns a value\");\n        } else {\n            f.body = Script(t, true);\n        }\n\n        if (tt === LEFT_CURLY)\n            t.mustMatch(RIGHT_CURLY);\n\n        f.end = t.token.end;\n        f.functionForm = functionForm;\n        if (functionForm === DECLARED_FORM)\n            x.parentScript.funDecls.push(f);\n        return f;\n    }\n\n    /*\n     * Variables :: (tokenizer, compiler context) -> node\n     *\n     * Parses a comma-separated list of var declarations (and maybe\n     * initializations).\n     */\n    function Variables(t, x, letBlock) {\n        var n, n2, ss, i, s, tt;\n\n        tt = t.token.type;\n        switch (tt) {\n          case VAR:\n          case CONST:\n            s = x.parentScript;\n            break;\n          case LET:\n            s = x.parentBlock;\n            break;\n          case LEFT_PAREN:\n            tt = LET;\n            s = letBlock;\n            break;\n        }\n\n        n = new Node(t, { type: tt, destructurings: [] });\n\n        do {\n            tt = t.get();\n            if (tt === LEFT_BRACKET || tt === LEFT_CURLY) {\n                // Need to unget to parse the full destructured expression.\n                t.unget();\n\n                var dexp = DestructuringExpression(t, x, true);\n\n                n2 = new Node(t, { type: IDENTIFIER,\n                                   name: dexp,\n                                   readOnly: n.type === CONST });\n                n.push(n2);\n                pushDestructuringVarDecls(n2.name.destructuredNames, s);\n                n.destructurings.push({ exp: dexp, decl: n2 });\n\n                if (x.inForLoopInit && t.peek() === IN) {\n                    continue;\n                }\n\n                t.mustMatch(ASSIGN);\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n\n                continue;\n            }\n\n            if (tt !== IDENTIFIER)\n                throw t.newSyntaxError(\"missing variable name\");\n\n            n2 = new Node(t, { type: IDENTIFIER,\n                               name: t.token.value,\n                               readOnly: n.type === CONST });\n            n.push(n2);\n            s.varDecls.push(n2);\n\n            if (t.match(ASSIGN)) {\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n            }\n        } while (t.match(COMMA));\n\n        return n;\n    }\n\n    /*\n     * LetBlock :: (tokenizer, compiler context, boolean) -> node\n     *\n     * Does not handle let inside of for loop init.\n     */\n    function LetBlock(t, x, isStatement) {\n        var n, n2;\n\n        // t.token.type must be LET\n        n = new Node(t, { type: LET_BLOCK, varDecls: [] });\n        t.mustMatch(LEFT_PAREN);\n        n.variables = Variables(t, x, n);\n        t.mustMatch(RIGHT_PAREN);\n\n        if (isStatement && t.peek() !== LEFT_CURLY) {\n            /*\n             * If this is really an expression in let statement guise, then we\n             * need to wrap the LET_BLOCK node in a SEMICOLON node so that we pop\n             * the return value of the expression.\n             */\n            n2 = new Node(t, { type: SEMICOLON,\n                               expression: n });\n            isStatement = false;\n        }\n\n        if (isStatement)\n            n.block = Block(t, x);\n        else\n            n.expression = AssignExpression(t, x);\n\n        return n;\n    }\n\n    function checkDestructuring(t, x, n, simpleNamesOnly) {\n        if (n.type === ARRAY_COMP)\n            throw t.newSyntaxError(\"Invalid array comprehension left-hand side\");\n        if (n.type !== ARRAY_INIT && n.type !== OBJECT_INIT)\n            return;\n\n        var lhss = {};\n        var nn, n2, idx, sub, cc, c = n.children;\n        for (var i = 0, j = c.length; i < j; i++) {\n            if (!(nn = c[i]))\n                continue;\n            if (nn.type === PROPERTY_INIT) {\n                cc = nn.children;\n                sub = cc[1];\n                idx = cc[0].value;\n            } else if (n.type === OBJECT_INIT) {\n                // Do we have destructuring shorthand {foo, bar}?\n                sub = nn;\n                idx = nn.value;\n            } else {\n                sub = nn;\n                idx = i;\n            }\n\n            if (sub.type === ARRAY_INIT || sub.type === OBJECT_INIT) {\n                lhss[idx] = checkDestructuring(t, x, sub, simpleNamesOnly);\n            } else {\n                if (simpleNamesOnly && sub.type !== IDENTIFIER) {\n                    // In declarations, lhs must be simple names\n                    throw t.newSyntaxError(\"missing name in pattern\");\n                }\n\n                lhss[idx] = sub;\n            }\n        }\n\n        return lhss;\n    }\n\n    function DestructuringExpression(t, x, simpleNamesOnly) {\n        var n = PrimaryExpression(t, x);\n        // Keep the list of lefthand sides for varDecls\n        n.destructuredNames = checkDestructuring(t, x, n, simpleNamesOnly);\n        return n;\n    }\n\n    function GeneratorExpression(t, x, e) {\n        return new Node(t, { type: GENERATOR,\n                             expression: e,\n                             tail: ComprehensionTail(t, x) });\n    }\n\n    function ComprehensionTail(t, x) {\n        var body, n, n2, n3, p;\n\n        // t.token.type must be FOR\n        body = new Node(t, { type: COMP_TAIL });\n\n        do {\n            // Comprehension tails are always for..in loops.\n            n = new Node(t, { type: FOR_IN, isLoop: true });\n            if (t.match(IDENTIFIER)) {\n                // But sometimes they're for each..in.\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            p = MaybeLeftParen(t, x);\n            switch(t.get()) {\n              case LEFT_BRACKET:\n              case LEFT_CURLY:\n                t.unget();\n                // Destructured left side of for in comprehension tails.\n                n.iterator = DestructuringExpression(t, x);\n                break;\n\n              case IDENTIFIER:\n                n.iterator = n3 = new Node(t, { type: IDENTIFIER });\n                n3.name = n3.value;\n                n.varDecl = n2 = new Node(t, { type: VAR });\n                n2.push(n3);\n                x.parentScript.varDecls.push(n3);\n                // Don't add to varDecls since the semantics of comprehensions is\n                // such that the variables are in their own function when\n                // desugared.\n                break;\n\n              default:\n                throw t.newSyntaxError(\"missing identifier\");\n            }\n            t.mustMatch(IN);\n            n.object = Expression(t, x);\n            MaybeRightParen(t, p);\n            body.push(n);\n        } while (t.match(FOR));\n\n        // Optional guard.\n        if (t.match(IF))\n            body.guard = HeadExpression(t, x);\n\n        return body;\n    }\n\n    function HeadExpression(t, x) {\n        var p = MaybeLeftParen(t, x);\n        var n = ParenExpression(t, x);\n        MaybeRightParen(t, p);\n        if (p === END && !n.parenthesized) {\n            var tt = t.peek();\n            if (tt !== LEFT_CURLY && !definitions.isStatementStartCode[tt])\n                throw t.newSyntaxError(\"Unparenthesized head followed by unbraced body\");\n        }\n        return n;\n    }\n\n    function ParenExpression(t, x) {\n        // Always accept the 'in' operator in a parenthesized expression,\n        // where it's unambiguous, even if we might be parsing the init of a\n        // for statement.\n        var n = Expression(t, x.update({ inForLoopInit: x.inForLoopInit &&\n                                                        (t.token.type === LEFT_PAREN) }));\n\n        if (t.match(FOR)) {\n            if (n.type === YIELD && !n.parenthesized)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (n.type === COMMA && !n.parenthesized)\n                throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            n = GeneratorExpression(t, x, n);\n        }\n\n        return n;\n    }\n\n    /*\n     * Expression :: (tokenizer, compiler context) -> node\n     *\n     * Top-down expression parser matched against SpiderMonkey.\n     */\n    function Expression(t, x) {\n        var n, n2;\n\n        n = AssignExpression(t, x);\n        if (t.match(COMMA)) {\n            n2 = new Node(t, { type: COMMA });\n            n2.push(n);\n            n = n2;\n            do {\n                n2 = n.children[n.children.length-1];\n                if (n2.type === YIELD && !n2.parenthesized)\n                    throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n                n.push(AssignExpression(t, x));\n            } while (t.match(COMMA));\n        }\n\n        return n;\n    }\n\n    function AssignExpression(t, x) {\n        var n, lhs;\n\n        // Have to treat yield like an operand because it could be the leftmost\n        // operand of the expression.\n        if (t.match(YIELD, true))\n            return ReturnOrYield(t, x);\n\n        n = new Node(t, { type: ASSIGN });\n        lhs = ConditionalExpression(t, x);\n\n        if (!t.match(ASSIGN)) {\n            return lhs;\n        }\n\n        switch (lhs.type) {\n          case OBJECT_INIT:\n          case ARRAY_INIT:\n            lhs.destructuredNames = checkDestructuring(t, x, lhs);\n            // FALL THROUGH\n          case IDENTIFIER: case DOT: case INDEX: case CALL:\n            break;\n          default:\n            throw t.newSyntaxError(\"Bad left-hand side of assignment\");\n            break;\n        }\n\n        n.assignOp = t.token.assignOp;\n        n.push(lhs);\n        n.push(AssignExpression(t, x));\n\n        return n;\n    }\n\n    function ConditionalExpression(t, x) {\n        var n, n2;\n\n        n = OrExpression(t, x);\n        if (t.match(HOOK)) {\n            n2 = n;\n            n = new Node(t, { type: HOOK });\n            n.push(n2);\n            /*\n             * Always accept the 'in' operator in the middle clause of a ternary,\n             * where it's unambiguous, even if we might be parsing the init of a\n             * for statement.\n             */\n            n.push(AssignExpression(t, x.update({ inForLoopInit: false })));\n            if (!t.match(COLON))\n                throw t.newSyntaxError(\"missing : after ?\");\n            n.push(AssignExpression(t, x));\n        }\n\n        return n;\n    }\n\n    function OrExpression(t, x) {\n        var n, n2;\n\n        n = AndExpression(t, x);\n        while (t.match(OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AndExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseOrExpression(t, x);\n        while (t.match(AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseOrExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseOrExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseXorExpression(t, x);\n        while (t.match(BITWISE_OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseXorExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseXorExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseAndExpression(t, x);\n        while (t.match(BITWISE_XOR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseAndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseAndExpression(t, x) {\n        var n, n2;\n\n        n = EqualityExpression(t, x);\n        while (t.match(BITWISE_AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(EqualityExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function EqualityExpression(t, x) {\n        var n, n2;\n\n        n = RelationalExpression(t, x);\n        while (t.match(EQ) || t.match(NE) ||\n               t.match(STRICT_EQ) || t.match(STRICT_NE)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(RelationalExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function RelationalExpression(t, x) {\n        var n, n2;\n\n        /*\n         * Uses of the in operator in shiftExprs are always unambiguous,\n         * so unset the flag that prohibits recognizing it.\n         */\n        var x2 = x.update({ inForLoopInit: false });\n        n = ShiftExpression(t, x2);\n        while ((t.match(LT) || t.match(LE) || t.match(GE) || t.match(GT) ||\n               (!x.inForLoopInit && t.match(IN)) ||\n               t.match(INSTANCEOF))) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(ShiftExpression(t, x2));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ShiftExpression(t, x) {\n        var n, n2;\n\n        n = AddExpression(t, x);\n        while (t.match(LSH) || t.match(RSH) || t.match(URSH)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AddExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AddExpression(t, x) {\n        var n, n2;\n\n        n = MultiplyExpression(t, x);\n        while (t.match(PLUS) || t.match(MINUS)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(MultiplyExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function MultiplyExpression(t, x) {\n        var n, n2;\n\n        n = UnaryExpression(t, x);\n        while (t.match(MUL) || t.match(DIV) || t.match(MOD)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(UnaryExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function UnaryExpression(t, x) {\n        var n, n2, tt;\n\n        switch (tt = t.get(true)) {\n          case DELETE: case VOID: case TYPEOF:\n          case NOT: case BITWISE_NOT: case PLUS: case MINUS:\n            if (tt === PLUS)\n                n = new Node(t, { type: UNARY_PLUS });\n            else if (tt === MINUS)\n                n = new Node(t, { type: UNARY_MINUS });\n            else\n                n = new Node(t);\n            n.push(UnaryExpression(t, x));\n            break;\n\n          case INCREMENT:\n          case DECREMENT:\n            // Prefix increment/decrement.\n            n = new Node(t);\n            n.push(MemberExpression(t, x, true));\n            break;\n\n          default:\n            t.unget();\n            n = MemberExpression(t, x, true);\n\n            // Don't look across a newline boundary for a postfix {in,de}crement.\n            if (t.tokens[(t.tokenIndex + t.lookahead - 1) & 3].lineno ===\n                t.lineno) {\n                if (t.match(INCREMENT) || t.match(DECREMENT)) {\n                    n2 = new Node(t, { postfix: true });\n                    n2.push(n);\n                    n = n2;\n                }\n            }\n            break;\n        }\n\n        return n;\n    }\n\n    function MemberExpression(t, x, allowCallSyntax) {\n        var n, n2, name, tt;\n\n        if (t.match(NEW)) {\n            n = new Node(t);\n            n.push(MemberExpression(t, x, false));\n            if (t.match(LEFT_PAREN)) {\n                n.type = NEW_WITH_ARGS;\n                n.push(ArgumentList(t, x));\n            }\n        } else {\n            n = PrimaryExpression(t, x);\n        }\n\n        while ((tt = t.get()) !== END) {\n            switch (tt) {\n              case DOT:\n                n2 = new Node(t);\n                n2.push(n);\n                t.mustMatch(IDENTIFIER);\n                n2.push(new Node(t));\n                break;\n\n              case LEFT_BRACKET:\n                n2 = new Node(t, { type: INDEX });\n                n2.push(n);\n                n2.push(Expression(t, x));\n                t.mustMatch(RIGHT_BRACKET);\n                break;\n\n              case LEFT_PAREN:\n                if (allowCallSyntax) {\n                    n2 = new Node(t, { type: CALL });\n                    n2.push(n);\n                    n2.push(ArgumentList(t, x));\n                    break;\n                }\n\n                // FALL THROUGH\n              default:\n                t.unget();\n                return n;\n            }\n\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ArgumentList(t, x) {\n        var n, n2;\n\n        n = new Node(t, { type: LIST });\n        if (t.match(RIGHT_PAREN, true))\n            return n;\n        do {\n            n2 = AssignExpression(t, x);\n            if (n2.type === YIELD && !n2.parenthesized && t.peek() === COMMA)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (t.match(FOR)) {\n                n2 = GeneratorExpression(t, x, n2);\n                if (n.children.length > 1 || t.peek(true) === COMMA)\n                    throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            }\n            n.push(n2);\n        } while (t.match(COMMA));\n        t.mustMatch(RIGHT_PAREN);\n\n        return n;\n    }\n\n    function PrimaryExpression(t, x) {\n        var n, n2, tt = t.get(true);\n\n        switch (tt) {\n          case FUNCTION:\n            n = FunctionDefinition(t, x, false, EXPRESSED_FORM);\n            break;\n\n          case LEFT_BRACKET:\n            n = new Node(t, { type: ARRAY_INIT });\n            while ((tt = t.peek(true)) !== RIGHT_BRACKET) {\n                if (tt === COMMA) {\n                    t.get();\n                    n.push(null);\n                    continue;\n                }\n                n.push(AssignExpression(t, x));\n                if (tt !== COMMA && !t.match(COMMA))\n                    break;\n            }\n\n            // If we matched exactly one element and got a FOR, we have an\n            // array comprehension.\n            if (n.children.length === 1 && t.match(FOR)) {\n                n2 = new Node(t, { type: ARRAY_COMP,\n                                   expression: n.children[0],\n                                   tail: ComprehensionTail(t, x) });\n                n = n2;\n            }\n            t.mustMatch(RIGHT_BRACKET);\n            break;\n\n          case LEFT_CURLY:\n            var id, fd;\n            n = new Node(t, { type: OBJECT_INIT });\n\n          object_init:\n            if (!t.match(RIGHT_CURLY)) {\n                do {\n                    tt = t.get();\n                    if ((t.token.value === \"get\" || t.token.value === \"set\") &&\n                        t.peek() === IDENTIFIER) {\n                        if (x.ecma3OnlyMode)\n                            throw t.newSyntaxError(\"Illegal property accessor\");\n                        n.push(FunctionDefinition(t, x, true, EXPRESSED_FORM));\n                    } else {\n                        switch (tt) {\n                          case IDENTIFIER: case NUMBER: case STRING:\n                            id = new Node(t, { type: IDENTIFIER });\n                            break;\n                          case RIGHT_CURLY:\n                            if (x.ecma3OnlyMode)\n                                throw t.newSyntaxError(\"Illegal trailing ,\");\n                            break object_init;\n                          default:\n                            if (t.token.value in definitions.keywords) {\n                                id = new Node(t, { type: IDENTIFIER });\n                                break;\n                            }\n                            throw t.newSyntaxError(\"Invalid property name\");\n                        }\n                        if (t.match(COLON)) {\n                            n2 = new Node(t, { type: PROPERTY_INIT });\n                            n2.push(id);\n                            n2.push(AssignExpression(t, x));\n                            n.push(n2);\n                        } else {\n                            // Support, e.g., |var {x, y} = o| as destructuring shorthand\n                            // for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.\n                            if (t.peek() !== COMMA && t.peek() !== RIGHT_CURLY)\n                                throw t.newSyntaxError(\"missing : after property\");\n                            n.push(id);\n                        }\n                    }\n                } while (t.match(COMMA));\n                t.mustMatch(RIGHT_CURLY);\n            }\n            break;\n\n          case LEFT_PAREN:\n            n = ParenExpression(t, x);\n            t.mustMatch(RIGHT_PAREN);\n            n.parenthesized = true;\n            break;\n\n          case LET:\n            n = LetBlock(t, x, false);\n            break;\n\n          case NULL: case THIS: case TRUE: case FALSE:\n          case IDENTIFIER: case NUMBER: case STRING: case REGEXP:\n            n = new Node(t);\n            break;\n\n          default:\n            throw t.newSyntaxError(\"missing operand\");\n            break;\n        }\n\n        return n;\n    }\n\n    /*\n     * parse :: (source, filename, line number) -> node\n     */\n    function parse(s, f, l) {\n        var t = new lexer.Tokenizer(s, f, l);\n        var n = Script(t, false);\n        if (!t.done)\n            throw t.newSyntaxError(\"Syntax error\");\n\n        return n;\n    }\n\n    /*\n     * parseStdin :: (source, {line number}) -> node\n     */\n    function parseStdin(s, ln) {\n        for (;;) {\n            try {\n                var t = new lexer.Tokenizer(s, \"stdin\", ln.value);\n                var n = Script(t, false);\n                ln.value = t.lineno;\n                return n;\n            } catch (e) {\n                if (!t.unexpectedEOF)\n                    throw e;\n                var more = readline();\n                if (!more)\n                    throw e;\n                s += \"\\n\" + more;\n            }\n        }\n    }\n\n    return {\n        parse: parse,\n        parseStdin: parseStdin,\n        Node: Node,\n        DECLARED_FORM: DECLARED_FORM,\n        EXPRESSED_FORM: EXPRESSED_FORM,\n        STATEMENT_FORM: STATEMENT_FORM,\n        Tokenizer: lexer.Tokenizer,\n        FunctionDefinition: FunctionDefinition\n    };\n\n}());\n\nvar exports = {\n  definitions: Narcissus.definitions,\n  lexer: Narcissus.lexer,\n  parser: Narcissus.parser\n};\n\nif (typeof module != 'undefined') {\n  module.exports = exports;\n};\n\n\n(function() {\n  var Node, Typenames, Types, exports, narcissus, parser, tokens, _,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice;\n\n  narcissus = require('./narcissus_packed');\n\n  _ = require('underscore');\n\n  tokens = narcissus.definitions.tokens;\n\n  parser = narcissus.parser;\n\n  Node = parser.Node;\n\n  Node.prototype.left = function() {\n    return this.children[0];\n  };\n\n  Node.prototype.right = function() {\n    return this.children[1];\n  };\n\n  Node.prototype.last = function() {\n    return this.children[this.children.length - 1];\n  };\n\n  Node.prototype.walk = function(options, fn, parent, list) {\n    if (parent == null) {\n      parent = null;\n    }\n    if (list == null) {\n      list = null;\n    }\n    if (parent) {\n      fn(parent, this, list);\n    }\n    if (options.last) {\n      if (this.last() != null) {\n        this.last().walk(options, fn, this);\n      }\n    }\n    if (this.thenPart != null) {\n      this.thenPart.walk(options, fn, this, 'thenPart');\n    }\n    if (this.elsePart != null) {\n      this.elsePart.walk(options, fn, this, 'elsePart');\n    }\n    if (this.cases) {\n      return _.each(this.cases, function(item) {\n        return item.statements.walk(options, fn, item, 'cases');\n      });\n    }\n  };\n\n  Node.prototype.clone = function(hash) {\n    var i;\n    for (i in this) {\n      if (i === 'tokenizer' || i === 'length' || i === 'filename') {\n        continue;\n      }\n      if (hash[i] == null) {\n        hash[i] = this[i];\n      }\n    }\n    return new Node(this.tokenizer, hash);\n  };\n\n  Node.prototype.toHash = function(done) {\n    var hash, i, toHash;\n    if (done == null) {\n      done = [];\n    }\n    hash = {};\n    toHash = function(what) {\n      if (!what) {\n        return null;\n      }\n      if (what.toHash) {\n        if (__indexOf.call(done, what) >= 0) {\n          return \"--recursive \" + what.id + \"--\";\n        }\n        what.id = done.push(what);\n        return what.toHash(done);\n      } else {\n        return what;\n      }\n    };\n    hash.type = this.typeName();\n    hash.src = this.src();\n    for (i in this) {\n      if (i === 'filename' || i === 'length' || i === 'type' || i === 'start' || i === 'end' || i === 'tokenizer') {\n        continue;\n      }\n      if (typeof this[i] === 'function') {\n        continue;\n      }\n      if (!this[i]) {\n        continue;\n      }\n      if (this[i].constructor === Array) {\n        hash[i] = _.map(this[i], function(item) {\n          return toHash(item);\n        });\n      } else {\n        hash[i] = toHash(this[i]);\n      }\n    }\n    return hash;\n  };\n\n  Node.prototype.inspect = function() {\n    return JSON.stringify(this.toHash(), null, '  ');\n  };\n\n  Node.prototype.src = function() {\n    return this.tokenizer.source.substr(this.start, this.end - this.start);\n  };\n\n  Node.prototype.typeName = function() {\n    return Types[this.type];\n  };\n\n  Node.prototype.isA = function() {\n    var what, _ref;\n    what = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return _ref = Types[this.type], __indexOf.call(what, _ref) >= 0;\n  };\n\n  Types = (function() {\n    var dict, i, last;\n    dict = {};\n    last = 0;\n    for (i in tokens) {\n      if (typeof tokens[i] === 'number') {\n        dict[tokens[i]] = i.toLowerCase();\n        last = tokens[i];\n      }\n    }\n    dict[++last] = 'call_statement';\n    dict[++last] = 'existence_check';\n    return dict;\n  })();\n\n  Typenames = (function() {\n    var dict, i;\n    dict = {};\n    for (i in Types) {\n      dict[Types[i]] = i;\n    }\n    return dict;\n  })();\n\n  this.NodeExt = exports = {\n    Types: Types,\n    Typenames: Typenames,\n    Node: Node\n  };\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = exports;\n  }\n\n}).call(this);\n\n(function() {\n  var Code, CoffeeScript, blockTrim, coffeescript_reserved, exports, indentLines, isSingleLine, ltrim, p, paren, rtrim, strEscape, strEscapeSingleQuotes, strRepeat, trim, truthy, unreserve, unshift, word,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  CoffeeScript = require('coffee-script');\n\n  if (CoffeeScript.RESERVED == null) {\n    CoffeeScript.RESERVED = require('coffee-script/lib/coffee-script/lexer.js').RESERVED;\n  }\n\n  Code = (function() {\n    Code.INDENT = \"  \";\n\n    function Code() {\n      this.code = '';\n    }\n\n    Code.prototype.add = function(str) {\n      this.code += str.toString();\n      return this;\n    };\n\n    Code.prototype.scope = function(str, level) {\n      var indent;\n      if (level == null) {\n        level = 1;\n      }\n      indent = strRepeat(Code.INDENT, level);\n      this.code = rtrim(this.code) + \"\\n\";\n      this.code += indent + rtrim(str).replace(/\\n/g, \"\\n\" + indent) + \"\\n\";\n      return this;\n    };\n\n    Code.prototype.toString = function() {\n      return this.code;\n    };\n\n    return Code;\n\n  })();\n\n  paren = function(string) {\n    var str;\n    str = string.toString();\n    if (str.substr(0, 1) === '(' && str.substr(-1, 1) === ')') {\n      return str;\n    } else {\n      return \"(\" + str + \")\";\n    }\n  };\n\n  strRepeat = function(str, times) {\n    var i;\n    return ((function() {\n      var _i, _results;\n      _results = [];\n      for (i = _i = 0; 0 <= times ? _i < times : _i > times; i = 0 <= times ? ++_i : --_i) {\n        _results.push(str);\n      }\n      return _results;\n    })()).join('');\n  };\n\n  ltrim = function(str) {\n    return (\"\" + str).replace(/^\\s*/g, '');\n  };\n\n  rtrim = function(str) {\n    return (\"\" + str).replace(/\\s*$/g, '');\n  };\n\n  blockTrim = function(str) {\n    return (\"\" + str).replace(/^\\s*\\n|\\s*$/g, '');\n  };\n\n  trim = function(str) {\n    return (\"\" + str).replace(/^\\s*|\\s*$/g, '');\n  };\n\n  isSingleLine = function(str) {\n    return trim(str).indexOf(\"\\n\") === -1;\n  };\n\n  unshift = function(str) {\n    var m1, m2;\n    str = \"\" + str;\n    while (true) {\n      m1 = str.match(/^/gm);\n      m2 = str.match(/^ /gm);\n      if (!m1 || !m2 || m1.length !== m2.length) {\n        return str;\n      }\n      str = str.replace(/^ /gm, '');\n    }\n  };\n\n  truthy = function(n) {\n    return n.isA('true') || (n.isA('number') && parseFloat(n.src()) !== 0.0);\n  };\n\n  strEscape = function(str) {\n    if (str.indexOf('#{') !== -1) {\n      return strEscapeSingleQuotes(str);\n    }\n    return JSON.stringify(\"\" + str);\n  };\n\n  strEscapeSingleQuotes = function(str) {\n    var dq, esq, rdq;\n    dq = JSON.stringify(str);\n    rdq = dq.replace(/\\\\\"/g, '\"');\n    esq = rdq.replace(/'/g, \"\\\\\\'\");\n    return \"'\" + esq.substr(1, esq.length - 2) + \"'\";\n  };\n\n  p = function(str) {\n    if (str.constructor === String) {\n      console.log(JSON.stringify(str));\n    } else {\n      console.log(str);\n    }\n    return '';\n  };\n\n  coffeescript_reserved = (function() {\n    var _i, _len, _ref, _results;\n    _ref = CoffeeScript.RESERVED;\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      word = _ref[_i];\n      if (word !== 'undefined') {\n        _results.push(word);\n      }\n    }\n    return _results;\n  })();\n\n  unreserve = function(str) {\n    var _ref;\n    if (_ref = \"\" + str, __indexOf.call(coffeescript_reserved, _ref) >= 0) {\n      return \"\" + str + \"_\";\n    } else {\n      return \"\" + str;\n    }\n  };\n\n  indentLines = function(indent, lines) {\n    return indent + lines.replace(/\\n/g, \"\\n\" + indent);\n  };\n\n  this.Js2coffeeHelpers = exports = {\n    Code: Code,\n    p: p,\n    strEscapeDoubleQuotes: strEscape,\n    strEscapeSingleQuotes: strEscapeSingleQuotes,\n    unreserve: unreserve,\n    unshift: unshift,\n    isSingleLine: isSingleLine,\n    trim: trim,\n    blockTrim: blockTrim,\n    ltrim: ltrim,\n    rtrim: rtrim,\n    strRepeat: strRepeat,\n    paren: paren,\n    truthy: truthy,\n    indentLines: indentLines\n  };\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = exports;\n  }\n\n}).call(this);\n\n(function() {\n  var Builder, Code, Node, Transformer, Typenames, Types, UnsupportedError, blockTrim, buildCoffee, exports, indentLines, isSingleLine, ltrim, p, paren, parser, pkg, rtrim, strEscape, strEscapeDoubleQuotes, strEscapeSingleQuotes, strRepeat, trim, truthy, unreserve, unshift, _, _ref, _ref1,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty;\n\n  _ = require('underscore');\n\n  pkg = require('../../package.json');\n\n  parser = require('./narcissus_packed').parser;\n\n  _ref = require('./node_ext'), Types = _ref.Types, Typenames = _ref.Typenames, Node = _ref.Node;\n\n  _ref1 = require('./helpers'), Code = _ref1.Code, p = _ref1.p, strEscapeDoubleQuotes = _ref1.strEscapeDoubleQuotes, strEscapeSingleQuotes = _ref1.strEscapeSingleQuotes, unreserve = _ref1.unreserve, unshift = _ref1.unshift, isSingleLine = _ref1.isSingleLine, trim = _ref1.trim, blockTrim = _ref1.blockTrim, ltrim = _ref1.ltrim, rtrim = _ref1.rtrim, strRepeat = _ref1.strRepeat, paren = _ref1.paren, truthy = _ref1.truthy, indentLines = _ref1.indentLines;\n\n  strEscape = void 0;\n\n  buildCoffee = function(str, opts) {\n    var builder, comments, indent, keepLineNumbers, l, line, minline, output, precomments, res, scriptNode, srclines, text, _i, _len, _ref2;\n    if (opts == null) {\n      opts = {};\n    }\n    str = str.replace(/\\r/g, '');\n    str += \"\\n\";\n    if (opts.indent != null) {\n      Code.INDENT = opts.indent;\n    }\n    if ((opts.single_quotes != null) && opts.single_quotes === true) {\n      console.log(opts.single_quotes);\n      strEscape = strEscapeSingleQuotes;\n    } else {\n      strEscape = strEscapeDoubleQuotes;\n    }\n    builder = new Builder(opts);\n    scriptNode = parser.parse(str);\n    output = trim(builder.build(scriptNode));\n    if (opts.no_comments) {\n      return ((function() {\n        var _i, _len, _ref2, _results;\n        _ref2 = output.split('\\n');\n        _results = [];\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          line = _ref2[_i];\n          _results.push(rtrim(line));\n        }\n        return _results;\n      })()).join('\\n');\n    } else {\n      keepLineNumbers = opts.show_src_lineno;\n      res = [];\n      _ref2 = output.split(\"\\n\");\n      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n        l = _ref2[_i];\n        srclines = [];\n        text = l.replace(/\\uFEFE([0-9]+).*?\\uFEFE/g, function(m, g) {\n          srclines.push(parseInt(g));\n          return \"\";\n        });\n        srclines = _.sortBy(_.uniq(srclines), function(i) {\n          return i;\n        });\n        text = rtrim(text);\n        indent = text.match(/^\\s*/);\n        if (srclines.length > 0) {\n          minline = _.last(srclines);\n          precomments = builder.commentsNotDoneTo(minline);\n          if (precomments) {\n            res.push(indentLines(indent, precomments));\n          }\n        }\n        if (text) {\n          if (keepLineNumbers) {\n            text = text + \"#\" + srclines.join(\",\") + \"#  \";\n          }\n          res.push(rtrim(text + \" \" + ltrim(builder.lineComments(srclines))));\n        } else {\n          res.push(\"\");\n        }\n      }\n      comments = builder.commentsNotDoneTo(1e10);\n      if (comments) {\n        res.push(comments);\n      }\n      return res.join(\"\\n\");\n    }\n  };\n\n  Builder = (function() {\n    function Builder(options) {\n      this.options = options != null ? options : {};\n      this.transformer = new Transformer;\n    }\n\n    Builder.prototype.l = function(n) {\n      if (this.options.no_comments) {\n        return '';\n      }\n      if (n && n.lineno) {\n        return \"\\uFEFE\" + n.lineno + \"\\uFEFE\";\n      } else {\n        return \"\";\n      }\n    };\n\n    Builder.prototype.makeComment = function(comment) {\n      var c, line;\n      if (comment.type === \"BLOCK_COMMENT\") {\n        c = comment.value.split(\"\\n\");\n        if (c.length > 0 && c[0].length > 0 && c[0][0] === \"*\") {\n          c = (function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = c.length; _i < _len; _i++) {\n              line = c[_i];\n              _results.push(line.replace(/^[\\s\\*]*/, ''));\n            }\n            return _results;\n          })();\n          c = (function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = c.length; _i < _len; _i++) {\n              line = c[_i];\n              _results.push(line.replace(/[\\s]*$/, ''));\n            }\n            return _results;\n          })();\n          while (c.length > 0 && c[0].length === 0) {\n            c.shift();\n          }\n          while (c.length > 0 && c[c.length - 1].length === 0) {\n            c.pop();\n          }\n          c.unshift('###');\n          c.push('###');\n        } else {\n          c = (function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = c.length; _i < _len; _i++) {\n              line = c[_i];\n              _results.push(\"#\" + line);\n            }\n            return _results;\n          })();\n        }\n      } else {\n        c = ['#' + comment.value];\n      }\n      if (comment.nlcount > 0) {\n        c.unshift('');\n      }\n      return c.join('\\n');\n    };\n\n    Builder.prototype.commentsNotDoneTo = function(lineno) {\n      var c, res;\n      res = [];\n      while (true) {\n        if (this.comments.length === 0) {\n          break;\n        }\n        c = this.comments[0];\n        if (c.lineno < lineno) {\n          res.push(this.makeComment(c));\n          this.comments.shift();\n          continue;\n        }\n        break;\n      }\n      return res.join(\"\\n\");\n    };\n\n    Builder.prototype.lineComments = function(linenos) {\n      var c, selection;\n      selection = (function() {\n        var _i, _len, _ref2, _ref3, _results;\n        _ref2 = this.comments;\n        _results = [];\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          c = _ref2[_i];\n          if (_ref3 = c.lineno, __indexOf.call(linenos, _ref3) >= 0) {\n            _results.push(c);\n          }\n        }\n        return _results;\n      }).call(this);\n      this.comments = _.difference(this.comments, selection);\n      return ((function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = selection.length; _i < _len; _i++) {\n          c = selection[_i];\n          _results.push(this.makeComment(c));\n        }\n        return _results;\n      }).call(this)).join(\"\\n\");\n    };\n\n    Builder.prototype.build = function() {\n      var args, fn, name, node, out;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      node = args[0];\n      if (this.comments == null) {\n        this.comments = _.sortBy(node.tokenizer.comments, function(n) {\n          return n.start;\n        });\n      }\n      this.transform(node);\n      name = 'other';\n      if (node !== void 0 && node.typeName) {\n        name = node.typeName();\n      }\n      fn = this[name] || this.other;\n      out = fn.apply(this, args);\n      if (node.parenthesized) {\n        return paren(out);\n      } else {\n        return out;\n      }\n    };\n\n    Builder.prototype.transform = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return this.transformer.transform.apply(this.transformer, args);\n    };\n\n    Builder.prototype.body = function(node, opts) {\n      var str;\n      if (opts == null) {\n        opts = {};\n      }\n      str = this.build(node, opts);\n      str = blockTrim(str);\n      str = unshift(str);\n      if (str.length > 0) {\n        return str;\n      } else {\n        return \"\";\n      }\n    };\n\n    Builder.prototype['script'] = function(n, opts) {\n      var c,\n        _this = this;\n      if (opts == null) {\n        opts = {};\n      }\n      c = new Code;\n      _.each(n.functions, function(item) {\n        return c.add(_this.build(item));\n      });\n      _.each(n.nonfunctions, function(item) {\n        return c.add(_this.build(item));\n      });\n      return c.toString();\n    };\n\n    Builder.prototype['property_identifier'] = function(n) {\n      var str;\n      str = n.value.toString();\n      if (str.match(/^([_\\$a-z][_\\$a-z0-9]*)$/i) || str.match(/^[0-9]+$/i)) {\n        return this.l(n) + str;\n      } else {\n        return this.l(n) + strEscape(str);\n      }\n    };\n\n    Builder.prototype['identifier'] = function(n) {\n      if (n.value === 'undefined') {\n        return this.l(n) + '`undefined`';\n      } else if (n.property_accessor) {\n        return this.l(n) + n.value.toString();\n      } else {\n        return this.l(n) + unreserve(n.value.toString());\n      }\n    };\n\n    Builder.prototype['number'] = function(n) {\n      return this.l(n) + (\"\" + (n.src()));\n    };\n\n    Builder.prototype['id'] = function(n) {\n      if (n.property_accessor) {\n        return this.l(n) + n;\n      } else {\n        return this.l(n) + unreserve(n);\n      }\n    };\n\n    Builder.prototype['id_param'] = function(n) {\n      var _ref2;\n      if ((_ref2 = n.toString()) === 'undefined') {\n        return this.l(n) + (\"\" + n + \"_\");\n      } else {\n        return this.l(n) + this.id(n);\n      }\n    };\n\n    Builder.prototype['return'] = function(n) {\n      if (n.value == null) {\n        return this.l(n) + \"return\\n\";\n      } else {\n        return this.l(n) + (\"return \" + (this.build(n.value)) + \"\\n\");\n      }\n    };\n\n    Builder.prototype[';'] = function(n) {\n      var src;\n      if (n.expression == null) {\n        return \"\";\n      } else if (n.expression.typeName() === 'object_init') {\n        src = this.object_init(n.expression);\n        if (n.parenthesized) {\n          return src;\n        } else {\n          return \"\" + (unshift(blockTrim(src))) + \"\\n\";\n        }\n      } else {\n        return this.build(n.expression) + \"\\n\";\n      }\n    };\n\n    Builder.prototype['new'] = function(n) {\n      return this.l(n) + (\"new \" + (this.build(n.left())));\n    };\n\n    Builder.prototype['new_with_args'] = function(n) {\n      return this.l(n) + (\"new \" + (this.build(n.left())) + \"(\" + (this.build(n.right())) + \")\");\n    };\n\n    Builder.prototype['unary_plus'] = function(n) {\n      return \"+\" + (this.build(n.left()));\n    };\n\n    Builder.prototype['unary_minus'] = function(n) {\n      return \"-\" + (this.build(n.left()));\n    };\n\n    Builder.prototype['this'] = function(n) {\n      return this.l(n) + 'this';\n    };\n\n    Builder.prototype['null'] = function(n) {\n      return this.l(n) + 'null';\n    };\n\n    Builder.prototype['true'] = function(n) {\n      return this.l(n) + 'true';\n    };\n\n    Builder.prototype['false'] = function(n) {\n      return this.l(n) + 'false';\n    };\n\n    Builder.prototype['void'] = function(n) {\n      return this.l(n) + 'undefined';\n    };\n\n    Builder.prototype['debugger'] = function(n) {\n      return this.l(n) + \"debugger\\n\";\n    };\n\n    Builder.prototype['break'] = function(n) {\n      return this.l(n) + \"break\\n\";\n    };\n\n    Builder.prototype['continue'] = function(n) {\n      return this.l(n) + \"continue\\n\";\n    };\n\n    Builder.prototype['~'] = function(n) {\n      return \"~\" + (this.build(n.left()));\n    };\n\n    Builder.prototype['typeof'] = function(n) {\n      return this.l(n) + (\"typeof \" + (this.build(n.left())));\n    };\n\n    Builder.prototype['index'] = function(n) {\n      var right;\n      right = this.build(n.right());\n      if (_.any(n.children, function(child) {\n        return child.typeName() === 'object_init' && child.children.length > 1;\n      })) {\n        right = \"{\" + right + \"}\";\n      }\n      return this.l(n) + (\"\" + (this.build(n.left())) + \"[\" + right + \"]\");\n    };\n\n    Builder.prototype['throw'] = function(n) {\n      return this.l(n) + (\"throw \" + (this.build(n.exception)));\n    };\n\n    Builder.prototype['!'] = function(n) {\n      var negations, target;\n      target = n.left();\n      negations = 1;\n      while ((target.isA('!')) && (target = target.left())) {\n        ++negations;\n      }\n      if ((negations & 1) && target.isA('==', '!=', '===', '!==', 'in', 'instanceof')) {\n        target.negated = !target.negated;\n        return this.build(target);\n      }\n      return this.l(n) + (\"\" + (negations & 1 ? 'not ' : '!!') + (this.build(target)));\n    };\n\n    Builder.prototype[\"in\"] = function(n) {\n      return this.binary_operator(n, 'of');\n    };\n\n    Builder.prototype['+'] = function(n) {\n      return this.binary_operator(n, '+');\n    };\n\n    Builder.prototype['-'] = function(n) {\n      return this.binary_operator(n, '-');\n    };\n\n    Builder.prototype['*'] = function(n) {\n      return this.binary_operator(n, '*');\n    };\n\n    Builder.prototype['/'] = function(n) {\n      return this.binary_operator(n, '/');\n    };\n\n    Builder.prototype['%'] = function(n) {\n      return this.binary_operator(n, '%');\n    };\n\n    Builder.prototype['>'] = function(n) {\n      return this.binary_operator(n, '>');\n    };\n\n    Builder.prototype['<'] = function(n) {\n      return this.binary_operator(n, '<');\n    };\n\n    Builder.prototype['&'] = function(n) {\n      return this.binary_operator(n, '&');\n    };\n\n    Builder.prototype['|'] = function(n) {\n      return this.binary_operator(n, '|');\n    };\n\n    Builder.prototype['^'] = function(n) {\n      return this.binary_operator(n, '^');\n    };\n\n    Builder.prototype['&&'] = function(n) {\n      return this.binary_operator(n, 'and');\n    };\n\n    Builder.prototype['||'] = function(n) {\n      return this.binary_operator(n, 'or');\n    };\n\n    Builder.prototype['<<'] = function(n) {\n      return this.binary_operator(n, '<<');\n    };\n\n    Builder.prototype['<='] = function(n) {\n      return this.binary_operator(n, '<=');\n    };\n\n    Builder.prototype['>>'] = function(n) {\n      return this.binary_operator(n, '>>');\n    };\n\n    Builder.prototype['>='] = function(n) {\n      return this.binary_operator(n, '>=');\n    };\n\n    Builder.prototype['==='] = function(n) {\n      return this.binary_operator(n, 'is');\n    };\n\n    Builder.prototype['!=='] = function(n) {\n      return this.binary_operator(n, 'isnt');\n    };\n\n    Builder.prototype['>>>'] = function(n) {\n      return this.binary_operator(n, '>>>');\n    };\n\n    Builder.prototype[\"instanceof\"] = function(n) {\n      return this.binary_operator(n, 'instanceof');\n    };\n\n    Builder.prototype['=='] = function(n) {\n      return this.binary_operator(n, 'is');\n    };\n\n    Builder.prototype['!='] = function(n) {\n      return this.binary_operator(n, 'isnt');\n    };\n\n    Builder.prototype['binary_operator'] = (function() {\n      var INVERSIONS, k, v;\n      INVERSIONS = {\n        is: 'isnt',\n        \"in\": 'not in',\n        of: 'not of',\n        \"instanceof\": 'not instanceof'\n      };\n      for (k in INVERSIONS) {\n        if (!__hasProp.call(INVERSIONS, k)) continue;\n        v = INVERSIONS[k];\n        INVERSIONS[v] = k;\n      }\n      return function(n, sign) {\n        if (n.negated) {\n          sign = INVERSIONS[sign];\n        }\n        return this.l(n) + (\"\" + (this.build(n.left())) + \" \" + sign + \" \" + (this.build(n.right())));\n      };\n    })();\n\n    Builder.prototype['--'] = function(n) {\n      return this.increment_decrement(n, '--');\n    };\n\n    Builder.prototype['++'] = function(n) {\n      return this.increment_decrement(n, '++');\n    };\n\n    Builder.prototype['increment_decrement'] = function(n, sign) {\n      if (n.postfix) {\n        return this.l(n) + (\"\" + (this.build(n.left())) + sign);\n      } else {\n        return this.l(n) + (\"\" + sign + (this.build(n.left())));\n      }\n    };\n\n    Builder.prototype['='] = function(n) {\n      var sign;\n      sign = n.assignOp != null ? Types[n.assignOp] + '=' : '=';\n      return this.l(n) + (\"\" + (this.build(n.left())) + \" \" + sign + \" \" + (this.build(n.right())));\n    };\n\n    Builder.prototype[','] = function(n) {\n      var list,\n        _this = this;\n      list = _.map(n.children, function(item) {\n        return _this.l(item) + _this.build(item) + \"\\n\";\n      });\n      return list.join('');\n    };\n\n    Builder.prototype['regexp'] = function(n) {\n      var begins_with, flag, m, value;\n      m = n.value.toString().match(/^\\/(.*)\\/([a-z]?)/);\n      value = m[1];\n      flag = m[2];\n      begins_with = value[0];\n      if (begins_with === ' ' || begins_with === '=') {\n        if (flag.length > 0) {\n          return this.l(n) + (\"RegExp(\" + (strEscape(value)) + \", \\\"\" + flag + \"\\\")\");\n        } else {\n          return this.l(n) + (\"RegExp(\" + (strEscape(value)) + \")\");\n        }\n      } else {\n        return this.l(n) + (\"/\" + value + \"/\" + flag);\n      }\n    };\n\n    Builder.prototype['string'] = function(n) {\n      return this.l(n) + strEscape(n.value);\n    };\n\n    Builder.prototype['call'] = function(n) {\n      if (n.right().children.length === 0) {\n        return (\"\" + (this.build(n.left())) + \"()\") + this.l(n);\n      } else {\n        return (\"\" + (this.build(n.left())) + \"(\" + (this.build(n.right())) + \")\") + this.l(n);\n      }\n    };\n\n    Builder.prototype['call_statement'] = function(n) {\n      var left;\n      left = this.build(n.left());\n      if (n.left().isA('function')) {\n        left = paren(left);\n      }\n      if (n.right().children.length === 0) {\n        return (\"\" + left + \"()\") + this.l(n);\n      } else {\n        return (\"\" + left + \" \" + (this.build(n.right()))) + this.l(n);\n      }\n    };\n\n    Builder.prototype['list'] = function(n, options) {\n      var list,\n        _this = this;\n      if (options == null) {\n        options = {};\n      }\n      list = _.map(n.children, function(item) {\n        var c, raw;\n        if (n.children.length > 1) {\n          item.is_list_element = true;\n        }\n        if (options.array === true && n.children.length > 0) {\n          raw = _this[item.typeName()](item);\n          c = new Code(_this, item);\n          c.scope(raw);\n          c = trim(c + Code.INDENT);\n          if (item.typeName() === 'object_init') {\n            c = \"{\\n\" + Code.INDENT + Code.INDENT + c + \"\\n\" + Code.INDENT + \"}\";\n          }\n          return c;\n        } else {\n          return _this.build(item);\n        }\n      });\n      if (options.array === true && n.children.length > 0) {\n        return this.l(n) + (\"\\n\" + Code.INDENT + (list.join('\\n' + Code.INDENT)));\n      } else {\n        return this.l(n) + list.join(\", \");\n      }\n    };\n\n    Builder.prototype['delete'] = function(n) {\n      var ids,\n        _this = this;\n      ids = _.map(n.children, function(el) {\n        return _this.build(el);\n      });\n      ids = ids.join(', ');\n      return this.l(n) + (\"delete \" + ids + \"\\n\");\n    };\n\n    Builder.prototype['.'] = function(n) {\n      var left, right, right_obj;\n      left = this.build(n.left());\n      right_obj = n.right();\n      right_obj.property_accessor = true;\n      right = this.build(right_obj);\n      if (n.isThis && n.isPrototype) {\n        return this.l(n) + \"@::\";\n      } else if (n.isThis) {\n        return this.l(n) + (\"@\" + right);\n      } else if (n.isPrototype) {\n        return this.l(n) + (\"\" + left + \"::\");\n      } else if (n.left().isPrototype) {\n        return this.l(n) + (\"\" + left + right);\n      } else {\n        return this.l(n) + (\"\" + left + \".\" + right);\n      }\n    };\n\n    Builder.prototype['try'] = function(n) {\n      var c,\n        _this = this;\n      c = new Code;\n      c.add('try');\n      c.scope(this.body(n.tryBlock));\n      _.each(n.catchClauses, function(clause) {\n        return c.add(_this.build(clause));\n      });\n      if (n.finallyBlock != null) {\n        c.add(\"finally\");\n        c.scope(this.body(n.finallyBlock));\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['catch'] = function(n) {\n      var body_, c;\n      body_ = this.body(n.block);\n      if (trim(body_).length === 0) {\n        return '';\n      }\n      c = new Code;\n      if (n.varName != null) {\n        c.add(\"catch \" + n.varName);\n      } else {\n        c.add('catch');\n      }\n      c.scope(this.body(n.block));\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['?'] = function(n) {\n      return this.l(n) + (\"(if \" + (this.build(n.left())) + \" then \" + (this.build(n.children[1])) + \" else \" + (this.build(n.children[2])) + \")\");\n    };\n\n    Builder.prototype['for'] = function(n) {\n      var c;\n      c = new Code;\n      if (n.setup != null) {\n        c.add(\"\" + (this.build(n.setup)) + \"\\n\");\n      }\n      if (n.condition != null) {\n        c.add(\"while \" + (this.build(n.condition)) + \"\\n\");\n      } else {\n        c.add(\"loop\");\n      }\n      c.scope(this.body(n.body));\n      if (n.update != null) {\n        c.scope(this.body(n.update));\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['for_in'] = function(n) {\n      var c;\n      c = new Code;\n      c.add(\"for \" + (this.build(n.iterator)) + \" of \" + (this.build(n.object)));\n      if (n.body.children.length > 0) {\n        c.scope(this.body(n.body));\n      } else {\n        c.scope(\"continue\");\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['while'] = function(n) {\n      var body_, c, keyword, statement;\n      c = new Code;\n      keyword = n.positive ? \"while\" : \"until\";\n      body_ = this.body(n.body);\n      if (truthy(n.condition)) {\n        statement = \"loop\";\n      } else {\n        statement = \"\" + keyword + \" \" + (this.build(n.condition));\n      }\n      if (isSingleLine(body_) && statement !== \"loop\") {\n        c.add(\"\" + (trim(body_)) + Code.INDENT + statement + \"\\n\");\n      } else {\n        c.add(statement);\n        c.scope(body_);\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['do'] = function(n) {\n      var c;\n      c = new Code;\n      c.add(\"loop\");\n      c.scope(this.body(n.body));\n      if (n.condition != null) {\n        c.scope(\"break unless \" + (this.build(n.condition)));\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['if'] = function(n) {\n      var body_, c, keyword;\n      c = new Code;\n      keyword = n.positive ? \"if\" : \"unless\";\n      body_ = this.body(n.thenPart);\n      n.condition.parenthesized = false;\n      if (n.thenPart.isA('block') && n.thenPart.children.length === 0 && (n.elsePart == null)) {\n        console.log(n.thenPart);\n        c.add(\"\" + (this.build(n.condition)) + \"\\n\");\n      } else if (isSingleLine(body_) && (n.elsePart == null)) {\n        c.add(\"\" + (trim(body_)) + Code.INDENT + keyword + \" \" + (this.build(n.condition)) + \"\\n\");\n      } else {\n        c.add(\"\" + keyword + \" \" + (this.build(n.condition)));\n        c.scope(this.body(n.thenPart));\n        if (n.elsePart != null) {\n          if (n.elsePart.typeName() === 'if') {\n            c.add(\"else \" + (this.build(n.elsePart).toString()));\n          } else {\n            c.add(this.l(n.elsePart) + \"else\\n\");\n            c.scope(this.body(n.elsePart));\n          }\n        }\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['switch'] = function(n) {\n      var c, fall_through,\n        _this = this;\n      c = new Code;\n      c.add(\"switch \" + (this.build(n.discriminant)) + \"\\n\");\n      fall_through = false;\n      _.each(n.cases, function(item) {\n        var first;\n        if (item.value === 'default') {\n          c.scope(_this.l(item) + \"else\");\n        } else {\n          if (fall_through === true) {\n            c.add(_this.l(item) + (\", \" + (_this.build(item.caseLabel)) + \"\\n\"));\n          } else {\n            c.add(_this.l(item) + (\"  when \" + (_this.build(item.caseLabel))));\n          }\n        }\n        if (_this.body(item.statements).length === 0) {\n          fall_through = true;\n        } else {\n          fall_through = false;\n          c.add(\"\\n\");\n          c.scope(_this.body(item.statements), 2);\n        }\n        return first = false;\n      });\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['existence_check'] = function(n) {\n      return this.l(n) + (\"\" + (this.build(n.left())) + \"?\");\n    };\n\n    Builder.prototype['array_init'] = function(n) {\n      var options;\n      options = {\n        array: true\n      };\n      if (n.children.length === 0) {\n        return this.l(n) + \"[]\";\n      } else if (n.children.length > 1) {\n        return this.l(n) + (\"[\" + (this.list(n, options)) + \"\\n]\");\n      } else {\n        return this.l(n) + (\"[\" + (this.list(n)) + \"]\");\n      }\n    };\n\n    Builder.prototype['property_init'] = function(n) {\n      var left, right;\n      left = n.left();\n      right = n.right();\n      right.is_property_value = true;\n      return \"\" + (this.property_identifier(left)) + \": \" + (this.build(right));\n    };\n\n    Builder.prototype['object_init'] = function(n, options) {\n      var c, list,\n        _this = this;\n      if (options == null) {\n        options = {};\n      }\n      if (n.children.length === 0) {\n        return this.l(n) + \"{}\";\n      } else if (n.children.length === 1 && !(n.is_property_value || n.is_list_element)) {\n        return this.build(n.children[0]);\n      } else {\n        list = _.map(n.children, function(item) {\n          return _this.build(item);\n        });\n        c = new Code(this, n);\n        c.scope(list.join(\"\\n\"));\n        if (options.brackets != null) {\n          c = \"{\" + c + \"}\";\n        }\n        return c;\n      }\n    };\n\n    Builder.prototype['function'] = function(n) {\n      var body, c, params,\n        _this = this;\n      c = new Code;\n      params = _.map(n.params, function(str) {\n        if (str.constructor === String) {\n          return _this.id_param(str);\n        } else {\n          return _this.build(str);\n        }\n      });\n      if (n.name) {\n        c.add(\"\" + n.name + \" = \");\n      }\n      if (n.params.length > 0) {\n        c.add(\"(\" + (params.join(', ')) + \") ->\");\n      } else {\n        c.add(\"->\");\n      }\n      body = this.body(n.body);\n      if (trim(body).length > 0) {\n        c.scope(body);\n      } else {\n        c.add(\"\\n\");\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['var'] = function(n) {\n      var list,\n        _this = this;\n      list = _.map(n.children, function(item) {\n        return \"\" + (unreserve(item.value)) + \" = \" + (item.initializer != null ? _this.build(item.initializer) : 'undefined');\n      });\n      return this.l(n) + _.compact(list).join(\"\\n\") + \"\\n\";\n    };\n\n    Builder.prototype['other'] = function(n) {\n      return this.unsupported(n, \"\" + (n.typeName()) + \" is not supported yet\");\n    };\n\n    Builder.prototype['getter'] = function(n) {\n      return this.unsupported(n, \"getter syntax is not supported; use __defineGetter__\");\n    };\n\n    Builder.prototype['setter'] = function(n) {\n      return this.unsupported(n, \"setter syntax is not supported; use __defineSetter__\");\n    };\n\n    Builder.prototype['label'] = function(n) {\n      return this.unsupported(n, \"labels are not supported by CoffeeScript\");\n    };\n\n    Builder.prototype['const'] = function(n) {\n      return this.unsupported(n, \"consts are not supported by CoffeeScript\");\n    };\n\n    Builder.prototype['block'] = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return this.script.apply(this, args);\n    };\n\n    Builder.prototype['unsupported'] = function(node, message) {\n      throw new UnsupportedError(\"Unsupported: \" + message, node);\n    };\n\n    return Builder;\n\n  })();\n\n  Transformer = (function() {\n    function Transformer() {}\n\n    Transformer.prototype.transform = function() {\n      var args, fn, node, type;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      node = args[0];\n      if (node.transformed != null) {\n        return;\n      }\n      type = node.typeName();\n      fn = this[type];\n      if (fn) {\n        fn.apply(this, args);\n        return node.transformed = true;\n      }\n    };\n\n    Transformer.prototype['script'] = function(n) {\n      var last,\n        _this = this;\n      n.functions = [];\n      n.nonfunctions = [];\n      _.each(n.children, function(item) {\n        if (item.isA('function')) {\n          return n.functions.push(item);\n        } else {\n          return n.nonfunctions.push(item);\n        }\n      });\n      last = null;\n      return _.each(n.nonfunctions, function(item) {\n        var expr;\n        if (item.expression != null) {\n          expr = item.expression;\n          if ((last != null ? last.isA('object_init') : void 0) && expr.isA('object_init')) {\n            item.parenthesized = true;\n          } else {\n            item.parenthesized = false;\n          }\n          return last = expr;\n        }\n      });\n    };\n\n    Transformer.prototype['.'] = function(n) {\n      if (n.left().isA('function')) {\n        n.left().parenthesized = true;\n      }\n      n.isThis = n.left().isA('this');\n      return n.isPrototype = n.right().isA('identifier') && n.right().value === 'prototype';\n    };\n\n    Transformer.prototype[';'] = function(n) {\n      if (n.expression != null) {\n        n.expression.parenthesized = false;\n        if (n.expression.isA('call')) {\n          n.expression.type = Typenames['call_statement'];\n          return this.call_statement(n);\n        }\n      }\n    };\n\n    Transformer.prototype['function'] = function(n) {\n      var nonreturns, transform_switch;\n      nonreturns = 0;\n      transform_switch = this[\"switch\"];\n      n.body.walk({\n        last: true\n      }, function(parent, node, list) {\n        var lastNode;\n        if (node.isA('switch')) {\n          transform_switch(node);\n        }\n        lastNode = list ? parent[list] : parent.children[parent.children.length - 1];\n        if (node.value && lastNode) {\n          if (node.isA('return')) {\n            lastNode.type = Typenames[';'];\n            return lastNode.expression = lastNode.value;\n          } else if (lastNode.isA('if', 'switch', 'block')) {\n\n          } else {\n            return nonreturns += 1;\n          }\n        }\n      });\n      if (nonreturns > 0) {\n        return n.body.children.push({\n          type: 'return',\n          typeName: function() {\n            return this.type;\n          },\n          isA: function(t) {\n            return t === this.type;\n          }\n        });\n      }\n    };\n\n    Transformer.prototype['switch'] = function(n) {\n      var _this = this;\n      return _.each(n.cases, function(item) {\n        var block, ch, _ref2;\n        block = item.statements;\n        ch = block.children;\n        if ((_ref2 = block.last()) != null ? _ref2.isA('break') : void 0) {\n          return delete ch[ch.length - 1];\n        }\n      });\n    };\n\n    Transformer.prototype['call_statement'] = function(n) {\n      if (n.children[1]) {\n        return _.each(n.children[1].children, function(child, i) {\n          if (child.isA('function') && i !== n.children[1].children.length - 1) {\n            return child.parenthesized = true;\n          }\n        });\n      }\n    };\n\n    Transformer.prototype['return'] = function(n) {\n      if (n.value && n.value.isA('object_init') && n.value.children.length > 1) {\n        return n.value.parenthesized = true;\n      }\n    };\n\n    Transformer.prototype['block'] = function(n) {\n      return this.script(n);\n    };\n\n    Transformer.prototype['if'] = function(n) {\n      var _ref2;\n      if (n.thenPart.isA('block') && n.thenPart.children.length === 0 && (!n.elsePartisA('block') || ((_ref2 = n.elsePart) != null ? _ref2.children.length : void 0) > 0)) {\n        n.positive = false;\n        n.thenPart = n.elsePart;\n        delete n.elsePart;\n      }\n      return this.inversible(n);\n    };\n\n    Transformer.prototype['while'] = function(n) {\n      if (n.body.children.length === 0) {\n        n.body.children.push(n.clone({\n          type: Typenames['continue'],\n          value: 'continue',\n          children: []\n        }));\n      }\n      return this.inversible(n);\n    };\n\n    Transformer.prototype['inversible'] = function(n) {\n      var positive;\n      this.transform(n.condition);\n      positive = n.positive != null ? n.positive : true;\n      if (n.condition.isA('!=')) {\n        n.condition.type = Typenames['=='];\n        return n.positive = !positive;\n      } else if (n.condition.isA('!')) {\n        n.condition = n.condition.left();\n        return n.positive = !positive;\n      } else {\n        return n.positive = positive;\n      }\n    };\n\n    Transformer.prototype['=='] = function(n) {\n      if (n.right().isA('null', 'void')) {\n        n.type = Typenames['!'];\n        return n.children = [\n          n.clone({\n            type: Typenames['existence_check'],\n            children: [n.left()]\n          })\n        ];\n      }\n    };\n\n    Transformer.prototype['!='] = function(n) {\n      if (n.right().isA('null', 'void')) {\n        n.type = Typenames['existence_check'];\n        return n.children = [n.left()];\n      }\n    };\n\n    return Transformer;\n\n  })();\n\n  UnsupportedError = (function() {\n    function UnsupportedError(str, src) {\n      this.message = str;\n      this.cursor = src.start;\n      this.line = src.lineno;\n      this.source = src.tokenizer.source;\n    }\n\n    UnsupportedError.prototype.toString = function() {\n      return this.message;\n    };\n\n    return UnsupportedError;\n\n  })();\n\n  this.Js2coffee = exports = {\n    VERSION: pkg.version,\n    build: buildCoffee,\n    UnsupportedError: UnsupportedError\n  };\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = exports;\n  }\n\n}).call(this);\n",
      "contentRenderedWithoutLayouts": "/* vim: set sw=4 ts=4 et tw=78: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (typeof module == 'undefined') {\n  this.Narcissus = new Object;\n}\n\nvar Narcissus = {\n    options: {\n        version: 185,\n    },\n    hostGlobal: this\n};\n\nNarcissus.definitions = (function() {\n\n    var tokens = [\n        // End of source.\n        \"END\",\n\n        // Operators and punctuators.  Some pair-wise order matters, e.g. (+, -)\n        // and (UNARY_PLUS, UNARY_MINUS).\n        \"\\n\", \";\",\n        \",\",\n        \"=\",\n        \"?\", \":\", \"CONDITIONAL\",\n        \"||\",\n        \"&&\",\n        \"|\",\n        \"^\",\n        \"&\",\n        \"==\", \"!=\", \"===\", \"!==\",\n        \"<\", \"<=\", \">=\", \">\",\n        \"<<\", \">>\", \">>>\",\n        \"+\", \"-\",\n        \"*\", \"/\", \"%\",\n        \"!\", \"~\", \"UNARY_PLUS\", \"UNARY_MINUS\",\n        \"++\", \"--\",\n        \".\",\n        \"[\", \"]\",\n        \"{\", \"}\",\n        \"(\", \")\",\n\n        // Nonterminal tree node type codes.\n        \"SCRIPT\", \"BLOCK\", \"LABEL\", \"FOR_IN\", \"CALL\", \"NEW_WITH_ARGS\", \"INDEX\",\n        \"ARRAY_INIT\", \"OBJECT_INIT\", \"PROPERTY_INIT\", \"GETTER\", \"SETTER\",\n        \"GROUP\", \"LIST\", \"LET_BLOCK\", \"ARRAY_COMP\", \"GENERATOR\", \"COMP_TAIL\",\n\n        // Terminals.\n        \"IDENTIFIER\", \"NUMBER\", \"STRING\", \"REGEXP\",\n\n        // Keywords.\n        \"break\",\n        \"case\", \"catch\", \"const\", \"continue\",\n        \"debugger\", \"default\", \"delete\", \"do\",\n        \"else\",\n        \"false\", \"finally\", \"for\", \"function\",\n        \"if\", \"in\", \"instanceof\",\n        \"let\",\n        \"new\", \"null\",\n        \"return\",\n        \"switch\",\n        \"this\", \"throw\", \"true\", \"try\", \"typeof\",\n        \"var\", \"void\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    var statementStartTokens = [\n        \"break\",\n        \"const\", \"continue\",\n        \"debugger\", \"do\",\n        \"for\",\n        \"if\",\n        \"return\",\n        \"switch\",\n        \"throw\", \"try\",\n        \"var\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    // Operator and punctuator mapping from token to tree node type name.\n    // NB: because the lexer doesn't backtrack, all token prefixes must themselves\n    // be valid tokens (e.g. !== is acceptable because its prefixes are the valid\n    // tokens != and !).\n    var opTypeNames = {\n        '\\n':   \"NEWLINE\",\n        ';':    \"SEMICOLON\",\n        ',':    \"COMMA\",\n        '?':    \"HOOK\",\n        ':':    \"COLON\",\n        '||':   \"OR\",\n        '&&':   \"AND\",\n        '|':    \"BITWISE_OR\",\n        '^':    \"BITWISE_XOR\",\n        '&':    \"BITWISE_AND\",\n        '===':  \"STRICT_EQ\",\n        '==':   \"EQ\",\n        '=':    \"ASSIGN\",\n        '!==':  \"STRICT_NE\",\n        '!=':   \"NE\",\n        '<<':   \"LSH\",\n        '<=':   \"LE\",\n        '<':    \"LT\",\n        '>>>':  \"URSH\",\n        '>>':   \"RSH\",\n        '>=':   \"GE\",\n        '>':    \"GT\",\n        '++':   \"INCREMENT\",\n        '--':   \"DECREMENT\",\n        '+':    \"PLUS\",\n        '-':    \"MINUS\",\n        '*':    \"MUL\",\n        '/':    \"DIV\",\n        '%':    \"MOD\",\n        '!':    \"NOT\",\n        '~':    \"BITWISE_NOT\",\n        '.':    \"DOT\",\n        '[':    \"LEFT_BRACKET\",\n        ']':    \"RIGHT_BRACKET\",\n        '{':    \"LEFT_CURLY\",\n        '}':    \"RIGHT_CURLY\",\n        '(':    \"LEFT_PAREN\",\n        ')':    \"RIGHT_PAREN\"\n    };\n\n    // Hash of keyword identifier to tokens index.  NB: we must null __proto__ to\n    // avoid toString, etc. namespace pollution.\n    var keywords = {__proto__: null};\n\n    // Define const END, etc., based on the token names.  Also map name to index.\n    var tokenIds = {};\n\n    // Building up a string to be eval'd in different contexts.\n    var consts = \"const \";\n    for (var i = 0, j = tokens.length; i < j; i++) {\n        if (i > 0)\n            consts += \", \";\n        var t = tokens[i];\n        var name;\n        if (/^[a-z]/.test(t)) {\n            name = t.toUpperCase();\n            keywords[t] = i;\n        } else {\n            name = (/^\\W/.test(t) ? opTypeNames[t] : t);\n        }\n        consts += name + \" = \" + i;\n        tokenIds[name] = i;\n        tokens[t] = i;\n    }\n    consts += \";\";\n\n    var isStatementStartCode = {__proto__: null};\n    for (i = 0, j = statementStartTokens.length; i < j; i++)\n        isStatementStartCode[keywords[statementStartTokens[i]]] = true;\n\n    // Map assignment operators to their indexes in the tokens array.\n    var assignOps = ['|', '^', '&', '<<', '>>', '>>>', '+', '-', '*', '/', '%'];\n\n    for (i = 0, j = assignOps.length; i < j; i++) {\n        t = assignOps[i];\n        assignOps[t] = tokens[t];\n    }\n\n    function defineGetter(obj, prop, fn, dontDelete, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { get: fn, configurable: !dontDelete, enumerable: !dontEnum });\n    }\n\n    function defineProperty(obj, prop, val, dontDelete, readOnly, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { value: val, writable: !readOnly, configurable: !dontDelete,\n                                enumerable: !dontEnum });\n    }\n\n    // Returns true if fn is a native function.  (Note: SpiderMonkey specific.)\n    function isNativeCode(fn) {\n        // Relies on the toString method to identify native code.\n        return ((typeof fn) === \"function\") && fn.toString().match(/\\[native code\\]/);\n    }\n\n    function getPropertyDescriptor(obj, name) {\n        while (obj) {\n            if (({}).hasOwnProperty.call(obj, name))\n                return Object.getOwnPropertyDescriptor(obj, name);\n            obj = Object.getPrototypeOf(obj);\n        }\n    }\n\n    function getOwnProperties(obj) {\n        var map = {};\n        for (var name in Object.getOwnPropertyNames(obj))\n            map[name] = Object.getOwnPropertyDescriptor(obj, name);\n        return map;\n    }\n\n    function makePassthruHandler(obj) {\n        // Handler copied from\n        // http://wiki.ecmascript.org/doku.php?id=harmony:proxies&s=proxy%20object#examplea_no-op_forwarding_proxy\n        return {\n            getOwnPropertyDescriptor: function(name) {\n                var desc = Object.getOwnPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getPropertyDescriptor: function(name) {\n                var desc = getPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getOwnPropertyNames: function() {\n                return Object.getOwnPropertyNames(obj);\n            },\n            defineProperty: function(name, desc) {\n                Object.defineProperty(obj, name, desc);\n            },\n            \"delete\": function(name) { return delete obj[name]; },\n            fix: function() {\n                if (Object.isFrozen(obj)) {\n                    return getOwnProperties(obj);\n                }\n\n                // As long as obj is not frozen, the proxy won't allow itself to be fixed.\n                return undefined; // will cause a TypeError to be thrown\n            },\n\n            has: function(name) { return name in obj; },\n            hasOwn: function(name) { return ({}).hasOwnProperty.call(obj, name); },\n            get: function(receiver, name) { return obj[name]; },\n\n            // bad behavior when set fails in non-strict mode\n            set: function(receiver, name, val) { obj[name] = val; return true; },\n            enumerate: function() {\n                var result = [];\n                for (name in obj) { result.push(name); };\n                return result;\n            },\n            keys: function() { return Object.keys(obj); }\n        };\n    }\n\n    // default function used when looking for a property in the global object\n    function noPropFound() { return undefined; }\n\n    var hasOwnProperty = ({}).hasOwnProperty;\n\n    function StringMap() {\n        this.table = Object.create(null, {});\n        this.size = 0;\n    }\n\n    StringMap.prototype = {\n        has: function(x) { return hasOwnProperty.call(this.table, x); },\n        set: function(x, v) {\n            if (!hasOwnProperty.call(this.table, x))\n                this.size++;\n            this.table[x] = v;\n        },\n        get: function(x) { return this.table[x]; },\n        getDef: function(x, thunk) {\n            if (!hasOwnProperty.call(this.table, x)) {\n                this.size++;\n                this.table[x] = thunk();\n            }\n            return this.table[x];\n        },\n        forEach: function(f) {\n            var table = this.table;\n            for (var key in table)\n                f.call(this, key, table[key]);\n        },\n        toString: function() { return \"[object StringMap]\" }\n    };\n\n    // non-destructive stack\n    function Stack(elts) {\n        this.elts = elts || null;\n    }\n\n    Stack.prototype = {\n        push: function(x) {\n            return new Stack({ top: x, rest: this.elts });\n        },\n        top: function() {\n            if (!this.elts)\n                throw new Error(\"empty stack\");\n            return this.elts.top;\n        },\n        isEmpty: function() {\n            return this.top === null;\n        },\n        find: function(test) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                if (test(elts.top))\n                    return elts.top;\n            }\n            return null;\n        },\n        has: function(x) {\n            return Boolean(this.find(function(elt) { return elt === x }));\n        },\n        forEach: function(f) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                f(elts.top);\n            }\n        }\n    };\n\n    return {\n        tokens: tokens,\n        opTypeNames: opTypeNames,\n        keywords: keywords,\n        isStatementStartCode: isStatementStartCode,\n        tokenIds: tokenIds,\n        consts: consts,\n        assignOps: assignOps,\n        defineGetter: defineGetter,\n        defineProperty: defineProperty,\n        isNativeCode: isNativeCode,\n        makePassthruHandler: makePassthruHandler,\n        noPropFound: noPropFound,\n        StringMap: StringMap,\n        Stack: Stack\n    };\n}());\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Lexical scanner.\n */\n\nNarcissus.lexer = (function() {\n\n    var definitions = Narcissus.definitions;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    // Build up a trie of operator tokens.\n    var opTokens = {};\n    for (var op in definitions.opTypeNames) {\n        if (op === '\\n' || op === '.')\n            continue;\n\n        var node = opTokens;\n        for (var i = 0; i < op.length; i++) {\n            var ch = op[i];\n            if (!(ch in node))\n                node[ch] = {};\n            node = node[ch];\n            node.op = op;\n        }\n    }\n\n    /*\n     * Tokenizer :: (source, filename, line number) -> Tokenizer\n     */\n    function Tokenizer(s, f, l) {\n        this.cursor = 0;\n        this.source = String(s);\n        this.tokens = [];\n        this.tokenIndex = 0;\n        this.lookahead = 0;\n        this.scanNewlines = false;\n        this.unexpectedEOF = false;\n        this.filename = f || \"\";\n        this.lineno = l || 1;\n        this.comments = [];\n    }\n\n    Tokenizer.prototype = {\n        get done() {\n            // We need to set scanOperand to true here because the first thing\n            // might be a regexp.\n            return this.peek(true) === END;\n        },\n\n        get token() {\n            return this.tokens[this.tokenIndex];\n        },\n\n        match: function (tt, scanOperand) {\n            return this.get(scanOperand) === tt || this.unget();\n        },\n\n        mustMatch: function (tt) {\n            if (!this.match(tt)) {\n                throw this.newSyntaxError(\"Missing \" +\n                                          definitions.tokens[tt].toLowerCase());\n            }\n            return this.token;\n        },\n\n        peek: function (scanOperand) {\n            var tt, next;\n            if (this.lookahead) {\n                next = this.tokens[(this.tokenIndex + this.lookahead) & 3];\n                tt = (this.scanNewlines && next.lineno !== this.lineno)\n                     ? NEWLINE\n                     : next.type;\n            } else {\n                tt = this.get(scanOperand);\n                this.unget();\n            }\n            return tt;\n        },\n\n        peekOnSameLine: function (scanOperand) {\n            this.scanNewlines = true;\n            var tt = this.peek(scanOperand);\n            this.scanNewlines = false;\n            return tt;\n        },\n\n        // Eat comments and whitespace.\n        // toka: returns list of skipped comments\n        skip: function () {\n            var input = this.source;\n            var cstart;\n            var clineno;\n            var comments = [];\n            var comment;\n            var nlcount = 0;\n\n            for (;;) {\n                var ch = input[this.cursor++];\n                var next = input[this.cursor];\n                if (ch === '\\n' && !this.scanNewlines) {\n                    this.lineno++;\n                    nlcount++;\n                } else if (ch === '/' && next === '*') {\n                    cstart = this.cursor;\n                    clineno = this.lineno;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated comment\");\n\n                        if (ch === '*') {\n                            next = input[this.cursor];\n                            if (next === '/') {\n                                this.cursor++;\n                                comment = {\n                                    type: \"BLOCK_COMMENT\",\n                                    nlcount: nlcount,\n                                    start:cstart-1, end:this.cursor, lineno:clineno, endlineno: this.lineno,\n                                    value: input.substring(cstart+1,this.cursor-2)\n                                }\n                                // comments.push(comment);\n                                this.comments.push(comment);\n                                nlcount = 0;\n                                break;\n                            }\n                        } else if (ch === '\\n') {\n                            this.lineno++;\n                        }\n                    }\n                } else if (ch === '/' && next === '/') {\n                    cstart = this.cursor;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined) {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            // comments.push(comment);\n                            this.comments.push(comment);\n                            return;\n                            // return comments;\n                        }\n                        if (ch === '\\n') {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            //comments.push(  );\n                            this.comments.push(comment);\n                            nlcount = 0;\n                            this.lineno++;\n                            break;\n                        }\n                    }\n                } else if (ch !== ' ' && ch !== '\\t') {\n                    this.cursor--;\n                    // return comments;\n                    return;\n                }\n            }\n        },\n\n        // Lex the exponential part of a number, if present. Return true iff an\n        // exponential part was found.\n        lexExponent: function() {\n            var input = this.source;\n            var next = input[this.cursor];\n            if (next === 'e' || next === 'E') {\n                this.cursor++;\n                ch = input[this.cursor++];\n                if (ch === '+' || ch === '-')\n                    ch = input[this.cursor++];\n\n                if (ch < '0' || ch > '9')\n                    throw this.newSyntaxError(\"Missing exponent\");\n\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                return true;\n            }\n\n            return false;\n        },\n\n        lexZeroNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            ch = input[this.cursor++];\n            if (ch === '.') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n                token.value = parseFloat(token.start, this.cursor);\n            } else if (ch === 'x' || ch === 'X') {\n                do {\n                    ch = input[this.cursor++];\n                } while ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||\n                         (ch >= 'A' && ch <= 'F'));\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else if (ch >= '0' && ch <= '7') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '7');\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else {\n                this.cursor--;\n                this.lexExponent();     // 0E1, &c.\n                token.value = 0;\n            }\n        },\n\n        lexNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            var floating = false;\n            do {\n                ch = input[this.cursor++];\n                if (ch === '.' && !floating) {\n                    floating = true;\n                    ch = input[this.cursor++];\n                }\n            } while (ch >= '0' && ch <= '9');\n\n            this.cursor--;\n\n            var exponent = this.lexExponent();\n            floating = floating || exponent;\n\n            var str = input.substring(token.start, this.cursor);\n            token.value = floating ? parseFloat(str) : parseInt(str);\n        },\n\n        lexDot: function (ch) {\n            var token = this.token, input = this.source;\n            var next = input[this.cursor];\n            if (next >= '0' && next <= '9') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n\n                token.type = NUMBER;\n                token.value = parseFloat(token.start, this.cursor);\n            } else {\n                token.type = DOT;\n                token.assignOp = null;\n                token.value = '.';\n            }\n        },\n\n        lexString: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = STRING;\n\n            var hasEscapes = false;\n            var delim = ch;\n            while ((ch = input[this.cursor++]) !== delim) {\n                // [JS2COFFEE] Fixed to make it work on a browser\n                if (this.cursor >= input.length)\n                    throw this.newSyntaxError(\"Unterminated string literal\");\n                if (ch === '\\\\') {\n                    hasEscapes = true;\n                    if (++this.cursor == input.length)\n                        throw this.newSyntaxError(\"Unterminated string literal\");\n                }\n            }\n\n            token.value = hasEscapes\n                          ? eval(input.substring(token.start, this.cursor))\n                          : input.substring(token.start + 1, this.cursor - 1);\n        },\n\n        lexRegExp: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = REGEXP;\n\n            do {\n                ch = input[this.cursor++];\n                if (ch === '\\\\') {\n                    this.cursor++;\n                } else if (ch === '[') {\n                    do {\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated character class\");\n\n                        if (ch === '\\\\')\n                            this.cursor++;\n\n                        ch = input[this.cursor++];\n                    } while (ch !== ']');\n                } else if (ch === undefined) {\n                    throw this.newSyntaxError(\"Unterminated regex\");\n                }\n            } while (ch !== '/');\n\n            do {\n                ch = input[this.cursor++];\n            } while (ch >= 'a' && ch <= 'z');\n\n            this.cursor--;\n\n            token.value = eval(input.substring(token.start, this.cursor));\n        },\n\n        lexOp: function (ch) {\n            var token = this.token, input = this.source;\n\n            // A bit ugly, but it seems wasteful to write a trie lookup routine\n            // for only 3 characters...\n            var node = opTokens[ch];\n            var next = input[this.cursor];\n            if (next in node) {\n                node = node[next];\n                this.cursor++;\n                next = input[this.cursor];\n                if (next in node) {\n                    node = node[next];\n                    this.cursor++;\n                    next = input[this.cursor];\n                }\n            }\n\n            var op = node.op;\n            if (definitions.assignOps[op] && input[this.cursor] === '=') {\n                this.cursor++;\n                token.type = ASSIGN;\n                token.assignOp = definitions.tokenIds[definitions.opTypeNames[op]];\n                op += '=';\n            } else {\n                token.type = definitions.tokenIds[definitions.opTypeNames[op]];\n                token.assignOp = null;\n            }\n\n            token.value = op;\n        },\n\n        // FIXME: Unicode escape sequences\n        // FIXME: Unicode identifiers\n        lexIdent: function (ch) {\n            var token = this.token, input = this.source;\n\n            do {\n                ch = input[this.cursor++];\n            } while ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n                     (ch >= '0' && ch <= '9') || ch === '$' || ch === '_');\n\n            this.cursor--;  // Put the non-word character back.\n\n            var id = input.substring(token.start, this.cursor);\n            token.type = definitions.keywords[id] || IDENTIFIER;\n            token.value = id;\n        },\n\n        /*\n         * Tokenizer.get :: void -> token type\n         *\n         * Consume input *only* if there is no lookahead.\n         * Dispatch to the appropriate lexing function depending on the input.\n         */\n        get: function (scanOperand) {\n            var token;\n            while (this.lookahead) {\n                --this.lookahead;\n                this.tokenIndex = (this.tokenIndex + 1) & 3;\n                token = this.tokens[this.tokenIndex];\n                if (token.type !== NEWLINE || this.scanNewlines)\n                    return token.type;\n            }\n\n            // var comments =\n            this.skip();\n\n            this.tokenIndex = (this.tokenIndex + 1) & 3;\n            token = this.tokens[this.tokenIndex];\n            if (!token)\n                this.tokens[this.tokenIndex] = token = {};\n\n            var input = this.source;\n            if (this.cursor === input.length)\n                return token.type = END;\n\n            token.start = this.cursor;\n            token.lineno = this.lineno;\n\n            var ch = input[this.cursor++];\n            if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '$' || ch === '_') {\n                this.lexIdent(ch);\n            } else if (scanOperand && ch === '/') {\n                this.lexRegExp(ch);\n            } else if (ch in opTokens) {\n                this.lexOp(ch);\n            } else if (ch === '.') {\n                this.lexDot(ch);\n            } else if (ch >= '1' && ch <= '9') {\n                this.lexNumber(ch);\n            } else if (ch === '0') {\n                this.lexZeroNumber(ch);\n            } else if (ch === '\"' || ch === \"'\") {\n                this.lexString(ch);\n            } else if (this.scanNewlines && ch === '\\n') {\n                token.type = NEWLINE;\n                token.value = '\\n';\n                this.lineno++;\n            } else {\n                throw this.newSyntaxError(\"Illegal token\");\n            }\n\n            token.end = this.cursor;\n            // token.comments = [comments,this.skip()];\n            return token.type;\n        },\n\n        /*\n         * Tokenizer.unget :: void -> undefined\n         *\n         * Match depends on unget returning undefined.\n         */\n        unget: function () {\n            if (++this.lookahead === 4) throw \"PANIC: too much lookahead!\";\n            this.tokenIndex = (this.tokenIndex - 1) & 3;\n        },\n\n        newSyntaxError: function (m) {\n            var e = new SyntaxError(m, this.filename, this.lineno);\n            e.source = this.source;\n            e.cursor = this.lookahead\n                       ? this.tokens[(this.tokenIndex + this.lookahead) & 3].start\n                       : this.cursor;\n            return e;\n        },\n    };\n\n    return { Tokenizer: Tokenizer };\n\n}());\n\n/* -*- Mode: JS; tab-width: 4; indent-tabs-mode: nil; -*-\n * vim: set sw=4 ts=4 et tw=78:\n * ***** BEGIN LICENSE BLOCK *****\n *\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Parser.\n */\n\nNarcissus.parser = (function() {\n\n    var lexer = Narcissus.lexer;\n    var definitions = Narcissus.definitions;\n\n    const StringMap = definitions.StringMap;\n    const Stack = definitions.Stack;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    /*\n     * pushDestructuringVarDecls :: (node, hoisting node) -> void\n     *\n     * Recursively add all destructured declarations to varDecls.\n     */\n    function pushDestructuringVarDecls(n, s) {\n        for (var i in n) {\n            var sub = n[i];\n            if (sub.type === IDENTIFIER) {\n                s.varDecls.push(sub);\n            } else {\n                pushDestructuringVarDecls(sub, s);\n            }\n        }\n    }\n\n    // NESTING_TOP: top-level\n    // NESTING_SHALLOW: nested within static forms such as { ... } or labeled statement\n    // NESTING_DEEP: nested within dynamic forms such as if, loops, etc.\n    const NESTING_TOP = 0, NESTING_SHALLOW = 1, NESTING_DEEP = 2;\n\n    function StaticContext(parentScript, parentBlock, inFunction, inForLoopInit, nesting) {\n        this.parentScript = parentScript;\n        this.parentBlock = parentBlock;\n        this.inFunction = inFunction;\n        this.inForLoopInit = inForLoopInit;\n        this.nesting = nesting;\n        this.allLabels = new Stack();\n        this.currentLabels = new Stack();\n        this.labeledTargets = new Stack();\n        this.defaultTarget = null;\n        Narcissus.options.ecma3OnlyMode && (this.ecma3OnlyMode = true);\n        Narcissus.options.parenFreeMode && (this.parenFreeMode = true);\n    }\n\n    StaticContext.prototype = {\n        ecma3OnlyMode: false,\n        parenFreeMode: false,\n        // non-destructive update via prototype extension\n        update: function(ext) {\n            var desc = {};\n            for (var key in ext) {\n                desc[key] = {\n                    value: ext[key],\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                }\n            }\n            return Object.create(this, desc);\n        },\n        pushLabel: function(label) {\n            return this.update({ currentLabels: this.currentLabels.push(label),\n                                 allLabels: this.allLabels.push(label) });\n        },\n        pushTarget: function(target) {\n            var isDefaultTarget = target.isLoop || target.type === SWITCH;\n\n            if (this.currentLabels.isEmpty()) {\n                return isDefaultTarget\n                     ? this.update({ defaultTarget: target })\n                     : this;\n            }\n\n            target.labels = new StringMap();\n            this.currentLabels.forEach(function(label) {\n                target.labels.set(label, true);\n            });\n            return this.update({ currentLabels: new Stack(),\n                                 labeledTargets: this.labeledTargets.push(target),\n                                 defaultTarget: isDefaultTarget\n                                                ? target\n                                                : this.defaultTarget });\n        },\n        nest: function(atLeast) {\n            var nesting = Math.max(this.nesting, atLeast);\n            return (nesting !== this.nesting)\n                 ? this.update({ nesting: nesting })\n                 : this;\n        }\n    };\n\n    /*\n     * Script :: (tokenizer, boolean) -> node\n     *\n     * Parses the toplevel and function bodies.\n     */\n    function Script(t, inFunction) {\n        var n = new Node(t, scriptInit());\n        var x = new StaticContext(n, n, inFunction, false, NESTING_TOP);\n        Statements(t, x, n);\n        return n;\n    }\n\n    // We extend Array slightly with a top-of-stack method.\n    definitions.defineProperty(Array.prototype, \"top\",\n                               function() {\n                                   return this.length && this[this.length-1];\n                               }, false, false, true);\n\n    /*\n     * Node :: (tokenizer, optional init object) -> node\n     */\n    function Node(t, init) {\n        var token = t.token;\n        if (token) {\n            // If init.type exists it will override token.type.\n            this.type = token.type;\n            this.value = token.value;\n            this.lineno = token.lineno;\n\n            // Start and end are file positions for error handling.\n            this.start = token.start;\n            this.end = token.end;\n\n        } else {\n            this.lineno = t.lineno;\n        }\n\n        // Node uses a tokenizer for debugging (getSource, filename getter).\n        this.tokenizer = t;\n        this.children = [];\n\n        for (var prop in init)\n            this[prop] = init[prop];\n    }\n\n    var Np = Node.prototype = {};\n    Np.constructor = Node;\n    Np.toSource = Object.prototype.toSource;\n\n    // Always use push to add operands to an expression, to update start and end.\n    Np.push = function (kid) {\n        // kid can be null e.g. [1, , 2].\n        if (kid !== null) {\n            if (kid.start < this.start)\n                this.start = kid.start;\n            if (this.end < kid.end)\n                this.end = kid.end;\n        }\n        return this.children.push(kid);\n    }\n\n    Node.indentLevel = 0;\n\n    function tokenString(tt) {\n        var t = definitions.tokens[tt];\n        return /^\\W/.test(t) ? definitions.opTypeNames[t] : t.toUpperCase();\n    }\n\n    Np.toString = function () {\n        var a = [];\n        for (var i in this) {\n            if (this.hasOwnProperty(i) && i !== 'type' && i !== 'target')\n                a.push({id: i, value: this[i]});\n        }\n        a.sort(function (a,b) { return (a.id < b.id) ? -1 : 1; });\n        const INDENTATION = \"    \";\n        var n = ++Node.indentLevel;\n        var s = \"{\\n\" + INDENTATION.repeat(n) + \"type: \" + tokenString(this.type);\n        for (i = 0; i < a.length; i++)\n            s += \",\\n\" + INDENTATION.repeat(n) + a[i].id + \": \" + a[i].value;\n        n = --Node.indentLevel;\n        s += \"\\n\" + INDENTATION.repeat(n) + \"}\";\n        return s;\n    }\n\n    Np.getSource = function () {\n        return this.tokenizer.source.slice(this.start, this.end);\n    };\n\n    /*\n     * Helper init objects for common nodes.\n     */\n\n    const LOOP_INIT = { isLoop: true };\n\n    function blockInit() {\n        return { type: BLOCK, varDecls: [] };\n    }\n\n    function scriptInit() {\n        return { type: SCRIPT,\n                 funDecls: [],\n                 varDecls: [],\n                 modDecls: [],\n                 impDecls: [],\n                 expDecls: [],\n                 loadDeps: [],\n                 hasEmptyReturn: false,\n                 hasReturnWithValue: false,\n                 isGenerator: false };\n    }\n\n    definitions.defineGetter(Np, \"filename\",\n                             function() {\n                                 return this.tokenizer.filename;\n                             });\n\n    definitions.defineGetter(Np, \"length\",\n                             function() {\n                                 throw new Error(\"Node.prototype.length is gone; \" +\n                                                 \"use n.children.length instead\");\n                             });\n\n    definitions.defineProperty(String.prototype, \"repeat\",\n                               function(n) {\n                                   var s = \"\", t = this + s;\n                                   while (--n >= 0)\n                                       s += t;\n                                   return s;\n                               }, false, false, true);\n\n    function MaybeLeftParen(t, x) {\n        if (x.parenFreeMode)\n            return t.match(LEFT_PAREN) ? LEFT_PAREN : END;\n        return t.mustMatch(LEFT_PAREN).type;\n    }\n\n    function MaybeRightParen(t, p) {\n        if (p === LEFT_PAREN)\n            t.mustMatch(RIGHT_PAREN);\n    }\n\n    /*\n     * Statements :: (tokenizer, compiler context, node) -> void\n     *\n     * Parses a sequence of Statements.\n     */\n    function Statements(t, x, n) {\n        try {\n            while (!t.done && t.peek(true) !== RIGHT_CURLY)\n            { n.push(Statement(t, x)); }\n        } catch (e) {\n            if (t.done)\n            { t.unexpectedEOF = true; }\n            throw(e);\n        }\n    }\n\n    function Block(t, x) {\n        t.mustMatch(LEFT_CURLY);\n        var n = new Node(t, blockInit());\n        Statements(t, x.update({ parentBlock: n }).pushTarget(n), n);\n        t.mustMatch(RIGHT_CURLY);\n        return n;\n    }\n\n    const DECLARED_FORM = 0, EXPRESSED_FORM = 1, STATEMENT_FORM = 2;\n\n    /*\n     * Statement :: (tokenizer, compiler context) -> node\n     *\n     * Parses a Statement.\n     */\n    function Statement(t, x) {\n        var i, label, n, n2, p, c, ss, tt = t.get(true), tt2, x2, x3;\n\n        // Cases for statements ending in a right curly return early, avoiding the\n        // common semicolon insertion magic after this switch.\n        switch (tt) {\n          case FUNCTION:\n            // DECLARED_FORM extends funDecls of x, STATEMENT_FORM doesn't.\n            return FunctionDefinition(t, x, true,\n                                      (x.nesting !== NESTING_TOP)\n                                      ? STATEMENT_FORM\n                                      : DECLARED_FORM);\n\n          case LEFT_CURLY:\n            n = new Node(t, blockInit());\n            Statements(t, x.update({ parentBlock: n }).pushTarget(n).nest(NESTING_SHALLOW), n);\n            t.mustMatch(RIGHT_CURLY);\n            return n;\n\n          case IF:\n            n = new Node(t);\n            n.condition = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            n.thenPart = Statement(t, x2);\n            n.elsePart = t.match(ELSE) ? Statement(t, x2) : null;\n            return n;\n\n          case SWITCH:\n            // This allows CASEs after a DEFAULT, which is in the standard.\n            n = new Node(t, { cases: [], defaultIndex: -1 });\n            n.discriminant = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            t.mustMatch(LEFT_CURLY);\n            while ((tt = t.get()) !== RIGHT_CURLY) {\n                switch (tt) {\n                  case DEFAULT:\n                    if (n.defaultIndex >= 0)\n                        throw t.newSyntaxError(\"More than one switch default\");\n                    // FALL THROUGH\n                  case CASE:\n                    n2 = new Node(t);\n                    if (tt === DEFAULT)\n                        n.defaultIndex = n.cases.length;\n                    else\n                        n2.caseLabel = Expression(t, x2, COLON);\n                    break;\n\n                  default:\n                    throw t.newSyntaxError(\"Invalid switch case\");\n                }\n                t.mustMatch(COLON);\n                n2.statements = new Node(t, blockInit());\n                while ((tt=t.peek(true)) !== CASE && tt !== DEFAULT &&\n                        tt !== RIGHT_CURLY)\n                    n2.statements.push(Statement(t, x2));\n                n.cases.push(n2);\n            }\n            return n;\n\n          case FOR:\n            n = new Node(t, LOOP_INIT);\n            if (t.match(IDENTIFIER)) {\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(LEFT_PAREN);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            x3 = x.update({ inForLoopInit: true });\n            if ((tt = t.peek()) !== SEMICOLON) {\n                if (tt === VAR || tt === CONST) {\n                    t.get();\n                    n2 = Variables(t, x3);\n                } else if (tt === LET) {\n                    t.get();\n                    if (t.peek() === LEFT_PAREN) {\n                        n2 = LetBlock(t, x3, false);\n                    } else {\n                        // Let in for head, we need to add an implicit block\n                        // around the rest of the for.\n                        x3.parentBlock = n;\n                        n.varDecls = [];\n                        n2 = Variables(t, x3);\n                    }\n                } else {\n                    n2 = Expression(t, x3);\n                }\n            }\n            if (n2 && t.match(IN)) {\n                n.type = FOR_IN;\n                n.object = Expression(t, x3);\n                if (n2.type === VAR || n2.type === LET) {\n                    c = n2.children;\n\n                    // Destructuring turns one decl into multiples, so either\n                    // there must be only one destructuring or only one\n                    // decl.\n                    if (c.length !== 1 && n2.destructurings.length !== 1) {\n                        throw new SyntaxError(\"Invalid for..in left-hand side\",\n                                              t.filename, n2.lineno);\n                    }\n                    if (n2.destructurings.length > 0) {\n                        n.iterator = n2.destructurings[0];\n                    } else {\n                        n.iterator = c[0];\n                    }\n                    n.varDecl = n2;\n                } else {\n                    if (n2.type === ARRAY_INIT || n2.type === OBJECT_INIT) {\n                        n2.destructuredNames = checkDestructuring(t, x3, n2);\n                    }\n                    n.iterator = n2;\n                }\n            } else {\n                n.setup = n2;\n                t.mustMatch(SEMICOLON);\n                if (n.isEach)\n                    throw t.newSyntaxError(\"Invalid for each..in loop\");\n                n.condition = (t.peek() === SEMICOLON)\n                              ? null\n                              : Expression(t, x3);\n                t.mustMatch(SEMICOLON);\n                tt2 = t.peek();\n                n.update = (x.parenFreeMode\n                            ? tt2 === LEFT_CURLY || definitions.isStatementStartCode[tt2]\n                            : tt2 === RIGHT_PAREN)\n                           ? null\n                           : Expression(t, x3);\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(RIGHT_PAREN);\n            n.body = Statement(t, x2);\n            return n;\n\n          case WHILE:\n            n = new Node(t, { isLoop: true });\n            n.condition = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case DO:\n            n = new Node(t, { isLoop: true });\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            t.mustMatch(WHILE);\n            n.condition = HeadExpression(t, x);\n            if (!x.ecmaStrictMode) {\n                // <script language=\"JavaScript\"> (without version hints) may need\n                // automatic semicolon insertion without a newline after do-while.\n                // See http://bugzilla.mozilla.org/show_bug.cgi?id=238945.\n                t.match(SEMICOLON);\n                return n;\n            }\n            break;\n\n          case BREAK:\n          case CONTINUE:\n            n = new Node(t);\n\n            // handle the |foo: break foo;| corner case\n            x2 = x.pushTarget(n);\n\n            if (t.peekOnSameLine() === IDENTIFIER) {\n                t.get();\n                n.label = t.token.value;\n            }\n\n            n.target = n.label\n                     ? x2.labeledTargets.find(function(target) { return target.labels.has(n.label) })\n                     : x2.defaultTarget;\n\n            if (!n.target)\n                throw t.newSyntaxError(\"Invalid \" + ((tt === BREAK) ? \"break\" : \"continue\"));\n            if (!n.target.isLoop && tt === CONTINUE)\n                throw t.newSyntaxError(\"Invalid continue\");\n\n            break;\n\n          case TRY:\n            n = new Node(t, { catchClauses: [] });\n            n.tryBlock = Block(t, x);\n            while (t.match(CATCH)) {\n                n2 = new Node(t);\n                p = MaybeLeftParen(t, x);\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured catch identifiers.\n                    t.unget();\n                    n2.varName = DestructuringExpression(t, x, true);\n                    break;\n                  case IDENTIFIER:\n                    n2.varName = t.token.value;\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing identifier in catch\");\n                    break;\n                }\n                if (t.match(IF)) {\n                    if (x.ecma3OnlyMode)\n                        throw t.newSyntaxError(\"Illegal catch guard\");\n                    if (n.catchClauses.length && !n.catchClauses.top().guard)\n                        throw t.newSyntaxError(\"Guarded catch after unguarded\");\n                    n2.guard = Expression(t, x);\n                }\n                MaybeRightParen(t, p);\n                n2.block = Block(t, x);\n                n.catchClauses.push(n2);\n            }\n            if (t.match(FINALLY))\n                n.finallyBlock = Block(t, x);\n            if (!n.catchClauses.length && !n.finallyBlock)\n                throw t.newSyntaxError(\"Invalid try statement\");\n            return n;\n\n          case CATCH:\n          case FINALLY:\n            throw t.newSyntaxError(definitions.tokens[tt] + \" without preceding try\");\n\n          case THROW:\n            n = new Node(t);\n            n.exception = Expression(t, x);\n            break;\n\n          case RETURN:\n            n = ReturnOrYield(t, x);\n            break;\n\n          case WITH:\n            n = new Node(t);\n            n.object = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case VAR:\n          case CONST:\n            n = Variables(t, x);\n            break;\n\n          case LET:\n            if (t.peek() === LEFT_PAREN)\n                n = LetBlock(t, x, true);\n            else\n                n = Variables(t, x);\n            break;\n\n          case DEBUGGER:\n            n = new Node(t);\n            break;\n\n          case NEWLINE:\n          case SEMICOLON:\n            n = new Node(t, { type: SEMICOLON });\n            n.expression = null;\n            return n;\n\n          default:\n            if (tt === IDENTIFIER) {\n                tt = t.peek();\n                // Labeled statement.\n                if (tt === COLON) {\n                    label = t.token.value;\n                    if (x.allLabels.has(label))\n                        throw t.newSyntaxError(\"Duplicate label\");\n                    t.get();\n                    n = new Node(t, { type: LABEL, label: label });\n                    n.statement = Statement(t, x.pushLabel(label).nest(NESTING_SHALLOW));\n                    n.target = (n.statement.type === LABEL) ? n.statement.target : n.statement;\n                    return n;\n                }\n            }\n\n            // Expression statement.\n            // We unget the current token to parse the expression as a whole.\n            n = new Node(t, { type: SEMICOLON });\n            t.unget();\n            n.expression = Expression(t, x);\n            n.end = n.expression.end;\n            break;\n        }\n\n        MagicalSemicolon(t);\n        return n;\n    }\n\n    function MagicalSemicolon(t) {\n        var tt;\n        if (t.lineno === t.token.lineno) {\n            tt = t.peekOnSameLine();\n            if (tt !== END && tt !== NEWLINE && tt !== SEMICOLON && tt !== RIGHT_CURLY)\n                throw t.newSyntaxError(\"missing ; before statement\");\n        }\n        t.match(SEMICOLON);\n    }\n\n    function ReturnOrYield(t, x) {\n        var n, b, tt = t.token.type, tt2;\n\n        var parentScript = x.parentScript;\n\n        if (tt === RETURN) {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Return not in function\");\n        } else /* if (tt === YIELD) */ {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Yield not in function\");\n            parentScript.isGenerator = true;\n        }\n        n = new Node(t, { value: undefined });\n\n        tt2 = t.peek(true);\n        if (tt2 !== END && tt2 !== NEWLINE &&\n            tt2 !== SEMICOLON && tt2 !== RIGHT_CURLY\n            && (tt !== YIELD ||\n                (tt2 !== tt && tt2 !== RIGHT_BRACKET && tt2 !== RIGHT_PAREN &&\n                 tt2 !== COLON && tt2 !== COMMA))) {\n            if (tt === RETURN) {\n                n.value = Expression(t, x);\n                parentScript.hasReturnWithValue = true;\n            } else {\n                n.value = AssignExpression(t, x);\n            }\n        } else if (tt === RETURN) {\n            parentScript.hasEmptyReturn = true;\n        }\n\n        // Disallow return v; in generator.\n        if (parentScript.hasReturnWithValue && parentScript.isGenerator)\n            throw t.newSyntaxError(\"Generator returns a value\");\n\n        return n;\n    }\n\n    /*\n     * FunctionDefinition :: (tokenizer, compiler context, boolean,\n     *                        DECLARED_FORM or EXPRESSED_FORM or STATEMENT_FORM)\n     *                    -> node\n     */\n    function FunctionDefinition(t, x, requireName, functionForm) {\n        var tt;\n        var f = new Node(t, { params: [] });\n        if (f.type !== FUNCTION)\n            f.type = (f.value === \"get\") ? GETTER : SETTER;\n        if (t.match(IDENTIFIER))\n            f.name = t.token.value;\n        else if (requireName)\n            throw t.newSyntaxError(\"missing function identifier\");\n\n        var x2 = new StaticContext(null, null, true, false, NESTING_TOP);\n\n        t.mustMatch(LEFT_PAREN);\n        if (!t.match(RIGHT_PAREN)) {\n            do {\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured formal parameters.\n                    t.unget();\n                    f.params.push(DestructuringExpression(t, x2));\n                    break;\n                  case IDENTIFIER:\n                    f.params.push(t.token.value);\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing formal parameter\");\n                    break;\n                }\n            } while (t.match(COMMA));\n            t.mustMatch(RIGHT_PAREN);\n        }\n\n        // Do we have an expression closure or a normal body?\n        tt = t.get();\n        if (tt !== LEFT_CURLY)\n            t.unget();\n\n        if (tt !== LEFT_CURLY) {\n            f.body = AssignExpression(t, x2);\n            if (f.body.isGenerator)\n                throw t.newSyntaxError(\"Generator returns a value\");\n        } else {\n            f.body = Script(t, true);\n        }\n\n        if (tt === LEFT_CURLY)\n            t.mustMatch(RIGHT_CURLY);\n\n        f.end = t.token.end;\n        f.functionForm = functionForm;\n        if (functionForm === DECLARED_FORM)\n            x.parentScript.funDecls.push(f);\n        return f;\n    }\n\n    /*\n     * Variables :: (tokenizer, compiler context) -> node\n     *\n     * Parses a comma-separated list of var declarations (and maybe\n     * initializations).\n     */\n    function Variables(t, x, letBlock) {\n        var n, n2, ss, i, s, tt;\n\n        tt = t.token.type;\n        switch (tt) {\n          case VAR:\n          case CONST:\n            s = x.parentScript;\n            break;\n          case LET:\n            s = x.parentBlock;\n            break;\n          case LEFT_PAREN:\n            tt = LET;\n            s = letBlock;\n            break;\n        }\n\n        n = new Node(t, { type: tt, destructurings: [] });\n\n        do {\n            tt = t.get();\n            if (tt === LEFT_BRACKET || tt === LEFT_CURLY) {\n                // Need to unget to parse the full destructured expression.\n                t.unget();\n\n                var dexp = DestructuringExpression(t, x, true);\n\n                n2 = new Node(t, { type: IDENTIFIER,\n                                   name: dexp,\n                                   readOnly: n.type === CONST });\n                n.push(n2);\n                pushDestructuringVarDecls(n2.name.destructuredNames, s);\n                n.destructurings.push({ exp: dexp, decl: n2 });\n\n                if (x.inForLoopInit && t.peek() === IN) {\n                    continue;\n                }\n\n                t.mustMatch(ASSIGN);\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n\n                continue;\n            }\n\n            if (tt !== IDENTIFIER)\n                throw t.newSyntaxError(\"missing variable name\");\n\n            n2 = new Node(t, { type: IDENTIFIER,\n                               name: t.token.value,\n                               readOnly: n.type === CONST });\n            n.push(n2);\n            s.varDecls.push(n2);\n\n            if (t.match(ASSIGN)) {\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n            }\n        } while (t.match(COMMA));\n\n        return n;\n    }\n\n    /*\n     * LetBlock :: (tokenizer, compiler context, boolean) -> node\n     *\n     * Does not handle let inside of for loop init.\n     */\n    function LetBlock(t, x, isStatement) {\n        var n, n2;\n\n        // t.token.type must be LET\n        n = new Node(t, { type: LET_BLOCK, varDecls: [] });\n        t.mustMatch(LEFT_PAREN);\n        n.variables = Variables(t, x, n);\n        t.mustMatch(RIGHT_PAREN);\n\n        if (isStatement && t.peek() !== LEFT_CURLY) {\n            /*\n             * If this is really an expression in let statement guise, then we\n             * need to wrap the LET_BLOCK node in a SEMICOLON node so that we pop\n             * the return value of the expression.\n             */\n            n2 = new Node(t, { type: SEMICOLON,\n                               expression: n });\n            isStatement = false;\n        }\n\n        if (isStatement)\n            n.block = Block(t, x);\n        else\n            n.expression = AssignExpression(t, x);\n\n        return n;\n    }\n\n    function checkDestructuring(t, x, n, simpleNamesOnly) {\n        if (n.type === ARRAY_COMP)\n            throw t.newSyntaxError(\"Invalid array comprehension left-hand side\");\n        if (n.type !== ARRAY_INIT && n.type !== OBJECT_INIT)\n            return;\n\n        var lhss = {};\n        var nn, n2, idx, sub, cc, c = n.children;\n        for (var i = 0, j = c.length; i < j; i++) {\n            if (!(nn = c[i]))\n                continue;\n            if (nn.type === PROPERTY_INIT) {\n                cc = nn.children;\n                sub = cc[1];\n                idx = cc[0].value;\n            } else if (n.type === OBJECT_INIT) {\n                // Do we have destructuring shorthand {foo, bar}?\n                sub = nn;\n                idx = nn.value;\n            } else {\n                sub = nn;\n                idx = i;\n            }\n\n            if (sub.type === ARRAY_INIT || sub.type === OBJECT_INIT) {\n                lhss[idx] = checkDestructuring(t, x, sub, simpleNamesOnly);\n            } else {\n                if (simpleNamesOnly && sub.type !== IDENTIFIER) {\n                    // In declarations, lhs must be simple names\n                    throw t.newSyntaxError(\"missing name in pattern\");\n                }\n\n                lhss[idx] = sub;\n            }\n        }\n\n        return lhss;\n    }\n\n    function DestructuringExpression(t, x, simpleNamesOnly) {\n        var n = PrimaryExpression(t, x);\n        // Keep the list of lefthand sides for varDecls\n        n.destructuredNames = checkDestructuring(t, x, n, simpleNamesOnly);\n        return n;\n    }\n\n    function GeneratorExpression(t, x, e) {\n        return new Node(t, { type: GENERATOR,\n                             expression: e,\n                             tail: ComprehensionTail(t, x) });\n    }\n\n    function ComprehensionTail(t, x) {\n        var body, n, n2, n3, p;\n\n        // t.token.type must be FOR\n        body = new Node(t, { type: COMP_TAIL });\n\n        do {\n            // Comprehension tails are always for..in loops.\n            n = new Node(t, { type: FOR_IN, isLoop: true });\n            if (t.match(IDENTIFIER)) {\n                // But sometimes they're for each..in.\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            p = MaybeLeftParen(t, x);\n            switch(t.get()) {\n              case LEFT_BRACKET:\n              case LEFT_CURLY:\n                t.unget();\n                // Destructured left side of for in comprehension tails.\n                n.iterator = DestructuringExpression(t, x);\n                break;\n\n              case IDENTIFIER:\n                n.iterator = n3 = new Node(t, { type: IDENTIFIER });\n                n3.name = n3.value;\n                n.varDecl = n2 = new Node(t, { type: VAR });\n                n2.push(n3);\n                x.parentScript.varDecls.push(n3);\n                // Don't add to varDecls since the semantics of comprehensions is\n                // such that the variables are in their own function when\n                // desugared.\n                break;\n\n              default:\n                throw t.newSyntaxError(\"missing identifier\");\n            }\n            t.mustMatch(IN);\n            n.object = Expression(t, x);\n            MaybeRightParen(t, p);\n            body.push(n);\n        } while (t.match(FOR));\n\n        // Optional guard.\n        if (t.match(IF))\n            body.guard = HeadExpression(t, x);\n\n        return body;\n    }\n\n    function HeadExpression(t, x) {\n        var p = MaybeLeftParen(t, x);\n        var n = ParenExpression(t, x);\n        MaybeRightParen(t, p);\n        if (p === END && !n.parenthesized) {\n            var tt = t.peek();\n            if (tt !== LEFT_CURLY && !definitions.isStatementStartCode[tt])\n                throw t.newSyntaxError(\"Unparenthesized head followed by unbraced body\");\n        }\n        return n;\n    }\n\n    function ParenExpression(t, x) {\n        // Always accept the 'in' operator in a parenthesized expression,\n        // where it's unambiguous, even if we might be parsing the init of a\n        // for statement.\n        var n = Expression(t, x.update({ inForLoopInit: x.inForLoopInit &&\n                                                        (t.token.type === LEFT_PAREN) }));\n\n        if (t.match(FOR)) {\n            if (n.type === YIELD && !n.parenthesized)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (n.type === COMMA && !n.parenthesized)\n                throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            n = GeneratorExpression(t, x, n);\n        }\n\n        return n;\n    }\n\n    /*\n     * Expression :: (tokenizer, compiler context) -> node\n     *\n     * Top-down expression parser matched against SpiderMonkey.\n     */\n    function Expression(t, x) {\n        var n, n2;\n\n        n = AssignExpression(t, x);\n        if (t.match(COMMA)) {\n            n2 = new Node(t, { type: COMMA });\n            n2.push(n);\n            n = n2;\n            do {\n                n2 = n.children[n.children.length-1];\n                if (n2.type === YIELD && !n2.parenthesized)\n                    throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n                n.push(AssignExpression(t, x));\n            } while (t.match(COMMA));\n        }\n\n        return n;\n    }\n\n    function AssignExpression(t, x) {\n        var n, lhs;\n\n        // Have to treat yield like an operand because it could be the leftmost\n        // operand of the expression.\n        if (t.match(YIELD, true))\n            return ReturnOrYield(t, x);\n\n        n = new Node(t, { type: ASSIGN });\n        lhs = ConditionalExpression(t, x);\n\n        if (!t.match(ASSIGN)) {\n            return lhs;\n        }\n\n        switch (lhs.type) {\n          case OBJECT_INIT:\n          case ARRAY_INIT:\n            lhs.destructuredNames = checkDestructuring(t, x, lhs);\n            // FALL THROUGH\n          case IDENTIFIER: case DOT: case INDEX: case CALL:\n            break;\n          default:\n            throw t.newSyntaxError(\"Bad left-hand side of assignment\");\n            break;\n        }\n\n        n.assignOp = t.token.assignOp;\n        n.push(lhs);\n        n.push(AssignExpression(t, x));\n\n        return n;\n    }\n\n    function ConditionalExpression(t, x) {\n        var n, n2;\n\n        n = OrExpression(t, x);\n        if (t.match(HOOK)) {\n            n2 = n;\n            n = new Node(t, { type: HOOK });\n            n.push(n2);\n            /*\n             * Always accept the 'in' operator in the middle clause of a ternary,\n             * where it's unambiguous, even if we might be parsing the init of a\n             * for statement.\n             */\n            n.push(AssignExpression(t, x.update({ inForLoopInit: false })));\n            if (!t.match(COLON))\n                throw t.newSyntaxError(\"missing : after ?\");\n            n.push(AssignExpression(t, x));\n        }\n\n        return n;\n    }\n\n    function OrExpression(t, x) {\n        var n, n2;\n\n        n = AndExpression(t, x);\n        while (t.match(OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AndExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseOrExpression(t, x);\n        while (t.match(AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseOrExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseOrExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseXorExpression(t, x);\n        while (t.match(BITWISE_OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseXorExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseXorExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseAndExpression(t, x);\n        while (t.match(BITWISE_XOR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseAndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseAndExpression(t, x) {\n        var n, n2;\n\n        n = EqualityExpression(t, x);\n        while (t.match(BITWISE_AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(EqualityExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function EqualityExpression(t, x) {\n        var n, n2;\n\n        n = RelationalExpression(t, x);\n        while (t.match(EQ) || t.match(NE) ||\n               t.match(STRICT_EQ) || t.match(STRICT_NE)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(RelationalExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function RelationalExpression(t, x) {\n        var n, n2;\n\n        /*\n         * Uses of the in operator in shiftExprs are always unambiguous,\n         * so unset the flag that prohibits recognizing it.\n         */\n        var x2 = x.update({ inForLoopInit: false });\n        n = ShiftExpression(t, x2);\n        while ((t.match(LT) || t.match(LE) || t.match(GE) || t.match(GT) ||\n               (!x.inForLoopInit && t.match(IN)) ||\n               t.match(INSTANCEOF))) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(ShiftExpression(t, x2));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ShiftExpression(t, x) {\n        var n, n2;\n\n        n = AddExpression(t, x);\n        while (t.match(LSH) || t.match(RSH) || t.match(URSH)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AddExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AddExpression(t, x) {\n        var n, n2;\n\n        n = MultiplyExpression(t, x);\n        while (t.match(PLUS) || t.match(MINUS)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(MultiplyExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function MultiplyExpression(t, x) {\n        var n, n2;\n\n        n = UnaryExpression(t, x);\n        while (t.match(MUL) || t.match(DIV) || t.match(MOD)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(UnaryExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function UnaryExpression(t, x) {\n        var n, n2, tt;\n\n        switch (tt = t.get(true)) {\n          case DELETE: case VOID: case TYPEOF:\n          case NOT: case BITWISE_NOT: case PLUS: case MINUS:\n            if (tt === PLUS)\n                n = new Node(t, { type: UNARY_PLUS });\n            else if (tt === MINUS)\n                n = new Node(t, { type: UNARY_MINUS });\n            else\n                n = new Node(t);\n            n.push(UnaryExpression(t, x));\n            break;\n\n          case INCREMENT:\n          case DECREMENT:\n            // Prefix increment/decrement.\n            n = new Node(t);\n            n.push(MemberExpression(t, x, true));\n            break;\n\n          default:\n            t.unget();\n            n = MemberExpression(t, x, true);\n\n            // Don't look across a newline boundary for a postfix {in,de}crement.\n            if (t.tokens[(t.tokenIndex + t.lookahead - 1) & 3].lineno ===\n                t.lineno) {\n                if (t.match(INCREMENT) || t.match(DECREMENT)) {\n                    n2 = new Node(t, { postfix: true });\n                    n2.push(n);\n                    n = n2;\n                }\n            }\n            break;\n        }\n\n        return n;\n    }\n\n    function MemberExpression(t, x, allowCallSyntax) {\n        var n, n2, name, tt;\n\n        if (t.match(NEW)) {\n            n = new Node(t);\n            n.push(MemberExpression(t, x, false));\n            if (t.match(LEFT_PAREN)) {\n                n.type = NEW_WITH_ARGS;\n                n.push(ArgumentList(t, x));\n            }\n        } else {\n            n = PrimaryExpression(t, x);\n        }\n\n        while ((tt = t.get()) !== END) {\n            switch (tt) {\n              case DOT:\n                n2 = new Node(t);\n                n2.push(n);\n                t.mustMatch(IDENTIFIER);\n                n2.push(new Node(t));\n                break;\n\n              case LEFT_BRACKET:\n                n2 = new Node(t, { type: INDEX });\n                n2.push(n);\n                n2.push(Expression(t, x));\n                t.mustMatch(RIGHT_BRACKET);\n                break;\n\n              case LEFT_PAREN:\n                if (allowCallSyntax) {\n                    n2 = new Node(t, { type: CALL });\n                    n2.push(n);\n                    n2.push(ArgumentList(t, x));\n                    break;\n                }\n\n                // FALL THROUGH\n              default:\n                t.unget();\n                return n;\n            }\n\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ArgumentList(t, x) {\n        var n, n2;\n\n        n = new Node(t, { type: LIST });\n        if (t.match(RIGHT_PAREN, true))\n            return n;\n        do {\n            n2 = AssignExpression(t, x);\n            if (n2.type === YIELD && !n2.parenthesized && t.peek() === COMMA)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (t.match(FOR)) {\n                n2 = GeneratorExpression(t, x, n2);\n                if (n.children.length > 1 || t.peek(true) === COMMA)\n                    throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            }\n            n.push(n2);\n        } while (t.match(COMMA));\n        t.mustMatch(RIGHT_PAREN);\n\n        return n;\n    }\n\n    function PrimaryExpression(t, x) {\n        var n, n2, tt = t.get(true);\n\n        switch (tt) {\n          case FUNCTION:\n            n = FunctionDefinition(t, x, false, EXPRESSED_FORM);\n            break;\n\n          case LEFT_BRACKET:\n            n = new Node(t, { type: ARRAY_INIT });\n            while ((tt = t.peek(true)) !== RIGHT_BRACKET) {\n                if (tt === COMMA) {\n                    t.get();\n                    n.push(null);\n                    continue;\n                }\n                n.push(AssignExpression(t, x));\n                if (tt !== COMMA && !t.match(COMMA))\n                    break;\n            }\n\n            // If we matched exactly one element and got a FOR, we have an\n            // array comprehension.\n            if (n.children.length === 1 && t.match(FOR)) {\n                n2 = new Node(t, { type: ARRAY_COMP,\n                                   expression: n.children[0],\n                                   tail: ComprehensionTail(t, x) });\n                n = n2;\n            }\n            t.mustMatch(RIGHT_BRACKET);\n            break;\n\n          case LEFT_CURLY:\n            var id, fd;\n            n = new Node(t, { type: OBJECT_INIT });\n\n          object_init:\n            if (!t.match(RIGHT_CURLY)) {\n                do {\n                    tt = t.get();\n                    if ((t.token.value === \"get\" || t.token.value === \"set\") &&\n                        t.peek() === IDENTIFIER) {\n                        if (x.ecma3OnlyMode)\n                            throw t.newSyntaxError(\"Illegal property accessor\");\n                        n.push(FunctionDefinition(t, x, true, EXPRESSED_FORM));\n                    } else {\n                        switch (tt) {\n                          case IDENTIFIER: case NUMBER: case STRING:\n                            id = new Node(t, { type: IDENTIFIER });\n                            break;\n                          case RIGHT_CURLY:\n                            if (x.ecma3OnlyMode)\n                                throw t.newSyntaxError(\"Illegal trailing ,\");\n                            break object_init;\n                          default:\n                            if (t.token.value in definitions.keywords) {\n                                id = new Node(t, { type: IDENTIFIER });\n                                break;\n                            }\n                            throw t.newSyntaxError(\"Invalid property name\");\n                        }\n                        if (t.match(COLON)) {\n                            n2 = new Node(t, { type: PROPERTY_INIT });\n                            n2.push(id);\n                            n2.push(AssignExpression(t, x));\n                            n.push(n2);\n                        } else {\n                            // Support, e.g., |var {x, y} = o| as destructuring shorthand\n                            // for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.\n                            if (t.peek() !== COMMA && t.peek() !== RIGHT_CURLY)\n                                throw t.newSyntaxError(\"missing : after property\");\n                            n.push(id);\n                        }\n                    }\n                } while (t.match(COMMA));\n                t.mustMatch(RIGHT_CURLY);\n            }\n            break;\n\n          case LEFT_PAREN:\n            n = ParenExpression(t, x);\n            t.mustMatch(RIGHT_PAREN);\n            n.parenthesized = true;\n            break;\n\n          case LET:\n            n = LetBlock(t, x, false);\n            break;\n\n          case NULL: case THIS: case TRUE: case FALSE:\n          case IDENTIFIER: case NUMBER: case STRING: case REGEXP:\n            n = new Node(t);\n            break;\n\n          default:\n            throw t.newSyntaxError(\"missing operand\");\n            break;\n        }\n\n        return n;\n    }\n\n    /*\n     * parse :: (source, filename, line number) -> node\n     */\n    function parse(s, f, l) {\n        var t = new lexer.Tokenizer(s, f, l);\n        var n = Script(t, false);\n        if (!t.done)\n            throw t.newSyntaxError(\"Syntax error\");\n\n        return n;\n    }\n\n    /*\n     * parseStdin :: (source, {line number}) -> node\n     */\n    function parseStdin(s, ln) {\n        for (;;) {\n            try {\n                var t = new lexer.Tokenizer(s, \"stdin\", ln.value);\n                var n = Script(t, false);\n                ln.value = t.lineno;\n                return n;\n            } catch (e) {\n                if (!t.unexpectedEOF)\n                    throw e;\n                var more = readline();\n                if (!more)\n                    throw e;\n                s += \"\\n\" + more;\n            }\n        }\n    }\n\n    return {\n        parse: parse,\n        parseStdin: parseStdin,\n        Node: Node,\n        DECLARED_FORM: DECLARED_FORM,\n        EXPRESSED_FORM: EXPRESSED_FORM,\n        STATEMENT_FORM: STATEMENT_FORM,\n        Tokenizer: lexer.Tokenizer,\n        FunctionDefinition: FunctionDefinition\n    };\n\n}());\n\nvar exports = {\n  definitions: Narcissus.definitions,\n  lexer: Narcissus.lexer,\n  parser: Narcissus.parser\n};\n\nif (typeof module != 'undefined') {\n  module.exports = exports;\n};\n\n\n(function() {\n  var Node, Typenames, Types, exports, narcissus, parser, tokens, _,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice;\n\n  narcissus = require('./narcissus_packed');\n\n  _ = require('underscore');\n\n  tokens = narcissus.definitions.tokens;\n\n  parser = narcissus.parser;\n\n  Node = parser.Node;\n\n  Node.prototype.left = function() {\n    return this.children[0];\n  };\n\n  Node.prototype.right = function() {\n    return this.children[1];\n  };\n\n  Node.prototype.last = function() {\n    return this.children[this.children.length - 1];\n  };\n\n  Node.prototype.walk = function(options, fn, parent, list) {\n    if (parent == null) {\n      parent = null;\n    }\n    if (list == null) {\n      list = null;\n    }\n    if (parent) {\n      fn(parent, this, list);\n    }\n    if (options.last) {\n      if (this.last() != null) {\n        this.last().walk(options, fn, this);\n      }\n    }\n    if (this.thenPart != null) {\n      this.thenPart.walk(options, fn, this, 'thenPart');\n    }\n    if (this.elsePart != null) {\n      this.elsePart.walk(options, fn, this, 'elsePart');\n    }\n    if (this.cases) {\n      return _.each(this.cases, function(item) {\n        return item.statements.walk(options, fn, item, 'cases');\n      });\n    }\n  };\n\n  Node.prototype.clone = function(hash) {\n    var i;\n    for (i in this) {\n      if (i === 'tokenizer' || i === 'length' || i === 'filename') {\n        continue;\n      }\n      if (hash[i] == null) {\n        hash[i] = this[i];\n      }\n    }\n    return new Node(this.tokenizer, hash);\n  };\n\n  Node.prototype.toHash = function(done) {\n    var hash, i, toHash;\n    if (done == null) {\n      done = [];\n    }\n    hash = {};\n    toHash = function(what) {\n      if (!what) {\n        return null;\n      }\n      if (what.toHash) {\n        if (__indexOf.call(done, what) >= 0) {\n          return \"--recursive \" + what.id + \"--\";\n        }\n        what.id = done.push(what);\n        return what.toHash(done);\n      } else {\n        return what;\n      }\n    };\n    hash.type = this.typeName();\n    hash.src = this.src();\n    for (i in this) {\n      if (i === 'filename' || i === 'length' || i === 'type' || i === 'start' || i === 'end' || i === 'tokenizer') {\n        continue;\n      }\n      if (typeof this[i] === 'function') {\n        continue;\n      }\n      if (!this[i]) {\n        continue;\n      }\n      if (this[i].constructor === Array) {\n        hash[i] = _.map(this[i], function(item) {\n          return toHash(item);\n        });\n      } else {\n        hash[i] = toHash(this[i]);\n      }\n    }\n    return hash;\n  };\n\n  Node.prototype.inspect = function() {\n    return JSON.stringify(this.toHash(), null, '  ');\n  };\n\n  Node.prototype.src = function() {\n    return this.tokenizer.source.substr(this.start, this.end - this.start);\n  };\n\n  Node.prototype.typeName = function() {\n    return Types[this.type];\n  };\n\n  Node.prototype.isA = function() {\n    var what, _ref;\n    what = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return _ref = Types[this.type], __indexOf.call(what, _ref) >= 0;\n  };\n\n  Types = (function() {\n    var dict, i, last;\n    dict = {};\n    last = 0;\n    for (i in tokens) {\n      if (typeof tokens[i] === 'number') {\n        dict[tokens[i]] = i.toLowerCase();\n        last = tokens[i];\n      }\n    }\n    dict[++last] = 'call_statement';\n    dict[++last] = 'existence_check';\n    return dict;\n  })();\n\n  Typenames = (function() {\n    var dict, i;\n    dict = {};\n    for (i in Types) {\n      dict[Types[i]] = i;\n    }\n    return dict;\n  })();\n\n  this.NodeExt = exports = {\n    Types: Types,\n    Typenames: Typenames,\n    Node: Node\n  };\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = exports;\n  }\n\n}).call(this);\n\n(function() {\n  var Code, CoffeeScript, blockTrim, coffeescript_reserved, exports, indentLines, isSingleLine, ltrim, p, paren, rtrim, strEscape, strEscapeSingleQuotes, strRepeat, trim, truthy, unreserve, unshift, word,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  CoffeeScript = require('coffee-script');\n\n  if (CoffeeScript.RESERVED == null) {\n    CoffeeScript.RESERVED = require('coffee-script/lib/coffee-script/lexer.js').RESERVED;\n  }\n\n  Code = (function() {\n    Code.INDENT = \"  \";\n\n    function Code() {\n      this.code = '';\n    }\n\n    Code.prototype.add = function(str) {\n      this.code += str.toString();\n      return this;\n    };\n\n    Code.prototype.scope = function(str, level) {\n      var indent;\n      if (level == null) {\n        level = 1;\n      }\n      indent = strRepeat(Code.INDENT, level);\n      this.code = rtrim(this.code) + \"\\n\";\n      this.code += indent + rtrim(str).replace(/\\n/g, \"\\n\" + indent) + \"\\n\";\n      return this;\n    };\n\n    Code.prototype.toString = function() {\n      return this.code;\n    };\n\n    return Code;\n\n  })();\n\n  paren = function(string) {\n    var str;\n    str = string.toString();\n    if (str.substr(0, 1) === '(' && str.substr(-1, 1) === ')') {\n      return str;\n    } else {\n      return \"(\" + str + \")\";\n    }\n  };\n\n  strRepeat = function(str, times) {\n    var i;\n    return ((function() {\n      var _i, _results;\n      _results = [];\n      for (i = _i = 0; 0 <= times ? _i < times : _i > times; i = 0 <= times ? ++_i : --_i) {\n        _results.push(str);\n      }\n      return _results;\n    })()).join('');\n  };\n\n  ltrim = function(str) {\n    return (\"\" + str).replace(/^\\s*/g, '');\n  };\n\n  rtrim = function(str) {\n    return (\"\" + str).replace(/\\s*$/g, '');\n  };\n\n  blockTrim = function(str) {\n    return (\"\" + str).replace(/^\\s*\\n|\\s*$/g, '');\n  };\n\n  trim = function(str) {\n    return (\"\" + str).replace(/^\\s*|\\s*$/g, '');\n  };\n\n  isSingleLine = function(str) {\n    return trim(str).indexOf(\"\\n\") === -1;\n  };\n\n  unshift = function(str) {\n    var m1, m2;\n    str = \"\" + str;\n    while (true) {\n      m1 = str.match(/^/gm);\n      m2 = str.match(/^ /gm);\n      if (!m1 || !m2 || m1.length !== m2.length) {\n        return str;\n      }\n      str = str.replace(/^ /gm, '');\n    }\n  };\n\n  truthy = function(n) {\n    return n.isA('true') || (n.isA('number') && parseFloat(n.src()) !== 0.0);\n  };\n\n  strEscape = function(str) {\n    if (str.indexOf('#{') !== -1) {\n      return strEscapeSingleQuotes(str);\n    }\n    return JSON.stringify(\"\" + str);\n  };\n\n  strEscapeSingleQuotes = function(str) {\n    var dq, esq, rdq;\n    dq = JSON.stringify(str);\n    rdq = dq.replace(/\\\\\"/g, '\"');\n    esq = rdq.replace(/'/g, \"\\\\\\'\");\n    return \"'\" + esq.substr(1, esq.length - 2) + \"'\";\n  };\n\n  p = function(str) {\n    if (str.constructor === String) {\n      console.log(JSON.stringify(str));\n    } else {\n      console.log(str);\n    }\n    return '';\n  };\n\n  coffeescript_reserved = (function() {\n    var _i, _len, _ref, _results;\n    _ref = CoffeeScript.RESERVED;\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      word = _ref[_i];\n      if (word !== 'undefined') {\n        _results.push(word);\n      }\n    }\n    return _results;\n  })();\n\n  unreserve = function(str) {\n    var _ref;\n    if (_ref = \"\" + str, __indexOf.call(coffeescript_reserved, _ref) >= 0) {\n      return \"\" + str + \"_\";\n    } else {\n      return \"\" + str;\n    }\n  };\n\n  indentLines = function(indent, lines) {\n    return indent + lines.replace(/\\n/g, \"\\n\" + indent);\n  };\n\n  this.Js2coffeeHelpers = exports = {\n    Code: Code,\n    p: p,\n    strEscapeDoubleQuotes: strEscape,\n    strEscapeSingleQuotes: strEscapeSingleQuotes,\n    unreserve: unreserve,\n    unshift: unshift,\n    isSingleLine: isSingleLine,\n    trim: trim,\n    blockTrim: blockTrim,\n    ltrim: ltrim,\n    rtrim: rtrim,\n    strRepeat: strRepeat,\n    paren: paren,\n    truthy: truthy,\n    indentLines: indentLines\n  };\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = exports;\n  }\n\n}).call(this);\n\n(function() {\n  var Builder, Code, Node, Transformer, Typenames, Types, UnsupportedError, blockTrim, buildCoffee, exports, indentLines, isSingleLine, ltrim, p, paren, parser, pkg, rtrim, strEscape, strEscapeDoubleQuotes, strEscapeSingleQuotes, strRepeat, trim, truthy, unreserve, unshift, _, _ref, _ref1,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty;\n\n  _ = require('underscore');\n\n  pkg = require('../../package.json');\n\n  parser = require('./narcissus_packed').parser;\n\n  _ref = require('./node_ext'), Types = _ref.Types, Typenames = _ref.Typenames, Node = _ref.Node;\n\n  _ref1 = require('./helpers'), Code = _ref1.Code, p = _ref1.p, strEscapeDoubleQuotes = _ref1.strEscapeDoubleQuotes, strEscapeSingleQuotes = _ref1.strEscapeSingleQuotes, unreserve = _ref1.unreserve, unshift = _ref1.unshift, isSingleLine = _ref1.isSingleLine, trim = _ref1.trim, blockTrim = _ref1.blockTrim, ltrim = _ref1.ltrim, rtrim = _ref1.rtrim, strRepeat = _ref1.strRepeat, paren = _ref1.paren, truthy = _ref1.truthy, indentLines = _ref1.indentLines;\n\n  strEscape = void 0;\n\n  buildCoffee = function(str, opts) {\n    var builder, comments, indent, keepLineNumbers, l, line, minline, output, precomments, res, scriptNode, srclines, text, _i, _len, _ref2;\n    if (opts == null) {\n      opts = {};\n    }\n    str = str.replace(/\\r/g, '');\n    str += \"\\n\";\n    if (opts.indent != null) {\n      Code.INDENT = opts.indent;\n    }\n    if ((opts.single_quotes != null) && opts.single_quotes === true) {\n      console.log(opts.single_quotes);\n      strEscape = strEscapeSingleQuotes;\n    } else {\n      strEscape = strEscapeDoubleQuotes;\n    }\n    builder = new Builder(opts);\n    scriptNode = parser.parse(str);\n    output = trim(builder.build(scriptNode));\n    if (opts.no_comments) {\n      return ((function() {\n        var _i, _len, _ref2, _results;\n        _ref2 = output.split('\\n');\n        _results = [];\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          line = _ref2[_i];\n          _results.push(rtrim(line));\n        }\n        return _results;\n      })()).join('\\n');\n    } else {\n      keepLineNumbers = opts.show_src_lineno;\n      res = [];\n      _ref2 = output.split(\"\\n\");\n      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n        l = _ref2[_i];\n        srclines = [];\n        text = l.replace(/\\uFEFE([0-9]+).*?\\uFEFE/g, function(m, g) {\n          srclines.push(parseInt(g));\n          return \"\";\n        });\n        srclines = _.sortBy(_.uniq(srclines), function(i) {\n          return i;\n        });\n        text = rtrim(text);\n        indent = text.match(/^\\s*/);\n        if (srclines.length > 0) {\n          minline = _.last(srclines);\n          precomments = builder.commentsNotDoneTo(minline);\n          if (precomments) {\n            res.push(indentLines(indent, precomments));\n          }\n        }\n        if (text) {\n          if (keepLineNumbers) {\n            text = text + \"#\" + srclines.join(\",\") + \"#  \";\n          }\n          res.push(rtrim(text + \" \" + ltrim(builder.lineComments(srclines))));\n        } else {\n          res.push(\"\");\n        }\n      }\n      comments = builder.commentsNotDoneTo(1e10);\n      if (comments) {\n        res.push(comments);\n      }\n      return res.join(\"\\n\");\n    }\n  };\n\n  Builder = (function() {\n    function Builder(options) {\n      this.options = options != null ? options : {};\n      this.transformer = new Transformer;\n    }\n\n    Builder.prototype.l = function(n) {\n      if (this.options.no_comments) {\n        return '';\n      }\n      if (n && n.lineno) {\n        return \"\\uFEFE\" + n.lineno + \"\\uFEFE\";\n      } else {\n        return \"\";\n      }\n    };\n\n    Builder.prototype.makeComment = function(comment) {\n      var c, line;\n      if (comment.type === \"BLOCK_COMMENT\") {\n        c = comment.value.split(\"\\n\");\n        if (c.length > 0 && c[0].length > 0 && c[0][0] === \"*\") {\n          c = (function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = c.length; _i < _len; _i++) {\n              line = c[_i];\n              _results.push(line.replace(/^[\\s\\*]*/, ''));\n            }\n            return _results;\n          })();\n          c = (function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = c.length; _i < _len; _i++) {\n              line = c[_i];\n              _results.push(line.replace(/[\\s]*$/, ''));\n            }\n            return _results;\n          })();\n          while (c.length > 0 && c[0].length === 0) {\n            c.shift();\n          }\n          while (c.length > 0 && c[c.length - 1].length === 0) {\n            c.pop();\n          }\n          c.unshift('###');\n          c.push('###');\n        } else {\n          c = (function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = c.length; _i < _len; _i++) {\n              line = c[_i];\n              _results.push(\"#\" + line);\n            }\n            return _results;\n          })();\n        }\n      } else {\n        c = ['#' + comment.value];\n      }\n      if (comment.nlcount > 0) {\n        c.unshift('');\n      }\n      return c.join('\\n');\n    };\n\n    Builder.prototype.commentsNotDoneTo = function(lineno) {\n      var c, res;\n      res = [];\n      while (true) {\n        if (this.comments.length === 0) {\n          break;\n        }\n        c = this.comments[0];\n        if (c.lineno < lineno) {\n          res.push(this.makeComment(c));\n          this.comments.shift();\n          continue;\n        }\n        break;\n      }\n      return res.join(\"\\n\");\n    };\n\n    Builder.prototype.lineComments = function(linenos) {\n      var c, selection;\n      selection = (function() {\n        var _i, _len, _ref2, _ref3, _results;\n        _ref2 = this.comments;\n        _results = [];\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          c = _ref2[_i];\n          if (_ref3 = c.lineno, __indexOf.call(linenos, _ref3) >= 0) {\n            _results.push(c);\n          }\n        }\n        return _results;\n      }).call(this);\n      this.comments = _.difference(this.comments, selection);\n      return ((function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = selection.length; _i < _len; _i++) {\n          c = selection[_i];\n          _results.push(this.makeComment(c));\n        }\n        return _results;\n      }).call(this)).join(\"\\n\");\n    };\n\n    Builder.prototype.build = function() {\n      var args, fn, name, node, out;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      node = args[0];\n      if (this.comments == null) {\n        this.comments = _.sortBy(node.tokenizer.comments, function(n) {\n          return n.start;\n        });\n      }\n      this.transform(node);\n      name = 'other';\n      if (node !== void 0 && node.typeName) {\n        name = node.typeName();\n      }\n      fn = this[name] || this.other;\n      out = fn.apply(this, args);\n      if (node.parenthesized) {\n        return paren(out);\n      } else {\n        return out;\n      }\n    };\n\n    Builder.prototype.transform = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return this.transformer.transform.apply(this.transformer, args);\n    };\n\n    Builder.prototype.body = function(node, opts) {\n      var str;\n      if (opts == null) {\n        opts = {};\n      }\n      str = this.build(node, opts);\n      str = blockTrim(str);\n      str = unshift(str);\n      if (str.length > 0) {\n        return str;\n      } else {\n        return \"\";\n      }\n    };\n\n    Builder.prototype['script'] = function(n, opts) {\n      var c,\n        _this = this;\n      if (opts == null) {\n        opts = {};\n      }\n      c = new Code;\n      _.each(n.functions, function(item) {\n        return c.add(_this.build(item));\n      });\n      _.each(n.nonfunctions, function(item) {\n        return c.add(_this.build(item));\n      });\n      return c.toString();\n    };\n\n    Builder.prototype['property_identifier'] = function(n) {\n      var str;\n      str = n.value.toString();\n      if (str.match(/^([_\\$a-z][_\\$a-z0-9]*)$/i) || str.match(/^[0-9]+$/i)) {\n        return this.l(n) + str;\n      } else {\n        return this.l(n) + strEscape(str);\n      }\n    };\n\n    Builder.prototype['identifier'] = function(n) {\n      if (n.value === 'undefined') {\n        return this.l(n) + '`undefined`';\n      } else if (n.property_accessor) {\n        return this.l(n) + n.value.toString();\n      } else {\n        return this.l(n) + unreserve(n.value.toString());\n      }\n    };\n\n    Builder.prototype['number'] = function(n) {\n      return this.l(n) + (\"\" + (n.src()));\n    };\n\n    Builder.prototype['id'] = function(n) {\n      if (n.property_accessor) {\n        return this.l(n) + n;\n      } else {\n        return this.l(n) + unreserve(n);\n      }\n    };\n\n    Builder.prototype['id_param'] = function(n) {\n      var _ref2;\n      if ((_ref2 = n.toString()) === 'undefined') {\n        return this.l(n) + (\"\" + n + \"_\");\n      } else {\n        return this.l(n) + this.id(n);\n      }\n    };\n\n    Builder.prototype['return'] = function(n) {\n      if (n.value == null) {\n        return this.l(n) + \"return\\n\";\n      } else {\n        return this.l(n) + (\"return \" + (this.build(n.value)) + \"\\n\");\n      }\n    };\n\n    Builder.prototype[';'] = function(n) {\n      var src;\n      if (n.expression == null) {\n        return \"\";\n      } else if (n.expression.typeName() === 'object_init') {\n        src = this.object_init(n.expression);\n        if (n.parenthesized) {\n          return src;\n        } else {\n          return \"\" + (unshift(blockTrim(src))) + \"\\n\";\n        }\n      } else {\n        return this.build(n.expression) + \"\\n\";\n      }\n    };\n\n    Builder.prototype['new'] = function(n) {\n      return this.l(n) + (\"new \" + (this.build(n.left())));\n    };\n\n    Builder.prototype['new_with_args'] = function(n) {\n      return this.l(n) + (\"new \" + (this.build(n.left())) + \"(\" + (this.build(n.right())) + \")\");\n    };\n\n    Builder.prototype['unary_plus'] = function(n) {\n      return \"+\" + (this.build(n.left()));\n    };\n\n    Builder.prototype['unary_minus'] = function(n) {\n      return \"-\" + (this.build(n.left()));\n    };\n\n    Builder.prototype['this'] = function(n) {\n      return this.l(n) + 'this';\n    };\n\n    Builder.prototype['null'] = function(n) {\n      return this.l(n) + 'null';\n    };\n\n    Builder.prototype['true'] = function(n) {\n      return this.l(n) + 'true';\n    };\n\n    Builder.prototype['false'] = function(n) {\n      return this.l(n) + 'false';\n    };\n\n    Builder.prototype['void'] = function(n) {\n      return this.l(n) + 'undefined';\n    };\n\n    Builder.prototype['debugger'] = function(n) {\n      return this.l(n) + \"debugger\\n\";\n    };\n\n    Builder.prototype['break'] = function(n) {\n      return this.l(n) + \"break\\n\";\n    };\n\n    Builder.prototype['continue'] = function(n) {\n      return this.l(n) + \"continue\\n\";\n    };\n\n    Builder.prototype['~'] = function(n) {\n      return \"~\" + (this.build(n.left()));\n    };\n\n    Builder.prototype['typeof'] = function(n) {\n      return this.l(n) + (\"typeof \" + (this.build(n.left())));\n    };\n\n    Builder.prototype['index'] = function(n) {\n      var right;\n      right = this.build(n.right());\n      if (_.any(n.children, function(child) {\n        return child.typeName() === 'object_init' && child.children.length > 1;\n      })) {\n        right = \"{\" + right + \"}\";\n      }\n      return this.l(n) + (\"\" + (this.build(n.left())) + \"[\" + right + \"]\");\n    };\n\n    Builder.prototype['throw'] = function(n) {\n      return this.l(n) + (\"throw \" + (this.build(n.exception)));\n    };\n\n    Builder.prototype['!'] = function(n) {\n      var negations, target;\n      target = n.left();\n      negations = 1;\n      while ((target.isA('!')) && (target = target.left())) {\n        ++negations;\n      }\n      if ((negations & 1) && target.isA('==', '!=', '===', '!==', 'in', 'instanceof')) {\n        target.negated = !target.negated;\n        return this.build(target);\n      }\n      return this.l(n) + (\"\" + (negations & 1 ? 'not ' : '!!') + (this.build(target)));\n    };\n\n    Builder.prototype[\"in\"] = function(n) {\n      return this.binary_operator(n, 'of');\n    };\n\n    Builder.prototype['+'] = function(n) {\n      return this.binary_operator(n, '+');\n    };\n\n    Builder.prototype['-'] = function(n) {\n      return this.binary_operator(n, '-');\n    };\n\n    Builder.prototype['*'] = function(n) {\n      return this.binary_operator(n, '*');\n    };\n\n    Builder.prototype['/'] = function(n) {\n      return this.binary_operator(n, '/');\n    };\n\n    Builder.prototype['%'] = function(n) {\n      return this.binary_operator(n, '%');\n    };\n\n    Builder.prototype['>'] = function(n) {\n      return this.binary_operator(n, '>');\n    };\n\n    Builder.prototype['<'] = function(n) {\n      return this.binary_operator(n, '<');\n    };\n\n    Builder.prototype['&'] = function(n) {\n      return this.binary_operator(n, '&');\n    };\n\n    Builder.prototype['|'] = function(n) {\n      return this.binary_operator(n, '|');\n    };\n\n    Builder.prototype['^'] = function(n) {\n      return this.binary_operator(n, '^');\n    };\n\n    Builder.prototype['&&'] = function(n) {\n      return this.binary_operator(n, 'and');\n    };\n\n    Builder.prototype['||'] = function(n) {\n      return this.binary_operator(n, 'or');\n    };\n\n    Builder.prototype['<<'] = function(n) {\n      return this.binary_operator(n, '<<');\n    };\n\n    Builder.prototype['<='] = function(n) {\n      return this.binary_operator(n, '<=');\n    };\n\n    Builder.prototype['>>'] = function(n) {\n      return this.binary_operator(n, '>>');\n    };\n\n    Builder.prototype['>='] = function(n) {\n      return this.binary_operator(n, '>=');\n    };\n\n    Builder.prototype['==='] = function(n) {\n      return this.binary_operator(n, 'is');\n    };\n\n    Builder.prototype['!=='] = function(n) {\n      return this.binary_operator(n, 'isnt');\n    };\n\n    Builder.prototype['>>>'] = function(n) {\n      return this.binary_operator(n, '>>>');\n    };\n\n    Builder.prototype[\"instanceof\"] = function(n) {\n      return this.binary_operator(n, 'instanceof');\n    };\n\n    Builder.prototype['=='] = function(n) {\n      return this.binary_operator(n, 'is');\n    };\n\n    Builder.prototype['!='] = function(n) {\n      return this.binary_operator(n, 'isnt');\n    };\n\n    Builder.prototype['binary_operator'] = (function() {\n      var INVERSIONS, k, v;\n      INVERSIONS = {\n        is: 'isnt',\n        \"in\": 'not in',\n        of: 'not of',\n        \"instanceof\": 'not instanceof'\n      };\n      for (k in INVERSIONS) {\n        if (!__hasProp.call(INVERSIONS, k)) continue;\n        v = INVERSIONS[k];\n        INVERSIONS[v] = k;\n      }\n      return function(n, sign) {\n        if (n.negated) {\n          sign = INVERSIONS[sign];\n        }\n        return this.l(n) + (\"\" + (this.build(n.left())) + \" \" + sign + \" \" + (this.build(n.right())));\n      };\n    })();\n\n    Builder.prototype['--'] = function(n) {\n      return this.increment_decrement(n, '--');\n    };\n\n    Builder.prototype['++'] = function(n) {\n      return this.increment_decrement(n, '++');\n    };\n\n    Builder.prototype['increment_decrement'] = function(n, sign) {\n      if (n.postfix) {\n        return this.l(n) + (\"\" + (this.build(n.left())) + sign);\n      } else {\n        return this.l(n) + (\"\" + sign + (this.build(n.left())));\n      }\n    };\n\n    Builder.prototype['='] = function(n) {\n      var sign;\n      sign = n.assignOp != null ? Types[n.assignOp] + '=' : '=';\n      return this.l(n) + (\"\" + (this.build(n.left())) + \" \" + sign + \" \" + (this.build(n.right())));\n    };\n\n    Builder.prototype[','] = function(n) {\n      var list,\n        _this = this;\n      list = _.map(n.children, function(item) {\n        return _this.l(item) + _this.build(item) + \"\\n\";\n      });\n      return list.join('');\n    };\n\n    Builder.prototype['regexp'] = function(n) {\n      var begins_with, flag, m, value;\n      m = n.value.toString().match(/^\\/(.*)\\/([a-z]?)/);\n      value = m[1];\n      flag = m[2];\n      begins_with = value[0];\n      if (begins_with === ' ' || begins_with === '=') {\n        if (flag.length > 0) {\n          return this.l(n) + (\"RegExp(\" + (strEscape(value)) + \", \\\"\" + flag + \"\\\")\");\n        } else {\n          return this.l(n) + (\"RegExp(\" + (strEscape(value)) + \")\");\n        }\n      } else {\n        return this.l(n) + (\"/\" + value + \"/\" + flag);\n      }\n    };\n\n    Builder.prototype['string'] = function(n) {\n      return this.l(n) + strEscape(n.value);\n    };\n\n    Builder.prototype['call'] = function(n) {\n      if (n.right().children.length === 0) {\n        return (\"\" + (this.build(n.left())) + \"()\") + this.l(n);\n      } else {\n        return (\"\" + (this.build(n.left())) + \"(\" + (this.build(n.right())) + \")\") + this.l(n);\n      }\n    };\n\n    Builder.prototype['call_statement'] = function(n) {\n      var left;\n      left = this.build(n.left());\n      if (n.left().isA('function')) {\n        left = paren(left);\n      }\n      if (n.right().children.length === 0) {\n        return (\"\" + left + \"()\") + this.l(n);\n      } else {\n        return (\"\" + left + \" \" + (this.build(n.right()))) + this.l(n);\n      }\n    };\n\n    Builder.prototype['list'] = function(n, options) {\n      var list,\n        _this = this;\n      if (options == null) {\n        options = {};\n      }\n      list = _.map(n.children, function(item) {\n        var c, raw;\n        if (n.children.length > 1) {\n          item.is_list_element = true;\n        }\n        if (options.array === true && n.children.length > 0) {\n          raw = _this[item.typeName()](item);\n          c = new Code(_this, item);\n          c.scope(raw);\n          c = trim(c + Code.INDENT);\n          if (item.typeName() === 'object_init') {\n            c = \"{\\n\" + Code.INDENT + Code.INDENT + c + \"\\n\" + Code.INDENT + \"}\";\n          }\n          return c;\n        } else {\n          return _this.build(item);\n        }\n      });\n      if (options.array === true && n.children.length > 0) {\n        return this.l(n) + (\"\\n\" + Code.INDENT + (list.join('\\n' + Code.INDENT)));\n      } else {\n        return this.l(n) + list.join(\", \");\n      }\n    };\n\n    Builder.prototype['delete'] = function(n) {\n      var ids,\n        _this = this;\n      ids = _.map(n.children, function(el) {\n        return _this.build(el);\n      });\n      ids = ids.join(', ');\n      return this.l(n) + (\"delete \" + ids + \"\\n\");\n    };\n\n    Builder.prototype['.'] = function(n) {\n      var left, right, right_obj;\n      left = this.build(n.left());\n      right_obj = n.right();\n      right_obj.property_accessor = true;\n      right = this.build(right_obj);\n      if (n.isThis && n.isPrototype) {\n        return this.l(n) + \"@::\";\n      } else if (n.isThis) {\n        return this.l(n) + (\"@\" + right);\n      } else if (n.isPrototype) {\n        return this.l(n) + (\"\" + left + \"::\");\n      } else if (n.left().isPrototype) {\n        return this.l(n) + (\"\" + left + right);\n      } else {\n        return this.l(n) + (\"\" + left + \".\" + right);\n      }\n    };\n\n    Builder.prototype['try'] = function(n) {\n      var c,\n        _this = this;\n      c = new Code;\n      c.add('try');\n      c.scope(this.body(n.tryBlock));\n      _.each(n.catchClauses, function(clause) {\n        return c.add(_this.build(clause));\n      });\n      if (n.finallyBlock != null) {\n        c.add(\"finally\");\n        c.scope(this.body(n.finallyBlock));\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['catch'] = function(n) {\n      var body_, c;\n      body_ = this.body(n.block);\n      if (trim(body_).length === 0) {\n        return '';\n      }\n      c = new Code;\n      if (n.varName != null) {\n        c.add(\"catch \" + n.varName);\n      } else {\n        c.add('catch');\n      }\n      c.scope(this.body(n.block));\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['?'] = function(n) {\n      return this.l(n) + (\"(if \" + (this.build(n.left())) + \" then \" + (this.build(n.children[1])) + \" else \" + (this.build(n.children[2])) + \")\");\n    };\n\n    Builder.prototype['for'] = function(n) {\n      var c;\n      c = new Code;\n      if (n.setup != null) {\n        c.add(\"\" + (this.build(n.setup)) + \"\\n\");\n      }\n      if (n.condition != null) {\n        c.add(\"while \" + (this.build(n.condition)) + \"\\n\");\n      } else {\n        c.add(\"loop\");\n      }\n      c.scope(this.body(n.body));\n      if (n.update != null) {\n        c.scope(this.body(n.update));\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['for_in'] = function(n) {\n      var c;\n      c = new Code;\n      c.add(\"for \" + (this.build(n.iterator)) + \" of \" + (this.build(n.object)));\n      if (n.body.children.length > 0) {\n        c.scope(this.body(n.body));\n      } else {\n        c.scope(\"continue\");\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['while'] = function(n) {\n      var body_, c, keyword, statement;\n      c = new Code;\n      keyword = n.positive ? \"while\" : \"until\";\n      body_ = this.body(n.body);\n      if (truthy(n.condition)) {\n        statement = \"loop\";\n      } else {\n        statement = \"\" + keyword + \" \" + (this.build(n.condition));\n      }\n      if (isSingleLine(body_) && statement !== \"loop\") {\n        c.add(\"\" + (trim(body_)) + Code.INDENT + statement + \"\\n\");\n      } else {\n        c.add(statement);\n        c.scope(body_);\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['do'] = function(n) {\n      var c;\n      c = new Code;\n      c.add(\"loop\");\n      c.scope(this.body(n.body));\n      if (n.condition != null) {\n        c.scope(\"break unless \" + (this.build(n.condition)));\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['if'] = function(n) {\n      var body_, c, keyword;\n      c = new Code;\n      keyword = n.positive ? \"if\" : \"unless\";\n      body_ = this.body(n.thenPart);\n      n.condition.parenthesized = false;\n      if (n.thenPart.isA('block') && n.thenPart.children.length === 0 && (n.elsePart == null)) {\n        console.log(n.thenPart);\n        c.add(\"\" + (this.build(n.condition)) + \"\\n\");\n      } else if (isSingleLine(body_) && (n.elsePart == null)) {\n        c.add(\"\" + (trim(body_)) + Code.INDENT + keyword + \" \" + (this.build(n.condition)) + \"\\n\");\n      } else {\n        c.add(\"\" + keyword + \" \" + (this.build(n.condition)));\n        c.scope(this.body(n.thenPart));\n        if (n.elsePart != null) {\n          if (n.elsePart.typeName() === 'if') {\n            c.add(\"else \" + (this.build(n.elsePart).toString()));\n          } else {\n            c.add(this.l(n.elsePart) + \"else\\n\");\n            c.scope(this.body(n.elsePart));\n          }\n        }\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['switch'] = function(n) {\n      var c, fall_through,\n        _this = this;\n      c = new Code;\n      c.add(\"switch \" + (this.build(n.discriminant)) + \"\\n\");\n      fall_through = false;\n      _.each(n.cases, function(item) {\n        var first;\n        if (item.value === 'default') {\n          c.scope(_this.l(item) + \"else\");\n        } else {\n          if (fall_through === true) {\n            c.add(_this.l(item) + (\", \" + (_this.build(item.caseLabel)) + \"\\n\"));\n          } else {\n            c.add(_this.l(item) + (\"  when \" + (_this.build(item.caseLabel))));\n          }\n        }\n        if (_this.body(item.statements).length === 0) {\n          fall_through = true;\n        } else {\n          fall_through = false;\n          c.add(\"\\n\");\n          c.scope(_this.body(item.statements), 2);\n        }\n        return first = false;\n      });\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['existence_check'] = function(n) {\n      return this.l(n) + (\"\" + (this.build(n.left())) + \"?\");\n    };\n\n    Builder.prototype['array_init'] = function(n) {\n      var options;\n      options = {\n        array: true\n      };\n      if (n.children.length === 0) {\n        return this.l(n) + \"[]\";\n      } else if (n.children.length > 1) {\n        return this.l(n) + (\"[\" + (this.list(n, options)) + \"\\n]\");\n      } else {\n        return this.l(n) + (\"[\" + (this.list(n)) + \"]\");\n      }\n    };\n\n    Builder.prototype['property_init'] = function(n) {\n      var left, right;\n      left = n.left();\n      right = n.right();\n      right.is_property_value = true;\n      return \"\" + (this.property_identifier(left)) + \": \" + (this.build(right));\n    };\n\n    Builder.prototype['object_init'] = function(n, options) {\n      var c, list,\n        _this = this;\n      if (options == null) {\n        options = {};\n      }\n      if (n.children.length === 0) {\n        return this.l(n) + \"{}\";\n      } else if (n.children.length === 1 && !(n.is_property_value || n.is_list_element)) {\n        return this.build(n.children[0]);\n      } else {\n        list = _.map(n.children, function(item) {\n          return _this.build(item);\n        });\n        c = new Code(this, n);\n        c.scope(list.join(\"\\n\"));\n        if (options.brackets != null) {\n          c = \"{\" + c + \"}\";\n        }\n        return c;\n      }\n    };\n\n    Builder.prototype['function'] = function(n) {\n      var body, c, params,\n        _this = this;\n      c = new Code;\n      params = _.map(n.params, function(str) {\n        if (str.constructor === String) {\n          return _this.id_param(str);\n        } else {\n          return _this.build(str);\n        }\n      });\n      if (n.name) {\n        c.add(\"\" + n.name + \" = \");\n      }\n      if (n.params.length > 0) {\n        c.add(\"(\" + (params.join(', ')) + \") ->\");\n      } else {\n        c.add(\"->\");\n      }\n      body = this.body(n.body);\n      if (trim(body).length > 0) {\n        c.scope(body);\n      } else {\n        c.add(\"\\n\");\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['var'] = function(n) {\n      var list,\n        _this = this;\n      list = _.map(n.children, function(item) {\n        return \"\" + (unreserve(item.value)) + \" = \" + (item.initializer != null ? _this.build(item.initializer) : 'undefined');\n      });\n      return this.l(n) + _.compact(list).join(\"\\n\") + \"\\n\";\n    };\n\n    Builder.prototype['other'] = function(n) {\n      return this.unsupported(n, \"\" + (n.typeName()) + \" is not supported yet\");\n    };\n\n    Builder.prototype['getter'] = function(n) {\n      return this.unsupported(n, \"getter syntax is not supported; use __defineGetter__\");\n    };\n\n    Builder.prototype['setter'] = function(n) {\n      return this.unsupported(n, \"setter syntax is not supported; use __defineSetter__\");\n    };\n\n    Builder.prototype['label'] = function(n) {\n      return this.unsupported(n, \"labels are not supported by CoffeeScript\");\n    };\n\n    Builder.prototype['const'] = function(n) {\n      return this.unsupported(n, \"consts are not supported by CoffeeScript\");\n    };\n\n    Builder.prototype['block'] = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return this.script.apply(this, args);\n    };\n\n    Builder.prototype['unsupported'] = function(node, message) {\n      throw new UnsupportedError(\"Unsupported: \" + message, node);\n    };\n\n    return Builder;\n\n  })();\n\n  Transformer = (function() {\n    function Transformer() {}\n\n    Transformer.prototype.transform = function() {\n      var args, fn, node, type;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      node = args[0];\n      if (node.transformed != null) {\n        return;\n      }\n      type = node.typeName();\n      fn = this[type];\n      if (fn) {\n        fn.apply(this, args);\n        return node.transformed = true;\n      }\n    };\n\n    Transformer.prototype['script'] = function(n) {\n      var last,\n        _this = this;\n      n.functions = [];\n      n.nonfunctions = [];\n      _.each(n.children, function(item) {\n        if (item.isA('function')) {\n          return n.functions.push(item);\n        } else {\n          return n.nonfunctions.push(item);\n        }\n      });\n      last = null;\n      return _.each(n.nonfunctions, function(item) {\n        var expr;\n        if (item.expression != null) {\n          expr = item.expression;\n          if ((last != null ? last.isA('object_init') : void 0) && expr.isA('object_init')) {\n            item.parenthesized = true;\n          } else {\n            item.parenthesized = false;\n          }\n          return last = expr;\n        }\n      });\n    };\n\n    Transformer.prototype['.'] = function(n) {\n      if (n.left().isA('function')) {\n        n.left().parenthesized = true;\n      }\n      n.isThis = n.left().isA('this');\n      return n.isPrototype = n.right().isA('identifier') && n.right().value === 'prototype';\n    };\n\n    Transformer.prototype[';'] = function(n) {\n      if (n.expression != null) {\n        n.expression.parenthesized = false;\n        if (n.expression.isA('call')) {\n          n.expression.type = Typenames['call_statement'];\n          return this.call_statement(n);\n        }\n      }\n    };\n\n    Transformer.prototype['function'] = function(n) {\n      var nonreturns, transform_switch;\n      nonreturns = 0;\n      transform_switch = this[\"switch\"];\n      n.body.walk({\n        last: true\n      }, function(parent, node, list) {\n        var lastNode;\n        if (node.isA('switch')) {\n          transform_switch(node);\n        }\n        lastNode = list ? parent[list] : parent.children[parent.children.length - 1];\n        if (node.value && lastNode) {\n          if (node.isA('return')) {\n            lastNode.type = Typenames[';'];\n            return lastNode.expression = lastNode.value;\n          } else if (lastNode.isA('if', 'switch', 'block')) {\n\n          } else {\n            return nonreturns += 1;\n          }\n        }\n      });\n      if (nonreturns > 0) {\n        return n.body.children.push({\n          type: 'return',\n          typeName: function() {\n            return this.type;\n          },\n          isA: function(t) {\n            return t === this.type;\n          }\n        });\n      }\n    };\n\n    Transformer.prototype['switch'] = function(n) {\n      var _this = this;\n      return _.each(n.cases, function(item) {\n        var block, ch, _ref2;\n        block = item.statements;\n        ch = block.children;\n        if ((_ref2 = block.last()) != null ? _ref2.isA('break') : void 0) {\n          return delete ch[ch.length - 1];\n        }\n      });\n    };\n\n    Transformer.prototype['call_statement'] = function(n) {\n      if (n.children[1]) {\n        return _.each(n.children[1].children, function(child, i) {\n          if (child.isA('function') && i !== n.children[1].children.length - 1) {\n            return child.parenthesized = true;\n          }\n        });\n      }\n    };\n\n    Transformer.prototype['return'] = function(n) {\n      if (n.value && n.value.isA('object_init') && n.value.children.length > 1) {\n        return n.value.parenthesized = true;\n      }\n    };\n\n    Transformer.prototype['block'] = function(n) {\n      return this.script(n);\n    };\n\n    Transformer.prototype['if'] = function(n) {\n      var _ref2;\n      if (n.thenPart.isA('block') && n.thenPart.children.length === 0 && (!n.elsePartisA('block') || ((_ref2 = n.elsePart) != null ? _ref2.children.length : void 0) > 0)) {\n        n.positive = false;\n        n.thenPart = n.elsePart;\n        delete n.elsePart;\n      }\n      return this.inversible(n);\n    };\n\n    Transformer.prototype['while'] = function(n) {\n      if (n.body.children.length === 0) {\n        n.body.children.push(n.clone({\n          type: Typenames['continue'],\n          value: 'continue',\n          children: []\n        }));\n      }\n      return this.inversible(n);\n    };\n\n    Transformer.prototype['inversible'] = function(n) {\n      var positive;\n      this.transform(n.condition);\n      positive = n.positive != null ? n.positive : true;\n      if (n.condition.isA('!=')) {\n        n.condition.type = Typenames['=='];\n        return n.positive = !positive;\n      } else if (n.condition.isA('!')) {\n        n.condition = n.condition.left();\n        return n.positive = !positive;\n      } else {\n        return n.positive = positive;\n      }\n    };\n\n    Transformer.prototype['=='] = function(n) {\n      if (n.right().isA('null', 'void')) {\n        n.type = Typenames['!'];\n        return n.children = [\n          n.clone({\n            type: Typenames['existence_check'],\n            children: [n.left()]\n          })\n        ];\n      }\n    };\n\n    Transformer.prototype['!='] = function(n) {\n      if (n.right().isA('null', 'void')) {\n        n.type = Typenames['existence_check'];\n        return n.children = [n.left()];\n      }\n    };\n\n    return Transformer;\n\n  })();\n\n  UnsupportedError = (function() {\n    function UnsupportedError(str, src) {\n      this.message = str;\n      this.cursor = src.start;\n      this.line = src.lineno;\n      this.source = src.tokenizer.source;\n    }\n\n    UnsupportedError.prototype.toString = function() {\n      return this.message;\n    };\n\n    return UnsupportedError;\n\n  })();\n\n  this.Js2coffee = exports = {\n    VERSION: pkg.version,\n    build: buildCoffee,\n    UnsupportedError: UnsupportedError\n  };\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = exports;\n  }\n\n}).call(this);\n",
      "renderSingleExtensions": false,
      "minify": true,
      "meta": {
        "minify": true
      }
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/lib/command.js.coffee",
      "relativePath": "lib/command.js.coffee",
      "basename": "command",
      "outBasename": "command",
      "extension": "coffee",
      "outExtension": "js",
      "extensions": [
        "js",
        "coffee"
      ],
      "filename": "command.js.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/lib",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/lib/command.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/lib",
      "outFilename": "command.js",
      "relativeOutPath": "lib/command.js",
      "relativeDirPath": "lib",
      "relativeOutDirPath": "lib",
      "relativeBase": "lib/command",
      "relativeOutBase": "lib/command",
      "contentType": "application/octet-stream",
      "outContentType": "application/javascript",
      "ctime": "2013-12-30T16:19:41.000Z",
      "mtime": "2014-01-20T02:05:18.212Z",
      "rtime": "2014-01-20T02:05:25.496Z",
      "wtime": "2014-01-20T02:05:25.696Z",
      "exists": true,
      "encoding": "utf8",
      "source": "# The `js2coffee` utility.\n# Handles command-line compilation of JavaScript into various forms:\n# saved into `.coffee` files or printed to stdout\n\n# External dependencies.\njs2coffee = require './js2coffee'\nfsUtil    = require 'fs'\npathUtil  = require 'path'\ntty       = require 'tty'\nfileUtil  = require 'file'\n{inspect} = require 'util'\nnopt      = require 'nopt'\n\n# The help banner that is printed when `js2coffee` is called without arguments.\nBANNER =  \"\"\"\n     Usage: js2coffee [options] path/to/script.js\n\n       js2coffee file.js\n       js2coffee file.js > output.coffee\n       cat file.js | js2coffee\n\"\"\"\n\nknownOpts =\n  version: Boolean # show js2coffee version\n  verbose: Boolean # be verbose\n  no_comments: Boolean # do not translate comments\n  show_src_lineno: Boolean # show src lineno's as comments\n  single_quotes: Boolean # use single quoted string literals\n  help: Boolean # if you need help\n  indent: String # set indent character(s), default two spaces\n\nshortHands =\n  v: [\"--version\"]\n  V: [\"--verbose\"]\n  X: [\"--no_comments\"]\n  l: [\"--show_src_lineno\"]\n  h: [\"--help\"]\n  sq: [\"--single_quotes\"]\n  i4: [\"--indent\", \"    \"]\n  it: [\"--indent\", \"\\t\"]\n\n# The list of all the valid option flags that `js2coffee` knows how to handle.\ndescription =\n  version: 'Show js2coffee version'\n  verbose: 'Be verbose'\n  no_comments: 'Do not translate comments'\n  show_src_lineno: 'Show src lineno\\'s as comments'\n  help: 'If you need help'\n  single_quotes: \"Use single quoted string literals - default double quoted\"\n  indent: 'Specify the indent character(s) - default 2 spaces'\n\n# Top-level objects shared by all the functions.\noptions  = {}\nsources  = []\n\nencoding = 'utf-8'\nUnsupportedError = js2coffee.UnsupportedError\ncmd      = pathUtil.basename(process.argv[1])\n\nparseOptions = ->\n  options = nopt knownOpts, shortHands, process.argv, 2\n  sources = options.argv.remain or= []\n\n  if options.no_comments is true and options.show_src_lineno is true\n    console.warn \"You cannot combine -l and -X\"\n    return process.exit 1\n\n  # nopt trim string values, copy it manually from argv.cooked\n  index = options.argv.cooked.indexOf \"--indent\"\n  if index isnt -1 and options.argv.cooked.length >= index\n    options.indent = options.argv.cooked[index+1]\n\nwriteFile = (dir, currfile, coffee) ->\n  outputdir = options.output || '.'\n  try\n    if (outputdir.search '/') == -1\n      outputdir = outputdir.concat '/'\n    newPath = outputdir + dir + '/'\n    try\n      fsUtil.statSync(newPath).isDirectory()\n    catch e\n      fileUtil.mkdirsSync(newPath)\n    currfile = (currfile.split '.')[0] + '.coffee'\n    newFile = newPath + currfile\n    (console.log \"writing %s \", newFile) if options.verbose\n    fsUtil.writeFileSync(newFile, coffee, encoding)\n  catch e\n    console.error e\n\nbatch = () ->\n  callback = (dirPath, dirs, files) ->\n    for f in files\n      try\n        if ((f.split '.')[1] == 'js')\n          readf = dirPath + '/' + f\n          (console.log \"read file %s\", readf) if options.verbose\n          contents = fsUtil.readFileSync(readf, encoding)\n          output = js2coffee.build(contents,options)\n          writeFile(dirPath, f, output)\n      catch e\n        console.error e\n\n  for i in sources\n    try\n      if fsUtil.statSync(i).isDirectory()\n        if options.recursive\n          fileUtil.walkSync(i, callback)\n        else\n          list = []\n          for v in fsUtil.readdirSync(i)\n            if fsUtil.statSync(v).isFile()\n              list.add v\n          callback(i, '', list)\n    catch e\n      #console.error e\n\n# Compile a path, which could be a script or a directory. If a directory\n# is passed, recursively compile all '.js' extension source files in it\n# and all subdirectories.\ncompilePath = (source, topLevel = yes) ->\n  fsUtil.stat source, (err, stats) ->\n    throw err if err and err.code isnt 'ENOENT'\n    if err?.code is 'ENOENT' # file does not exist\n      if topLevel and source[-3..] isnt '.js'\n        # retry with extension '.js' added\n        source = \"#{source}.js\"\n        return compilePath source, topLevel\n      if topLevel\n        console.error \"File not found: #{source}\"\n        process.exit 1\n      return\n\n    if stats.isDirectory()\n      fsUtil.readdir source, (err, files) ->\n        throw err if err and err.code isnt 'ENOENT'\n        return if err?.code is 'ENOENT'\n        # index = sources.indexOf source\n        # sources[index..index] = (pathUtil.join source, file for file in files)\n        # sourceCode[index..index] = files.map -> null\n        for file in files when not hidden file\n          compilePath (pathUtil.join source, file), no\n    else if topLevel or (pathUtil.extname source) in ['.js', '.json']\n      compileScript source\n\n# Test if file is hidden (starts with a dot)\nhidden = (file) -> /^\\.|~$/.test file\n\n# Compile a single source script, containing the given code, according to the\n# requested options and write it on output (currently stdout)\ncompileScript = ( fname ) ->\n  try\n    console.log \"#### ---- #{fname}\" if options.verbose\n    code = fsUtil.readFileSync fname\n    if '.json' is pathUtil.extname fname\n      code = \"(#{code})\"\n    compiled_code = js2coffee.build(code.toString(),options)\n    console.log compiled_code\n  catch err\n    console.warn err instanceof Error and err.stack or \"ERROR: #{err} while compiling #{file}\"\n    exit 1 if options.stop_on_error\n\ncompileFromStdin = ->\n  contents = fsUtil.readFileSync(\"/dev/stdin\", encoding) # TODO: is this cross-platform?\n  output   = js2coffee.build(contents,options)\n  console.log output\n\nusage = ->\n  console.warn BANNER + \"\\n\"\n  console.warn \"options:\"\n  for arg of knownOpts\n    console.warn \"--#{arg} # #{description[arg]}\"\n  console.warn \"\\nshorcuts:\"\n  for short, long of shortHands\n    if short is '___singles'\n      continue\n    console.warn \"-#{short} = #{inspect long}\"\n  process.exit 0\n\nversion = ->\n  \"js2coffee version #{js2coffee.VERSION}\"\n\n# Run `js2coffee` by parsing passed options and determining what action to take.\nexports.run = ->\n  parseOptions()\n\n  return usage()                if options.help\n  return console.log version()  if options.version\n  console.log \"#### \"+version() if options.verbose\n\n  if sources.length > 0\n    for s in sources\n      compilePath s\n  else\n    return compileFromStdin '/dev/stdin' if not tty.isatty process.stdin\n    # if we come here there was nothing else to do\n    return usage()\n",
      "content": "# The `js2coffee` utility.\n# Handles command-line compilation of JavaScript into various forms:\n# saved into `.coffee` files or printed to stdout\n\n# External dependencies.\njs2coffee = require './js2coffee'\nfsUtil    = require 'fs'\npathUtil  = require 'path'\ntty       = require 'tty'\nfileUtil  = require 'file'\n{inspect} = require 'util'\nnopt      = require 'nopt'\n\n# The help banner that is printed when `js2coffee` is called without arguments.\nBANNER =  \"\"\"\n     Usage: js2coffee [options] path/to/script.js\n\n       js2coffee file.js\n       js2coffee file.js > output.coffee\n       cat file.js | js2coffee\n\"\"\"\n\nknownOpts =\n  version: Boolean # show js2coffee version\n  verbose: Boolean # be verbose\n  no_comments: Boolean # do not translate comments\n  show_src_lineno: Boolean # show src lineno's as comments\n  single_quotes: Boolean # use single quoted string literals\n  help: Boolean # if you need help\n  indent: String # set indent character(s), default two spaces\n\nshortHands =\n  v: [\"--version\"]\n  V: [\"--verbose\"]\n  X: [\"--no_comments\"]\n  l: [\"--show_src_lineno\"]\n  h: [\"--help\"]\n  sq: [\"--single_quotes\"]\n  i4: [\"--indent\", \"    \"]\n  it: [\"--indent\", \"\\t\"]\n\n# The list of all the valid option flags that `js2coffee` knows how to handle.\ndescription =\n  version: 'Show js2coffee version'\n  verbose: 'Be verbose'\n  no_comments: 'Do not translate comments'\n  show_src_lineno: 'Show src lineno\\'s as comments'\n  help: 'If you need help'\n  single_quotes: \"Use single quoted string literals - default double quoted\"\n  indent: 'Specify the indent character(s) - default 2 spaces'\n\n# Top-level objects shared by all the functions.\noptions  = {}\nsources  = []\n\nencoding = 'utf-8'\nUnsupportedError = js2coffee.UnsupportedError\ncmd      = pathUtil.basename(process.argv[1])\n\nparseOptions = ->\n  options = nopt knownOpts, shortHands, process.argv, 2\n  sources = options.argv.remain or= []\n\n  if options.no_comments is true and options.show_src_lineno is true\n    console.warn \"You cannot combine -l and -X\"\n    return process.exit 1\n\n  # nopt trim string values, copy it manually from argv.cooked\n  index = options.argv.cooked.indexOf \"--indent\"\n  if index isnt -1 and options.argv.cooked.length >= index\n    options.indent = options.argv.cooked[index+1]\n\nwriteFile = (dir, currfile, coffee) ->\n  outputdir = options.output || '.'\n  try\n    if (outputdir.search '/') == -1\n      outputdir = outputdir.concat '/'\n    newPath = outputdir + dir + '/'\n    try\n      fsUtil.statSync(newPath).isDirectory()\n    catch e\n      fileUtil.mkdirsSync(newPath)\n    currfile = (currfile.split '.')[0] + '.coffee'\n    newFile = newPath + currfile\n    (console.log \"writing %s \", newFile) if options.verbose\n    fsUtil.writeFileSync(newFile, coffee, encoding)\n  catch e\n    console.error e\n\nbatch = () ->\n  callback = (dirPath, dirs, files) ->\n    for f in files\n      try\n        if ((f.split '.')[1] == 'js')\n          readf = dirPath + '/' + f\n          (console.log \"read file %s\", readf) if options.verbose\n          contents = fsUtil.readFileSync(readf, encoding)\n          output = js2coffee.build(contents,options)\n          writeFile(dirPath, f, output)\n      catch e\n        console.error e\n\n  for i in sources\n    try\n      if fsUtil.statSync(i).isDirectory()\n        if options.recursive\n          fileUtil.walkSync(i, callback)\n        else\n          list = []\n          for v in fsUtil.readdirSync(i)\n            if fsUtil.statSync(v).isFile()\n              list.add v\n          callback(i, '', list)\n    catch e\n      #console.error e\n\n# Compile a path, which could be a script or a directory. If a directory\n# is passed, recursively compile all '.js' extension source files in it\n# and all subdirectories.\ncompilePath = (source, topLevel = yes) ->\n  fsUtil.stat source, (err, stats) ->\n    throw err if err and err.code isnt 'ENOENT'\n    if err?.code is 'ENOENT' # file does not exist\n      if topLevel and source[-3..] isnt '.js'\n        # retry with extension '.js' added\n        source = \"#{source}.js\"\n        return compilePath source, topLevel\n      if topLevel\n        console.error \"File not found: #{source}\"\n        process.exit 1\n      return\n\n    if stats.isDirectory()\n      fsUtil.readdir source, (err, files) ->\n        throw err if err and err.code isnt 'ENOENT'\n        return if err?.code is 'ENOENT'\n        # index = sources.indexOf source\n        # sources[index..index] = (pathUtil.join source, file for file in files)\n        # sourceCode[index..index] = files.map -> null\n        for file in files when not hidden file\n          compilePath (pathUtil.join source, file), no\n    else if topLevel or (pathUtil.extname source) in ['.js', '.json']\n      compileScript source\n\n# Test if file is hidden (starts with a dot)\nhidden = (file) -> /^\\.|~$/.test file\n\n# Compile a single source script, containing the given code, according to the\n# requested options and write it on output (currently stdout)\ncompileScript = ( fname ) ->\n  try\n    console.log \"#### ---- #{fname}\" if options.verbose\n    code = fsUtil.readFileSync fname\n    if '.json' is pathUtil.extname fname\n      code = \"(#{code})\"\n    compiled_code = js2coffee.build(code.toString(),options)\n    console.log compiled_code\n  catch err\n    console.warn err instanceof Error and err.stack or \"ERROR: #{err} while compiling #{file}\"\n    exit 1 if options.stop_on_error\n\ncompileFromStdin = ->\n  contents = fsUtil.readFileSync(\"/dev/stdin\", encoding) # TODO: is this cross-platform?\n  output   = js2coffee.build(contents,options)\n  console.log output\n\nusage = ->\n  console.warn BANNER + \"\\n\"\n  console.warn \"options:\"\n  for arg of knownOpts\n    console.warn \"--#{arg} # #{description[arg]}\"\n  console.warn \"\\nshorcuts:\"\n  for short, long of shortHands\n    if short is '___singles'\n      continue\n    console.warn \"-#{short} = #{inspect long}\"\n  process.exit 0\n\nversion = ->\n  \"js2coffee version #{js2coffee.VERSION}\"\n\n# Run `js2coffee` by parsing passed options and determining what action to take.\nexports.run = ->\n  parseOptions()\n\n  return usage()                if options.help\n  return console.log version()  if options.version\n  console.log \"#### \"+version() if options.verbose\n\n  if sources.length > 0\n    for s in sources\n      compilePath s\n  else\n    return compileFromStdin '/dev/stdin' if not tty.isatty process.stdin\n    # if we come here there was nothing else to do\n    return usage()\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "command.js",
      "date": "2014-01-20T02:05:18.212Z",
      "slug": "lib-command",
      "url": "/lib/command.js",
      "urls": [
        "/lib/command.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "# The `js2coffee` utility.\n# Handles command-line compilation of JavaScript into various forms:\n# saved into `.coffee` files or printed to stdout\n\n# External dependencies.\njs2coffee = require './js2coffee'\nfsUtil    = require 'fs'\npathUtil  = require 'path'\ntty       = require 'tty'\nfileUtil  = require 'file'\n{inspect} = require 'util'\nnopt      = require 'nopt'\n\n# The help banner that is printed when `js2coffee` is called without arguments.\nBANNER =  \"\"\"\n     Usage: js2coffee [options] path/to/script.js\n\n       js2coffee file.js\n       js2coffee file.js > output.coffee\n       cat file.js | js2coffee\n\"\"\"\n\nknownOpts =\n  version: Boolean # show js2coffee version\n  verbose: Boolean # be verbose\n  no_comments: Boolean # do not translate comments\n  show_src_lineno: Boolean # show src lineno's as comments\n  single_quotes: Boolean # use single quoted string literals\n  help: Boolean # if you need help\n  indent: String # set indent character(s), default two spaces\n\nshortHands =\n  v: [\"--version\"]\n  V: [\"--verbose\"]\n  X: [\"--no_comments\"]\n  l: [\"--show_src_lineno\"]\n  h: [\"--help\"]\n  sq: [\"--single_quotes\"]\n  i4: [\"--indent\", \"    \"]\n  it: [\"--indent\", \"\\t\"]\n\n# The list of all the valid option flags that `js2coffee` knows how to handle.\ndescription =\n  version: 'Show js2coffee version'\n  verbose: 'Be verbose'\n  no_comments: 'Do not translate comments'\n  show_src_lineno: 'Show src lineno\\'s as comments'\n  help: 'If you need help'\n  single_quotes: \"Use single quoted string literals - default double quoted\"\n  indent: 'Specify the indent character(s) - default 2 spaces'\n\n# Top-level objects shared by all the functions.\noptions  = {}\nsources  = []\n\nencoding = 'utf-8'\nUnsupportedError = js2coffee.UnsupportedError\ncmd      = pathUtil.basename(process.argv[1])\n\nparseOptions = ->\n  options = nopt knownOpts, shortHands, process.argv, 2\n  sources = options.argv.remain or= []\n\n  if options.no_comments is true and options.show_src_lineno is true\n    console.warn \"You cannot combine -l and -X\"\n    return process.exit 1\n\n  # nopt trim string values, copy it manually from argv.cooked\n  index = options.argv.cooked.indexOf \"--indent\"\n  if index isnt -1 and options.argv.cooked.length >= index\n    options.indent = options.argv.cooked[index+1]\n\nwriteFile = (dir, currfile, coffee) ->\n  outputdir = options.output || '.'\n  try\n    if (outputdir.search '/') == -1\n      outputdir = outputdir.concat '/'\n    newPath = outputdir + dir + '/'\n    try\n      fsUtil.statSync(newPath).isDirectory()\n    catch e\n      fileUtil.mkdirsSync(newPath)\n    currfile = (currfile.split '.')[0] + '.coffee'\n    newFile = newPath + currfile\n    (console.log \"writing %s \", newFile) if options.verbose\n    fsUtil.writeFileSync(newFile, coffee, encoding)\n  catch e\n    console.error e\n\nbatch = () ->\n  callback = (dirPath, dirs, files) ->\n    for f in files\n      try\n        if ((f.split '.')[1] == 'js')\n          readf = dirPath + '/' + f\n          (console.log \"read file %s\", readf) if options.verbose\n          contents = fsUtil.readFileSync(readf, encoding)\n          output = js2coffee.build(contents,options)\n          writeFile(dirPath, f, output)\n      catch e\n        console.error e\n\n  for i in sources\n    try\n      if fsUtil.statSync(i).isDirectory()\n        if options.recursive\n          fileUtil.walkSync(i, callback)\n        else\n          list = []\n          for v in fsUtil.readdirSync(i)\n            if fsUtil.statSync(v).isFile()\n              list.add v\n          callback(i, '', list)\n    catch e\n      #console.error e\n\n# Compile a path, which could be a script or a directory. If a directory\n# is passed, recursively compile all '.js' extension source files in it\n# and all subdirectories.\ncompilePath = (source, topLevel = yes) ->\n  fsUtil.stat source, (err, stats) ->\n    throw err if err and err.code isnt 'ENOENT'\n    if err?.code is 'ENOENT' # file does not exist\n      if topLevel and source[-3..] isnt '.js'\n        # retry with extension '.js' added\n        source = \"#{source}.js\"\n        return compilePath source, topLevel\n      if topLevel\n        console.error \"File not found: #{source}\"\n        process.exit 1\n      return\n\n    if stats.isDirectory()\n      fsUtil.readdir source, (err, files) ->\n        throw err if err and err.code isnt 'ENOENT'\n        return if err?.code is 'ENOENT'\n        # index = sources.indexOf source\n        # sources[index..index] = (pathUtil.join source, file for file in files)\n        # sourceCode[index..index] = files.map -> null\n        for file in files when not hidden file\n          compilePath (pathUtil.join source, file), no\n    else if topLevel or (pathUtil.extname source) in ['.js', '.json']\n      compileScript source\n\n# Test if file is hidden (starts with a dot)\nhidden = (file) -> /^\\.|~$/.test file\n\n# Compile a single source script, containing the given code, according to the\n# requested options and write it on output (currently stdout)\ncompileScript = ( fname ) ->\n  try\n    console.log \"#### ---- #{fname}\" if options.verbose\n    code = fsUtil.readFileSync fname\n    if '.json' is pathUtil.extname fname\n      code = \"(#{code})\"\n    compiled_code = js2coffee.build(code.toString(),options)\n    console.log compiled_code\n  catch err\n    console.warn err instanceof Error and err.stack or \"ERROR: #{err} while compiling #{file}\"\n    exit 1 if options.stop_on_error\n\ncompileFromStdin = ->\n  contents = fsUtil.readFileSync(\"/dev/stdin\", encoding) # TODO: is this cross-platform?\n  output   = js2coffee.build(contents,options)\n  console.log output\n\nusage = ->\n  console.warn BANNER + \"\\n\"\n  console.warn \"options:\"\n  for arg of knownOpts\n    console.warn \"--#{arg} # #{description[arg]}\"\n  console.warn \"\\nshorcuts:\"\n  for short, long of shortHands\n    if short is '___singles'\n      continue\n    console.warn \"-#{short} = #{inspect long}\"\n  process.exit 0\n\nversion = ->\n  \"js2coffee version #{js2coffee.VERSION}\"\n\n# Run `js2coffee` by parsing passed options and determining what action to take.\nexports.run = ->\n  parseOptions()\n\n  return usage()                if options.help\n  return console.log version()  if options.version\n  console.log \"#### \"+version() if options.verbose\n\n  if sources.length > 0\n    for s in sources\n      compilePath s\n  else\n    return compileFromStdin '/dev/stdin' if not tty.isatty process.stdin\n    # if we come here there was nothing else to do\n    return usage()\n",
      "rendered": true,
      "contentRendered": "(function() {\n  var BANNER, UnsupportedError, batch, cmd, compileFromStdin, compilePath, compileScript, description, encoding, fileUtil, fsUtil, hidden, inspect, js2coffee, knownOpts, nopt, options, parseOptions, pathUtil, shortHands, sources, tty, usage, version, writeFile;\n\n  js2coffee = require('./js2coffee');\n\n  fsUtil = require('fs');\n\n  pathUtil = require('path');\n\n  tty = require('tty');\n\n  fileUtil = require('file');\n\n  inspect = require('util').inspect;\n\n  nopt = require('nopt');\n\n  BANNER = \"Usage: js2coffee [options] path/to/script.js\\n\\n  js2coffee file.js\\n  js2coffee file.js > output.coffee\\n  cat file.js | js2coffee\";\n\n  knownOpts = {\n    version: Boolean,\n    verbose: Boolean,\n    no_comments: Boolean,\n    show_src_lineno: Boolean,\n    single_quotes: Boolean,\n    help: Boolean,\n    indent: String\n  };\n\n  shortHands = {\n    v: [\"--version\"],\n    V: [\"--verbose\"],\n    X: [\"--no_comments\"],\n    l: [\"--show_src_lineno\"],\n    h: [\"--help\"],\n    sq: [\"--single_quotes\"],\n    i4: [\"--indent\", \"    \"],\n    it: [\"--indent\", \"\\t\"]\n  };\n\n  description = {\n    version: 'Show js2coffee version',\n    verbose: 'Be verbose',\n    no_comments: 'Do not translate comments',\n    show_src_lineno: 'Show src lineno\\'s as comments',\n    help: 'If you need help',\n    single_quotes: \"Use single quoted string literals - default double quoted\",\n    indent: 'Specify the indent character(s) - default 2 spaces'\n  };\n\n  options = {};\n\n  sources = [];\n\n  encoding = 'utf-8';\n\n  UnsupportedError = js2coffee.UnsupportedError;\n\n  cmd = pathUtil.basename(process.argv[1]);\n\n  parseOptions = function() {\n    var index, _base;\n    options = nopt(knownOpts, shortHands, process.argv, 2);\n    sources = (_base = options.argv).remain || (_base.remain = []);\n    if (options.no_comments === true && options.show_src_lineno === true) {\n      console.warn(\"You cannot combine -l and -X\");\n      return process.exit(1);\n    }\n    index = options.argv.cooked.indexOf(\"--indent\");\n    if (index !== -1 && options.argv.cooked.length >= index) {\n      return options.indent = options.argv.cooked[index + 1];\n    }\n  };\n\n  writeFile = function(dir, currfile, coffee) {\n    var e, newFile, newPath, outputdir;\n    outputdir = options.output || '.';\n    try {\n      if ((outputdir.search('/')) === -1) {\n        outputdir = outputdir.concat('/');\n      }\n      newPath = outputdir + dir + '/';\n      try {\n        fsUtil.statSync(newPath).isDirectory();\n      } catch (_error) {\n        e = _error;\n        fileUtil.mkdirsSync(newPath);\n      }\n      currfile = (currfile.split('.'))[0] + '.coffee';\n      newFile = newPath + currfile;\n      if (options.verbose) {\n        console.log(\"writing %s \", newFile);\n      }\n      return fsUtil.writeFileSync(newFile, coffee, encoding);\n    } catch (_error) {\n      e = _error;\n      return console.error(e);\n    }\n  };\n\n  batch = function() {\n    var callback, e, i, list, v, _i, _j, _len, _len1, _ref, _results;\n    callback = function(dirPath, dirs, files) {\n      var contents, e, f, output, readf, _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = files.length; _i < _len; _i++) {\n        f = files[_i];\n        try {\n          if ((f.split('.'))[1] === 'js') {\n            readf = dirPath + '/' + f;\n            if (options.verbose) {\n              console.log(\"read file %s\", readf);\n            }\n            contents = fsUtil.readFileSync(readf, encoding);\n            output = js2coffee.build(contents, options);\n            _results.push(writeFile(dirPath, f, output));\n          } else {\n            _results.push(void 0);\n          }\n        } catch (_error) {\n          e = _error;\n          _results.push(console.error(e));\n        }\n      }\n      return _results;\n    };\n    _results = [];\n    for (_i = 0, _len = sources.length; _i < _len; _i++) {\n      i = sources[_i];\n      try {\n        if (fsUtil.statSync(i).isDirectory()) {\n          if (options.recursive) {\n            _results.push(fileUtil.walkSync(i, callback));\n          } else {\n            list = [];\n            _ref = fsUtil.readdirSync(i);\n            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n              v = _ref[_j];\n              if (fsUtil.statSync(v).isFile()) {\n                list.add(v);\n              }\n            }\n            _results.push(callback(i, '', list));\n          }\n        } else {\n          _results.push(void 0);\n        }\n      } catch (_error) {\n        e = _error;\n      }\n    }\n    return _results;\n  };\n\n  compilePath = function(source, topLevel) {\n    if (topLevel == null) {\n      topLevel = true;\n    }\n    return fsUtil.stat(source, function(err, stats) {\n      var _ref;\n      if (err && err.code !== 'ENOENT') {\n        throw err;\n      }\n      if ((err != null ? err.code : void 0) === 'ENOENT') {\n        if (topLevel && source.slice(-3) !== '.js') {\n          source = \"\" + source + \".js\";\n          return compilePath(source, topLevel);\n        }\n        if (topLevel) {\n          console.error(\"File not found: \" + source);\n          process.exit(1);\n        }\n        return;\n      }\n      if (stats.isDirectory()) {\n        return fsUtil.readdir(source, function(err, files) {\n          var file, _i, _len, _results;\n          if (err && err.code !== 'ENOENT') {\n            throw err;\n          }\n          if ((err != null ? err.code : void 0) === 'ENOENT') {\n            return;\n          }\n          _results = [];\n          for (_i = 0, _len = files.length; _i < _len; _i++) {\n            file = files[_i];\n            if (!hidden(file)) {\n              _results.push(compilePath(pathUtil.join(source, file), false));\n            }\n          }\n          return _results;\n        });\n      } else if (topLevel || ((_ref = pathUtil.extname(source)) === '.js' || _ref === '.json')) {\n        return compileScript(source);\n      }\n    });\n  };\n\n  hidden = function(file) {\n    return /^\\.|~$/.test(file);\n  };\n\n  compileScript = function(fname) {\n    var code, compiled_code, err;\n    try {\n      if (options.verbose) {\n        console.log(\"#### ---- \" + fname);\n      }\n      code = fsUtil.readFileSync(fname);\n      if ('.json' === pathUtil.extname(fname)) {\n        code = \"(\" + code + \")\";\n      }\n      compiled_code = js2coffee.build(code.toString(), options);\n      return console.log(compiled_code);\n    } catch (_error) {\n      err = _error;\n      console.warn(err instanceof Error && err.stack || (\"ERROR: \" + err + \" while compiling \" + file));\n      if (options.stop_on_error) {\n        return exit(1);\n      }\n    }\n  };\n\n  compileFromStdin = function() {\n    var contents, output;\n    contents = fsUtil.readFileSync(\"/dev/stdin\", encoding);\n    output = js2coffee.build(contents, options);\n    return console.log(output);\n  };\n\n  usage = function() {\n    var arg, long, short;\n    console.warn(BANNER + \"\\n\");\n    console.warn(\"options:\");\n    for (arg in knownOpts) {\n      console.warn(\"--\" + arg + \" # \" + description[arg]);\n    }\n    console.warn(\"\\nshorcuts:\");\n    for (short in shortHands) {\n      long = shortHands[short];\n      if (short === '___singles') {\n        continue;\n      }\n      console.warn(\"-\" + short + \" = \" + (inspect(long)));\n    }\n    return process.exit(0);\n  };\n\n  version = function() {\n    return \"js2coffee version \" + js2coffee.VERSION;\n  };\n\n  exports.run = function() {\n    var s, _i, _len, _results;\n    parseOptions();\n    if (options.help) {\n      return usage();\n    }\n    if (options.version) {\n      return console.log(version());\n    }\n    if (options.verbose) {\n      console.log(\"#### \" + version());\n    }\n    if (sources.length > 0) {\n      _results = [];\n      for (_i = 0, _len = sources.length; _i < _len; _i++) {\n        s = sources[_i];\n        _results.push(compilePath(s));\n      }\n      return _results;\n    } else {\n      if (!tty.isatty(process.stdin)) {\n        return compileFromStdin('/dev/stdin');\n      }\n      return usage();\n    }\n  };\n\n}).call(this);\n",
      "contentRenderedWithoutLayouts": "(function() {\n  var BANNER, UnsupportedError, batch, cmd, compileFromStdin, compilePath, compileScript, description, encoding, fileUtil, fsUtil, hidden, inspect, js2coffee, knownOpts, nopt, options, parseOptions, pathUtil, shortHands, sources, tty, usage, version, writeFile;\n\n  js2coffee = require('./js2coffee');\n\n  fsUtil = require('fs');\n\n  pathUtil = require('path');\n\n  tty = require('tty');\n\n  fileUtil = require('file');\n\n  inspect = require('util').inspect;\n\n  nopt = require('nopt');\n\n  BANNER = \"Usage: js2coffee [options] path/to/script.js\\n\\n  js2coffee file.js\\n  js2coffee file.js > output.coffee\\n  cat file.js | js2coffee\";\n\n  knownOpts = {\n    version: Boolean,\n    verbose: Boolean,\n    no_comments: Boolean,\n    show_src_lineno: Boolean,\n    single_quotes: Boolean,\n    help: Boolean,\n    indent: String\n  };\n\n  shortHands = {\n    v: [\"--version\"],\n    V: [\"--verbose\"],\n    X: [\"--no_comments\"],\n    l: [\"--show_src_lineno\"],\n    h: [\"--help\"],\n    sq: [\"--single_quotes\"],\n    i4: [\"--indent\", \"    \"],\n    it: [\"--indent\", \"\\t\"]\n  };\n\n  description = {\n    version: 'Show js2coffee version',\n    verbose: 'Be verbose',\n    no_comments: 'Do not translate comments',\n    show_src_lineno: 'Show src lineno\\'s as comments',\n    help: 'If you need help',\n    single_quotes: \"Use single quoted string literals - default double quoted\",\n    indent: 'Specify the indent character(s) - default 2 spaces'\n  };\n\n  options = {};\n\n  sources = [];\n\n  encoding = 'utf-8';\n\n  UnsupportedError = js2coffee.UnsupportedError;\n\n  cmd = pathUtil.basename(process.argv[1]);\n\n  parseOptions = function() {\n    var index, _base;\n    options = nopt(knownOpts, shortHands, process.argv, 2);\n    sources = (_base = options.argv).remain || (_base.remain = []);\n    if (options.no_comments === true && options.show_src_lineno === true) {\n      console.warn(\"You cannot combine -l and -X\");\n      return process.exit(1);\n    }\n    index = options.argv.cooked.indexOf(\"--indent\");\n    if (index !== -1 && options.argv.cooked.length >= index) {\n      return options.indent = options.argv.cooked[index + 1];\n    }\n  };\n\n  writeFile = function(dir, currfile, coffee) {\n    var e, newFile, newPath, outputdir;\n    outputdir = options.output || '.';\n    try {\n      if ((outputdir.search('/')) === -1) {\n        outputdir = outputdir.concat('/');\n      }\n      newPath = outputdir + dir + '/';\n      try {\n        fsUtil.statSync(newPath).isDirectory();\n      } catch (_error) {\n        e = _error;\n        fileUtil.mkdirsSync(newPath);\n      }\n      currfile = (currfile.split('.'))[0] + '.coffee';\n      newFile = newPath + currfile;\n      if (options.verbose) {\n        console.log(\"writing %s \", newFile);\n      }\n      return fsUtil.writeFileSync(newFile, coffee, encoding);\n    } catch (_error) {\n      e = _error;\n      return console.error(e);\n    }\n  };\n\n  batch = function() {\n    var callback, e, i, list, v, _i, _j, _len, _len1, _ref, _results;\n    callback = function(dirPath, dirs, files) {\n      var contents, e, f, output, readf, _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = files.length; _i < _len; _i++) {\n        f = files[_i];\n        try {\n          if ((f.split('.'))[1] === 'js') {\n            readf = dirPath + '/' + f;\n            if (options.verbose) {\n              console.log(\"read file %s\", readf);\n            }\n            contents = fsUtil.readFileSync(readf, encoding);\n            output = js2coffee.build(contents, options);\n            _results.push(writeFile(dirPath, f, output));\n          } else {\n            _results.push(void 0);\n          }\n        } catch (_error) {\n          e = _error;\n          _results.push(console.error(e));\n        }\n      }\n      return _results;\n    };\n    _results = [];\n    for (_i = 0, _len = sources.length; _i < _len; _i++) {\n      i = sources[_i];\n      try {\n        if (fsUtil.statSync(i).isDirectory()) {\n          if (options.recursive) {\n            _results.push(fileUtil.walkSync(i, callback));\n          } else {\n            list = [];\n            _ref = fsUtil.readdirSync(i);\n            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n              v = _ref[_j];\n              if (fsUtil.statSync(v).isFile()) {\n                list.add(v);\n              }\n            }\n            _results.push(callback(i, '', list));\n          }\n        } else {\n          _results.push(void 0);\n        }\n      } catch (_error) {\n        e = _error;\n      }\n    }\n    return _results;\n  };\n\n  compilePath = function(source, topLevel) {\n    if (topLevel == null) {\n      topLevel = true;\n    }\n    return fsUtil.stat(source, function(err, stats) {\n      var _ref;\n      if (err && err.code !== 'ENOENT') {\n        throw err;\n      }\n      if ((err != null ? err.code : void 0) === 'ENOENT') {\n        if (topLevel && source.slice(-3) !== '.js') {\n          source = \"\" + source + \".js\";\n          return compilePath(source, topLevel);\n        }\n        if (topLevel) {\n          console.error(\"File not found: \" + source);\n          process.exit(1);\n        }\n        return;\n      }\n      if (stats.isDirectory()) {\n        return fsUtil.readdir(source, function(err, files) {\n          var file, _i, _len, _results;\n          if (err && err.code !== 'ENOENT') {\n            throw err;\n          }\n          if ((err != null ? err.code : void 0) === 'ENOENT') {\n            return;\n          }\n          _results = [];\n          for (_i = 0, _len = files.length; _i < _len; _i++) {\n            file = files[_i];\n            if (!hidden(file)) {\n              _results.push(compilePath(pathUtil.join(source, file), false));\n            }\n          }\n          return _results;\n        });\n      } else if (topLevel || ((_ref = pathUtil.extname(source)) === '.js' || _ref === '.json')) {\n        return compileScript(source);\n      }\n    });\n  };\n\n  hidden = function(file) {\n    return /^\\.|~$/.test(file);\n  };\n\n  compileScript = function(fname) {\n    var code, compiled_code, err;\n    try {\n      if (options.verbose) {\n        console.log(\"#### ---- \" + fname);\n      }\n      code = fsUtil.readFileSync(fname);\n      if ('.json' === pathUtil.extname(fname)) {\n        code = \"(\" + code + \")\";\n      }\n      compiled_code = js2coffee.build(code.toString(), options);\n      return console.log(compiled_code);\n    } catch (_error) {\n      err = _error;\n      console.warn(err instanceof Error && err.stack || (\"ERROR: \" + err + \" while compiling \" + file));\n      if (options.stop_on_error) {\n        return exit(1);\n      }\n    }\n  };\n\n  compileFromStdin = function() {\n    var contents, output;\n    contents = fsUtil.readFileSync(\"/dev/stdin\", encoding);\n    output = js2coffee.build(contents, options);\n    return console.log(output);\n  };\n\n  usage = function() {\n    var arg, long, short;\n    console.warn(BANNER + \"\\n\");\n    console.warn(\"options:\");\n    for (arg in knownOpts) {\n      console.warn(\"--\" + arg + \" # \" + description[arg]);\n    }\n    console.warn(\"\\nshorcuts:\");\n    for (short in shortHands) {\n      long = shortHands[short];\n      if (short === '___singles') {\n        continue;\n      }\n      console.warn(\"-\" + short + \" = \" + (inspect(long)));\n    }\n    return process.exit(0);\n  };\n\n  version = function() {\n    return \"js2coffee version \" + js2coffee.VERSION;\n  };\n\n  exports.run = function() {\n    var s, _i, _len, _results;\n    parseOptions();\n    if (options.help) {\n      return usage();\n    }\n    if (options.version) {\n      return console.log(version());\n    }\n    if (options.verbose) {\n      console.log(\"#### \" + version());\n    }\n    if (sources.length > 0) {\n      _results = [];\n      for (_i = 0, _len = sources.length; _i < _len; _i++) {\n        s = sources[_i];\n        _results.push(compilePath(s));\n      }\n      return _results;\n    } else {\n      if (!tty.isatty(process.stdin)) {\n        return compileFromStdin('/dev/stdin');\n      }\n      return usage();\n    }\n  };\n\n}).call(this);\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/lib/helpers.js.coffee",
      "relativePath": "lib/helpers.js.coffee",
      "basename": "helpers",
      "outBasename": "helpers",
      "extension": "coffee",
      "outExtension": "js",
      "extensions": [
        "js",
        "coffee"
      ],
      "filename": "helpers.js.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/lib",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/lib/helpers.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/lib",
      "outFilename": "helpers.js",
      "relativeOutPath": "lib/helpers.js",
      "relativeDirPath": "lib",
      "relativeOutDirPath": "lib",
      "relativeBase": "lib/helpers",
      "relativeOutBase": "lib/helpers",
      "contentType": "application/octet-stream",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:18.232Z",
      "rtime": "2014-01-20T02:05:25.502Z",
      "wtime": "2014-01-20T02:05:25.704Z",
      "exists": true,
      "encoding": "utf8",
      "source": "## Code snippet helper\n# A helper class to deal with building code.\n\nCoffeeScript = require 'coffee-script'\nCoffeeScript.RESERVED ?= require('coffee-script/lib/coffee-script/lexer.js').RESERVED\n\nclass Code\n  Code.INDENT = \"  \"\n\n  constructor: ->\n    @code = ''\n\n  add: (str) ->\n    @code += str.toString()\n    @\n\n  scope: (str, level=1) ->\n    indent = strRepeat(Code.INDENT, level)\n    @code  = rtrim(@code) + \"\\n\"\n    @code += indent + rtrim(str).replace(/\\n/g, \"\\n#{indent}\") + \"\\n\"\n    @\n\n  toString: ->\n    @code\n\n# ## String helpers\n# These are functions that deal with strings.\n\n# `paren()`\n# Wraps a given string in parentheses.\n# Examples:\n#\n#     paren 'hi'   => \"(hi)\"\n#     paren '(hi)' => \"(hi)\"\n#\nparen = (string) ->\n  str = string.toString()\n  if str.substr(0, 1) == '(' and str.substr(-1, 1) == ')'\n    str\n  else\n    \"(#{str})\"\n\n# `strRepeat()`\n# Repeats a string a certain number of times.\n# Example:\n#\n#     strRepeat('.', 3) => \"...\"\n#\nstrRepeat = (str, times) ->\n  (str for i in [0...times]).join('')\n\n# `trim()` *and friends*\n# String trimming functions.\n\nltrim = (str) ->\n  \"#{str}\".replace(/^\\s*/g, '')\n\nrtrim = (str) ->\n  \"#{str}\".replace(/\\s*$/g, '')\n\nblockTrim = (str) ->\n  \"#{str}\".replace(/^\\s*\\n|\\s*$/g, '')\n\ntrim = (str) ->\n  \"#{str}\".replace(/^\\s*|\\s*$/g, '')\n\nisSingleLine = (str) ->\n  trim(str).indexOf(\"\\n\") == -1\n\n# `unshift()`\n# Removes any unneccesary indentation from a code block string.\nunshift = (str) ->\n  str = \"#{str}\"\n\n  while true\n    m1 = str.match(/^/gm)\n    m2 = str.match(/^ /gm)\n\n    return str  if !m1 or !m2 or m1.length != m2.length\n    str = str.replace(/^ /gm, '')\n\n# `truthy()`\n# Tests if the given node is constantly truthy. Currently only works with\n# `true` and non-zero numbers.\ntruthy = (n) ->\n  n.isA('true') or (n.isA('number') and parseFloat(n.src()) isnt 0.0)\n\n# `strEscape()`\n# Escapes a string.\n# Example:\n#\n#   * `hello \"there\"` turns to `\"hello \\\"there\\\"\"`\n#\nstrEscape = (str) ->\n  if str.indexOf('#{') isnt -1\n    return strEscapeSingleQuotes str # force single quoted, don't use \"#{foo}\"\n  JSON.stringify \"#{str}\"\n\nstrEscapeSingleQuotes = (str) ->\n  dq = JSON.stringify str # double quoted\n  rdq = dq.replace /\\\\\"/g, '\"' # revert escaping double quotes\n  esq = rdq.replace /'/g, \"\\\\\\'\" # esapce single quotes\n  \"'\" + esq.substr(1, esq.length - 2) + \"'\" # relpace first and last\n\n# `p()`\n# Debugging tool. Prints an object to the console.\n# Not actually used, but here for convenience.\np = (str) ->\n  if str.constructor == String\n    console.log JSON.stringify(str)\n  else\n    console.log str\n  ''\n\n# `coffeescript_reserved`\n# Array of reserved words from coffeescript,\n# for use by `unreserve()`\ncoffeescript_reserved = ( word for word in CoffeeScript.RESERVED when word != 'undefined' )\n\n# `unreserve()`\n# Picks the next best thing for a reserved keyword.\n# Example:\n#\n#     \"in\"    => \"in_\"\n#     \"hello\" => \"hello\"\n#     \"off\"   => \"off\"\n#\nunreserve = (str) ->\n  if \"#{str}\" in coffeescript_reserved\n    \"#{str}_\"\n  else\n    \"#{str}\"\n\n# `indentLines()`\n# Indents given `lines` string with spaces string given in `indent`.\nindentLines = (indent, lines) ->\n  indent + lines.replace(/\\n/g, \"\\n\"+indent)\n\n@Js2coffeeHelpers = exports =\n  {Code, p, strEscapeDoubleQuotes: strEscape, strEscapeSingleQuotes, \n  unreserve, unshift, isSingleLine, trim, blockTrim, ltrim, rtrim, strRepeat, \n  paren, truthy, indentLines}\n\nmodule.exports = exports  if module?\n",
      "content": "## Code snippet helper\n# A helper class to deal with building code.\n\nCoffeeScript = require 'coffee-script'\nCoffeeScript.RESERVED ?= require('coffee-script/lib/coffee-script/lexer.js').RESERVED\n\nclass Code\n  Code.INDENT = \"  \"\n\n  constructor: ->\n    @code = ''\n\n  add: (str) ->\n    @code += str.toString()\n    @\n\n  scope: (str, level=1) ->\n    indent = strRepeat(Code.INDENT, level)\n    @code  = rtrim(@code) + \"\\n\"\n    @code += indent + rtrim(str).replace(/\\n/g, \"\\n#{indent}\") + \"\\n\"\n    @\n\n  toString: ->\n    @code\n\n# ## String helpers\n# These are functions that deal with strings.\n\n# `paren()`\n# Wraps a given string in parentheses.\n# Examples:\n#\n#     paren 'hi'   => \"(hi)\"\n#     paren '(hi)' => \"(hi)\"\n#\nparen = (string) ->\n  str = string.toString()\n  if str.substr(0, 1) == '(' and str.substr(-1, 1) == ')'\n    str\n  else\n    \"(#{str})\"\n\n# `strRepeat()`\n# Repeats a string a certain number of times.\n# Example:\n#\n#     strRepeat('.', 3) => \"...\"\n#\nstrRepeat = (str, times) ->\n  (str for i in [0...times]).join('')\n\n# `trim()` *and friends*\n# String trimming functions.\n\nltrim = (str) ->\n  \"#{str}\".replace(/^\\s*/g, '')\n\nrtrim = (str) ->\n  \"#{str}\".replace(/\\s*$/g, '')\n\nblockTrim = (str) ->\n  \"#{str}\".replace(/^\\s*\\n|\\s*$/g, '')\n\ntrim = (str) ->\n  \"#{str}\".replace(/^\\s*|\\s*$/g, '')\n\nisSingleLine = (str) ->\n  trim(str).indexOf(\"\\n\") == -1\n\n# `unshift()`\n# Removes any unneccesary indentation from a code block string.\nunshift = (str) ->\n  str = \"#{str}\"\n\n  while true\n    m1 = str.match(/^/gm)\n    m2 = str.match(/^ /gm)\n\n    return str  if !m1 or !m2 or m1.length != m2.length\n    str = str.replace(/^ /gm, '')\n\n# `truthy()`\n# Tests if the given node is constantly truthy. Currently only works with\n# `true` and non-zero numbers.\ntruthy = (n) ->\n  n.isA('true') or (n.isA('number') and parseFloat(n.src()) isnt 0.0)\n\n# `strEscape()`\n# Escapes a string.\n# Example:\n#\n#   * `hello \"there\"` turns to `\"hello \\\"there\\\"\"`\n#\nstrEscape = (str) ->\n  if str.indexOf('#{') isnt -1\n    return strEscapeSingleQuotes str # force single quoted, don't use \"#{foo}\"\n  JSON.stringify \"#{str}\"\n\nstrEscapeSingleQuotes = (str) ->\n  dq = JSON.stringify str # double quoted\n  rdq = dq.replace /\\\\\"/g, '\"' # revert escaping double quotes\n  esq = rdq.replace /'/g, \"\\\\\\'\" # esapce single quotes\n  \"'\" + esq.substr(1, esq.length - 2) + \"'\" # relpace first and last\n\n# `p()`\n# Debugging tool. Prints an object to the console.\n# Not actually used, but here for convenience.\np = (str) ->\n  if str.constructor == String\n    console.log JSON.stringify(str)\n  else\n    console.log str\n  ''\n\n# `coffeescript_reserved`\n# Array of reserved words from coffeescript,\n# for use by `unreserve()`\ncoffeescript_reserved = ( word for word in CoffeeScript.RESERVED when word != 'undefined' )\n\n# `unreserve()`\n# Picks the next best thing for a reserved keyword.\n# Example:\n#\n#     \"in\"    => \"in_\"\n#     \"hello\" => \"hello\"\n#     \"off\"   => \"off\"\n#\nunreserve = (str) ->\n  if \"#{str}\" in coffeescript_reserved\n    \"#{str}_\"\n  else\n    \"#{str}\"\n\n# `indentLines()`\n# Indents given `lines` string with spaces string given in `indent`.\nindentLines = (indent, lines) ->\n  indent + lines.replace(/\\n/g, \"\\n\"+indent)\n\n@Js2coffeeHelpers = exports =\n  {Code, p, strEscapeDoubleQuotes: strEscape, strEscapeSingleQuotes, \n  unreserve, unshift, isSingleLine, trim, blockTrim, ltrim, rtrim, strRepeat, \n  paren, truthy, indentLines}\n\nmodule.exports = exports  if module?\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "helpers.js",
      "date": "2014-01-20T02:05:18.232Z",
      "slug": "lib-helpers",
      "url": "/lib/helpers.js",
      "urls": [
        "/lib/helpers.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "## Code snippet helper\n# A helper class to deal with building code.\n\nCoffeeScript = require 'coffee-script'\nCoffeeScript.RESERVED ?= require('coffee-script/lib/coffee-script/lexer.js').RESERVED\n\nclass Code\n  Code.INDENT = \"  \"\n\n  constructor: ->\n    @code = ''\n\n  add: (str) ->\n    @code += str.toString()\n    @\n\n  scope: (str, level=1) ->\n    indent = strRepeat(Code.INDENT, level)\n    @code  = rtrim(@code) + \"\\n\"\n    @code += indent + rtrim(str).replace(/\\n/g, \"\\n#{indent}\") + \"\\n\"\n    @\n\n  toString: ->\n    @code\n\n# ## String helpers\n# These are functions that deal with strings.\n\n# `paren()`\n# Wraps a given string in parentheses.\n# Examples:\n#\n#     paren 'hi'   => \"(hi)\"\n#     paren '(hi)' => \"(hi)\"\n#\nparen = (string) ->\n  str = string.toString()\n  if str.substr(0, 1) == '(' and str.substr(-1, 1) == ')'\n    str\n  else\n    \"(#{str})\"\n\n# `strRepeat()`\n# Repeats a string a certain number of times.\n# Example:\n#\n#     strRepeat('.', 3) => \"...\"\n#\nstrRepeat = (str, times) ->\n  (str for i in [0...times]).join('')\n\n# `trim()` *and friends*\n# String trimming functions.\n\nltrim = (str) ->\n  \"#{str}\".replace(/^\\s*/g, '')\n\nrtrim = (str) ->\n  \"#{str}\".replace(/\\s*$/g, '')\n\nblockTrim = (str) ->\n  \"#{str}\".replace(/^\\s*\\n|\\s*$/g, '')\n\ntrim = (str) ->\n  \"#{str}\".replace(/^\\s*|\\s*$/g, '')\n\nisSingleLine = (str) ->\n  trim(str).indexOf(\"\\n\") == -1\n\n# `unshift()`\n# Removes any unneccesary indentation from a code block string.\nunshift = (str) ->\n  str = \"#{str}\"\n\n  while true\n    m1 = str.match(/^/gm)\n    m2 = str.match(/^ /gm)\n\n    return str  if !m1 or !m2 or m1.length != m2.length\n    str = str.replace(/^ /gm, '')\n\n# `truthy()`\n# Tests if the given node is constantly truthy. Currently only works with\n# `true` and non-zero numbers.\ntruthy = (n) ->\n  n.isA('true') or (n.isA('number') and parseFloat(n.src()) isnt 0.0)\n\n# `strEscape()`\n# Escapes a string.\n# Example:\n#\n#   * `hello \"there\"` turns to `\"hello \\\"there\\\"\"`\n#\nstrEscape = (str) ->\n  if str.indexOf('#{') isnt -1\n    return strEscapeSingleQuotes str # force single quoted, don't use \"#{foo}\"\n  JSON.stringify \"#{str}\"\n\nstrEscapeSingleQuotes = (str) ->\n  dq = JSON.stringify str # double quoted\n  rdq = dq.replace /\\\\\"/g, '\"' # revert escaping double quotes\n  esq = rdq.replace /'/g, \"\\\\\\'\" # esapce single quotes\n  \"'\" + esq.substr(1, esq.length - 2) + \"'\" # relpace first and last\n\n# `p()`\n# Debugging tool. Prints an object to the console.\n# Not actually used, but here for convenience.\np = (str) ->\n  if str.constructor == String\n    console.log JSON.stringify(str)\n  else\n    console.log str\n  ''\n\n# `coffeescript_reserved`\n# Array of reserved words from coffeescript,\n# for use by `unreserve()`\ncoffeescript_reserved = ( word for word in CoffeeScript.RESERVED when word != 'undefined' )\n\n# `unreserve()`\n# Picks the next best thing for a reserved keyword.\n# Example:\n#\n#     \"in\"    => \"in_\"\n#     \"hello\" => \"hello\"\n#     \"off\"   => \"off\"\n#\nunreserve = (str) ->\n  if \"#{str}\" in coffeescript_reserved\n    \"#{str}_\"\n  else\n    \"#{str}\"\n\n# `indentLines()`\n# Indents given `lines` string with spaces string given in `indent`.\nindentLines = (indent, lines) ->\n  indent + lines.replace(/\\n/g, \"\\n\"+indent)\n\n@Js2coffeeHelpers = exports =\n  {Code, p, strEscapeDoubleQuotes: strEscape, strEscapeSingleQuotes, \n  unreserve, unshift, isSingleLine, trim, blockTrim, ltrim, rtrim, strRepeat, \n  paren, truthy, indentLines}\n\nmodule.exports = exports  if module?\n",
      "rendered": true,
      "contentRendered": "(function() {\n  var Code, CoffeeScript, blockTrim, coffeescript_reserved, exports, indentLines, isSingleLine, ltrim, p, paren, rtrim, strEscape, strEscapeSingleQuotes, strRepeat, trim, truthy, unreserve, unshift, word,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  CoffeeScript = require('coffee-script');\n\n  if (CoffeeScript.RESERVED == null) {\n    CoffeeScript.RESERVED = require('coffee-script/lib/coffee-script/lexer.js').RESERVED;\n  }\n\n  Code = (function() {\n    Code.INDENT = \"  \";\n\n    function Code() {\n      this.code = '';\n    }\n\n    Code.prototype.add = function(str) {\n      this.code += str.toString();\n      return this;\n    };\n\n    Code.prototype.scope = function(str, level) {\n      var indent;\n      if (level == null) {\n        level = 1;\n      }\n      indent = strRepeat(Code.INDENT, level);\n      this.code = rtrim(this.code) + \"\\n\";\n      this.code += indent + rtrim(str).replace(/\\n/g, \"\\n\" + indent) + \"\\n\";\n      return this;\n    };\n\n    Code.prototype.toString = function() {\n      return this.code;\n    };\n\n    return Code;\n\n  })();\n\n  paren = function(string) {\n    var str;\n    str = string.toString();\n    if (str.substr(0, 1) === '(' && str.substr(-1, 1) === ')') {\n      return str;\n    } else {\n      return \"(\" + str + \")\";\n    }\n  };\n\n  strRepeat = function(str, times) {\n    var i;\n    return ((function() {\n      var _i, _results;\n      _results = [];\n      for (i = _i = 0; 0 <= times ? _i < times : _i > times; i = 0 <= times ? ++_i : --_i) {\n        _results.push(str);\n      }\n      return _results;\n    })()).join('');\n  };\n\n  ltrim = function(str) {\n    return (\"\" + str).replace(/^\\s*/g, '');\n  };\n\n  rtrim = function(str) {\n    return (\"\" + str).replace(/\\s*$/g, '');\n  };\n\n  blockTrim = function(str) {\n    return (\"\" + str).replace(/^\\s*\\n|\\s*$/g, '');\n  };\n\n  trim = function(str) {\n    return (\"\" + str).replace(/^\\s*|\\s*$/g, '');\n  };\n\n  isSingleLine = function(str) {\n    return trim(str).indexOf(\"\\n\") === -1;\n  };\n\n  unshift = function(str) {\n    var m1, m2;\n    str = \"\" + str;\n    while (true) {\n      m1 = str.match(/^/gm);\n      m2 = str.match(/^ /gm);\n      if (!m1 || !m2 || m1.length !== m2.length) {\n        return str;\n      }\n      str = str.replace(/^ /gm, '');\n    }\n  };\n\n  truthy = function(n) {\n    return n.isA('true') || (n.isA('number') && parseFloat(n.src()) !== 0.0);\n  };\n\n  strEscape = function(str) {\n    if (str.indexOf('#{') !== -1) {\n      return strEscapeSingleQuotes(str);\n    }\n    return JSON.stringify(\"\" + str);\n  };\n\n  strEscapeSingleQuotes = function(str) {\n    var dq, esq, rdq;\n    dq = JSON.stringify(str);\n    rdq = dq.replace(/\\\\\"/g, '\"');\n    esq = rdq.replace(/'/g, \"\\\\\\'\");\n    return \"'\" + esq.substr(1, esq.length - 2) + \"'\";\n  };\n\n  p = function(str) {\n    if (str.constructor === String) {\n      console.log(JSON.stringify(str));\n    } else {\n      console.log(str);\n    }\n    return '';\n  };\n\n  coffeescript_reserved = (function() {\n    var _i, _len, _ref, _results;\n    _ref = CoffeeScript.RESERVED;\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      word = _ref[_i];\n      if (word !== 'undefined') {\n        _results.push(word);\n      }\n    }\n    return _results;\n  })();\n\n  unreserve = function(str) {\n    var _ref;\n    if (_ref = \"\" + str, __indexOf.call(coffeescript_reserved, _ref) >= 0) {\n      return \"\" + str + \"_\";\n    } else {\n      return \"\" + str;\n    }\n  };\n\n  indentLines = function(indent, lines) {\n    return indent + lines.replace(/\\n/g, \"\\n\" + indent);\n  };\n\n  this.Js2coffeeHelpers = exports = {\n    Code: Code,\n    p: p,\n    strEscapeDoubleQuotes: strEscape,\n    strEscapeSingleQuotes: strEscapeSingleQuotes,\n    unreserve: unreserve,\n    unshift: unshift,\n    isSingleLine: isSingleLine,\n    trim: trim,\n    blockTrim: blockTrim,\n    ltrim: ltrim,\n    rtrim: rtrim,\n    strRepeat: strRepeat,\n    paren: paren,\n    truthy: truthy,\n    indentLines: indentLines\n  };\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = exports;\n  }\n\n}).call(this);\n",
      "contentRenderedWithoutLayouts": "(function() {\n  var Code, CoffeeScript, blockTrim, coffeescript_reserved, exports, indentLines, isSingleLine, ltrim, p, paren, rtrim, strEscape, strEscapeSingleQuotes, strRepeat, trim, truthy, unreserve, unshift, word,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  CoffeeScript = require('coffee-script');\n\n  if (CoffeeScript.RESERVED == null) {\n    CoffeeScript.RESERVED = require('coffee-script/lib/coffee-script/lexer.js').RESERVED;\n  }\n\n  Code = (function() {\n    Code.INDENT = \"  \";\n\n    function Code() {\n      this.code = '';\n    }\n\n    Code.prototype.add = function(str) {\n      this.code += str.toString();\n      return this;\n    };\n\n    Code.prototype.scope = function(str, level) {\n      var indent;\n      if (level == null) {\n        level = 1;\n      }\n      indent = strRepeat(Code.INDENT, level);\n      this.code = rtrim(this.code) + \"\\n\";\n      this.code += indent + rtrim(str).replace(/\\n/g, \"\\n\" + indent) + \"\\n\";\n      return this;\n    };\n\n    Code.prototype.toString = function() {\n      return this.code;\n    };\n\n    return Code;\n\n  })();\n\n  paren = function(string) {\n    var str;\n    str = string.toString();\n    if (str.substr(0, 1) === '(' && str.substr(-1, 1) === ')') {\n      return str;\n    } else {\n      return \"(\" + str + \")\";\n    }\n  };\n\n  strRepeat = function(str, times) {\n    var i;\n    return ((function() {\n      var _i, _results;\n      _results = [];\n      for (i = _i = 0; 0 <= times ? _i < times : _i > times; i = 0 <= times ? ++_i : --_i) {\n        _results.push(str);\n      }\n      return _results;\n    })()).join('');\n  };\n\n  ltrim = function(str) {\n    return (\"\" + str).replace(/^\\s*/g, '');\n  };\n\n  rtrim = function(str) {\n    return (\"\" + str).replace(/\\s*$/g, '');\n  };\n\n  blockTrim = function(str) {\n    return (\"\" + str).replace(/^\\s*\\n|\\s*$/g, '');\n  };\n\n  trim = function(str) {\n    return (\"\" + str).replace(/^\\s*|\\s*$/g, '');\n  };\n\n  isSingleLine = function(str) {\n    return trim(str).indexOf(\"\\n\") === -1;\n  };\n\n  unshift = function(str) {\n    var m1, m2;\n    str = \"\" + str;\n    while (true) {\n      m1 = str.match(/^/gm);\n      m2 = str.match(/^ /gm);\n      if (!m1 || !m2 || m1.length !== m2.length) {\n        return str;\n      }\n      str = str.replace(/^ /gm, '');\n    }\n  };\n\n  truthy = function(n) {\n    return n.isA('true') || (n.isA('number') && parseFloat(n.src()) !== 0.0);\n  };\n\n  strEscape = function(str) {\n    if (str.indexOf('#{') !== -1) {\n      return strEscapeSingleQuotes(str);\n    }\n    return JSON.stringify(\"\" + str);\n  };\n\n  strEscapeSingleQuotes = function(str) {\n    var dq, esq, rdq;\n    dq = JSON.stringify(str);\n    rdq = dq.replace(/\\\\\"/g, '\"');\n    esq = rdq.replace(/'/g, \"\\\\\\'\");\n    return \"'\" + esq.substr(1, esq.length - 2) + \"'\";\n  };\n\n  p = function(str) {\n    if (str.constructor === String) {\n      console.log(JSON.stringify(str));\n    } else {\n      console.log(str);\n    }\n    return '';\n  };\n\n  coffeescript_reserved = (function() {\n    var _i, _len, _ref, _results;\n    _ref = CoffeeScript.RESERVED;\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      word = _ref[_i];\n      if (word !== 'undefined') {\n        _results.push(word);\n      }\n    }\n    return _results;\n  })();\n\n  unreserve = function(str) {\n    var _ref;\n    if (_ref = \"\" + str, __indexOf.call(coffeescript_reserved, _ref) >= 0) {\n      return \"\" + str + \"_\";\n    } else {\n      return \"\" + str;\n    }\n  };\n\n  indentLines = function(indent, lines) {\n    return indent + lines.replace(/\\n/g, \"\\n\" + indent);\n  };\n\n  this.Js2coffeeHelpers = exports = {\n    Code: Code,\n    p: p,\n    strEscapeDoubleQuotes: strEscape,\n    strEscapeSingleQuotes: strEscapeSingleQuotes,\n    unreserve: unreserve,\n    unshift: unshift,\n    isSingleLine: isSingleLine,\n    trim: trim,\n    blockTrim: blockTrim,\n    ltrim: ltrim,\n    rtrim: rtrim,\n    strRepeat: strRepeat,\n    paren: paren,\n    truthy: truthy,\n    indentLines: indentLines\n  };\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = exports;\n  }\n\n}).call(this);\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/lib/js2coffee.js.coffee",
      "relativePath": "lib/js2coffee.js.coffee",
      "basename": "js2coffee",
      "outBasename": "js2coffee",
      "extension": "coffee",
      "outExtension": "js",
      "extensions": [
        "js",
        "coffee"
      ],
      "filename": "js2coffee.js.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/lib",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/lib/js2coffee.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/lib",
      "outFilename": "js2coffee.js",
      "relativeOutPath": "lib/js2coffee.js",
      "relativeDirPath": "lib",
      "relativeOutDirPath": "lib",
      "relativeBase": "lib/js2coffee",
      "relativeOutBase": "lib/js2coffee",
      "contentType": "application/octet-stream",
      "outContentType": "application/javascript",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:18.250Z",
      "rtime": "2014-01-20T02:05:25.508Z",
      "wtime": "2014-01-20T02:05:25.710Z",
      "exists": true,
      "encoding": "utf8",
      "source": "# The JavaScript to CoffeeScript compiler.\n#\n# Common usage:\n#\n#     var src = \"var square = function(n) { return n * n };\"\n#\n#     js2coffee = require('js2coffee');\n#     js2coffee.build(src);\n#     //=> \"square = (n) -> n * n\"\n\n# ## Requires\n#\n# Js2coffee relies on Narcissus's parser. (Narcissus is Mozilla's JavaScript\n# engine written in JavaScript).\n\n_ = require('underscore')\n#use extension to be compatible with browserify\npkg = require('../../package.json')\n{parser} = require('./narcissus_packed')\n{Types, Typenames, Node} = require('./node_ext')\n{Code, p, strEscapeDoubleQuotes, strEscapeSingleQuotes, unreserve, unshift, isSingleLine, trim, blockTrim, ltrim, rtrim, strRepeat, paren, truthy, indentLines} = require('./helpers')\n\nstrEscape = undefined \n\n# ## Main entry point\n# This is `require('js2coffee').build()`. It takes a JavaScript source\n# string as an argument, and it returns the CoffeeScript version.\n#\n# 1. Ask Narcissus to break it down into Nodes (`parser.parse`). This\n#    returns a `Node` object of type `script`.\n#\n# 2. This node is now passed onto `Builder#build()`.\n\nbuildCoffee = (str, opts = {}) ->\n  str  = str.replace /\\r/g, ''\n  str += \"\\n\"\n\n  if opts.indent?\n    Code.INDENT = opts.indent\n\n  if opts.single_quotes? and opts.single_quotes is true\n    console.log opts.single_quotes\n    strEscape = strEscapeSingleQuotes\n  else\n    strEscape = strEscapeDoubleQuotes\n\n  builder    = new Builder opts\n  scriptNode = parser.parse str\n\n  output = trim builder.build(scriptNode)\n\n  if opts.no_comments\n    (rtrim line for line in output.split('\\n')).join('\\n')\n\n  else\n    keepLineNumbers = opts.show_src_lineno\n\n    res = []\n    for l in output.split(\"\\n\")\n\n      srclines = []\n      text = l.replace /\\uFEFE([0-9]+).*?\\uFEFE/g,(m,g) ->\n          srclines.push parseInt(g)\n          \"\"\n\n      srclines = _.sortBy(_.uniq(srclines), (i) -> i)\n\n      text = rtrim(text)\n      indent = text.match /^\\s*/\n\n      if srclines.length > 0\n        minline = _.last(srclines)\n\n        precomments = builder.commentsNotDoneTo(minline)\n        if precomments\n          res.push indentLines indent,precomments\n\n      if text\n        if keepLineNumbers\n            text = text + \"#\" +srclines.join(\",\") + \"#  \"\n        res.push rtrim(text + \" \"+ltrim(builder.lineComments(srclines)))\n      else\n        res.push \"\"\n\n    comments = builder.commentsNotDoneTo(1e10)\n    if comments\n      res.push comments\n\n    res.join(\"\\n\")\n\n# ## Builder class\n# This is the main class that proccesses the AST and spits out streng.\n# See the `buildCoffee()` function above for info on how this is used.\n\nclass Builder\n  constructor: (@options={}) ->\n    @transformer = new Transformer\n\n  # `l()`\n  # Inject the source line as a hidden element to be stripped out later.\n\n  l: (n) ->\n    # todo: this could be configurable debug helper\n    # console.log n if n.lineno in [1]\n    if @options.no_comments\n      return ''\n    if n and n.lineno\n       # for DEBUG use this: \"\\uFEFE#{n.lineno},#{n.typeName()}\\uFEFE\"\n       \"\\uFEFE#{n.lineno}\\uFEFE\"\n    else\n      \"\"\n\n  makeComment: (comment) ->\n    if comment.type is \"BLOCK_COMMENT\"\n      c = comment.value.split(\"\\n\")\n\n      if c.length>0 and c[0].length>0 and c[0][0]==\"*\" # docstring ?\n        c = ( line.replace(/^[\\s\\*]*/,'') for line in c )\n        c = ( line.replace(/[\\s]*$/,'') for line in c )\n        #remove empty lines\n        while c.length > 0 and c[0].length==0\n          c.shift()\n        while c.length > 0 and c[c.length-1].length==0\n          c.pop()\n        c.unshift('###')\n        c.push('###')\n      else\n        c = (\"##{line}\" for line in c)\n    else\n        c = [ '#'+comment.value]\n\n    if comment.nlcount>0\n      c.unshift ''\n\n    c.join('\\n')\n\n  commentsNotDoneTo: (lineno) ->\n    res = []\n    loop\n      break if @comments.length is 0\n      c = @comments[0]\n\n      if c.lineno < lineno\n        res.push(@makeComment c)\n        @comments.shift()\n        continue\n      break\n\n    res.join(\"\\n\")\n\n  lineComments: (linenos) ->\n    # TODO: is there a nicer way to do this?\n    selection = (c for c in @comments when c.lineno in linenos)\n    @comments = _.difference(@comments, selection)\n    return (@makeComment c for c in selection).join(\"\\n\")\n\n  # `build()`\n  # The main entry point.\n\n  # This finds the appropriate @builder function for `node` based on it's type,\n  # the passes the node onto that function.\n  #\n  # For instance, for a `function` node, it calls `@builders.function(node)`.\n  # It defaults to `@builders.other` if it can't find a function for it.\n\n  build: (args...) ->\n    node = args[0]\n\n    # get comments from tokenizer\n    if not @comments?\n      @comments = _.sortBy node.tokenizer.comments, (n) ->\n        n.start\n\n    @transform node\n\n    name = 'other'\n    name = node.typeName()  if node != undefined and node.typeName\n\n    fn  = (@[name] or @other)\n    out = fn.apply(this, args)\n\n    if node.parenthesized then paren(out) else out\n\n  # `transform()`\n  # Perform a transformation on the node, if a transformation function is\n  # available.\n\n  transform: (args...) ->\n    @transformer.transform.apply(@transformer, args)\n\n  # `body()`\n  # Works like `@build()`, and is used for code blocks. It cleans up the returned\n  # code block by removing any extraneous spaces and such.\n\n  body: (node, opts={}) ->\n    str = @build(node, opts)\n    str = blockTrim(str)\n    str = unshift(str)\n\n    if str.length > 0 then str else \"\"\n\n  # ## The builders\n  #\n  # Each of these method are passed a Node, and is expected to return\n  # a string representation of it CoffeeScript counterpart.\n  #\n  # These are invoked using the main entry point, `Builder#build()`.\n\n  # `script`\n  # This is the main entry point.\n\n  'script': (n, opts={}) ->\n    c = new Code\n\n    # *Functions must always be declared first in a block.*\n    _.each n.functions,    (item) => c.add @build(item)\n    _.each n.nonfunctions, (item) => c.add @build(item)\n\n    c.toString()\n\n\n  # `property_identifier`\n  # A key in an object literal.\n\n  'property_identifier': (n) ->\n    str = n.value.toString()\n\n    # **Caveat:**\n    # *In object literals like `{ '#foo click': b }`, ensure that the key is\n    # quoted if need be.*\n\n    if str.match(/^([_\\$a-z][_\\$a-z0-9]*)$/i) or str.match(/^[0-9]+$/i)\n      @l(n)+str\n    else\n      @l(n)+strEscape str\n\n  # `identifier`\n  # Any object identifier like a variable name.\n\n  'identifier': (n) ->\n    if n.value is 'undefined'\n      @l(n)+'`undefined`'\n    else if n.property_accessor\n      @l(n)+n.value.toString()\n    else\n      @l(n)+unreserve n.value.toString()\n\n  'number': (n) ->\n    @l(n)+\"#{n.src()}\"\n\n  'id': (n) ->\n    if n.property_accessor\n      @l(n)+n\n    else\n      @l(n)+unreserve n\n\n  # `id_param`\n  # Function parameters. Belongs to `list`.\n\n  'id_param': (n) ->\n    if n.toString() in ['undefined']\n      @l(n)+\"#{n}_\"\n    else\n      @l(n)+@id n\n\n  # `return`\n  # A return statement. Has `n.value` of type `id`.\n\n  'return': (n) ->\n    if not n.value?\n      @l(n)+\"return\\n\"\n\n    else\n      @l(n)+\"return #{@build(n.value)}\\n\"\n\n  # `;` (aka, statement)\n  # A single statement.\n\n  ';': (n) ->\n    # **Caveat:**\n    # Some statements can be blank as some people are silly enough to use `;;`\n    # sometimes. They should be ignored.\n\n    unless n.expression?\n      \"\"\n\n    else if n.expression.typeName() == 'object_init'\n\n      src = @object_init(n.expression)\n      if n.parenthesized\n        src\n      else\n        \"#{unshift(blockTrim(src))}\\n\"\n\n    else\n      @build(n.expression) + \"\\n\"\n\n  # `new` + `new_with_args`\n  # For `new X` and `new X(y)` respctively.\n\n  'new': (n) -> @l(n)+\"new #{@build n.left()}\"\n  'new_with_args': (n) -> @l(n)+\"new #{@build n.left()}(#{@build n.right()})\"\n\n  # ### Unary operators\n\n  'unary_plus': (n) -> \"+#{@build n.left()}\"\n  'unary_minus': (n) -> \"-#{@build n.left()}\"\n\n  # ### Keywords\n\n  'this': (n) -> @l(n)+'this'\n  'null': (n) -> @l(n)+'null'\n  'true': (n) -> @l(n)+'true'\n  'false': (n) -> @l(n)+'false'\n  'void': (n) -> @l(n)+'undefined'\n\n  'debugger': (n) -> @l(n)+\"debugger\\n\"\n  'break': (n) -> @l(n)+\"break\\n\"\n  'continue': (n) -> @l(n)+\"continue\\n\"\n\n  # ### Some simple operators\n\n  '~': (n) ->\n    \"~#{@build n.left()}\"\n\n  'typeof': (n) ->\n    @l(n)+\"typeof #{@build n.left()}\"\n\n  'index': (n) ->\n    right = @build n.right()\n    if _.any(n.children, (child) -> child.typeName() == 'object_init' and child.children.length > 1)\n      right = \"{#{right}}\"\n    @l(n)+\"#{@build n.left()}[#{right}]\"\n\n  'throw': (n) ->\n    @l(n)+\"throw #{@build n.exception}\"\n\n  '!': (n) ->\n    target = n.left()\n    negations = 1\n    ++negations while (target.isA '!') and target = target.left()\n    if (negations & 1) and target.isA '==', '!=', '===', '!==', 'in', 'instanceof' # invertible binary operators\n      target.negated = not target.negated\n      return @build target\n    @l(n)+\"#{if negations & 1 then 'not ' else '!!'}#{@build target}\"\n\n  # ### Binary operators\n  # All of these are rerouted to the `binary_operator` @builder.\n\n  # TODO: make a function that generates these functions, invoked like so:\n  #   in: binop 'in', 'of'\n  #   '+': binop '+'\n  #   and so on...\n\n  in: (n) ->    @binary_operator n, 'of'\n  '+': (n) ->   @binary_operator n, '+'\n  '-': (n) ->   @binary_operator n, '-'\n  '*': (n) ->   @binary_operator n, '*'\n  '/': (n) ->   @binary_operator n, '/'\n  '%': (n) ->   @binary_operator n, '%'\n  '>': (n) ->   @binary_operator n, '>'\n  '<': (n) ->   @binary_operator n, '<'\n  '&': (n) ->   @binary_operator n, '&'\n  '|': (n) ->   @binary_operator n, '|'\n  '^': (n) ->   @binary_operator n, '^'\n  '&&': (n) ->  @binary_operator n, 'and'\n  '||': (n) ->  @binary_operator n, 'or'\n  '<<': (n) ->  @binary_operator n, '<<'\n  '<=': (n) ->  @binary_operator n, '<='\n  '>>': (n) ->  @binary_operator n, '>>'\n  '>=': (n) ->  @binary_operator n, '>='\n  '===': (n) -> @binary_operator n, 'is'\n  '!==': (n) -> @binary_operator n, 'isnt'\n  '>>>': (n) ->  @binary_operator n, '>>>'\n  instanceof: (n) -> @binary_operator n, 'instanceof'\n\n  '==': (n) ->\n    # TODO: throw warning\n    @binary_operator n, 'is'\n\n  '!=': (n) ->\n    # TODO: throw warning\n    @binary_operator n, 'isnt'\n\n  'binary_operator': do ->\n    INVERSIONS =\n      is: 'isnt'\n      in: 'not in'\n      of: 'not of'\n      instanceof: 'not instanceof'\n    INVERSIONS[v] = k for own k, v of INVERSIONS\n    (n, sign) ->\n      sign = INVERSIONS[sign] if n.negated\n      @l(n)+\"#{@build n.left()} #{sign} #{@build n.right()}\"\n\n  # ### Increments and decrements\n  # For `a++` and `--b`.\n\n  '--': (n) -> @increment_decrement n, '--'\n  '++': (n) -> @increment_decrement n, '++'\n\n  'increment_decrement': (n, sign) ->\n    if n.postfix\n      @l(n)+\"#{@build n.left()}#{sign}\"\n    else\n      @l(n)+\"#{sign}#{@build n.left()}\"\n\n  # `=` (aka, assignment)\n  # For `a = b` (but not `var a = b`: that's `var`).\n\n  '=': (n) ->\n    sign = if n.assignOp?\n      Types[n.assignOp] + '='\n    else\n      '='\n\n    @l(n)+\"#{@build n.left()} #{sign} #{@build n.right()}\"\n\n  # `,` (aka, comma)\n  # For `a = 1, b = 2'\n\n  ',': (n) ->\n    list = _.map n.children, (item) => @l(item)+@build(item) + \"\\n\"\n    list.join('')\n\n  # `regexp`\n  # Regular expressions.\n\n  'regexp': (n) ->\n    m     = n.value.toString().match(/^\\/(.*)\\/([a-z]?)/)\n    value = m[1]\n    flag  = m[2]\n\n    # **Caveat:**\n    # *If it begins with `=` or a space, the CoffeeScript parser will choke if\n    # it's written as `/=/`. Hence, they are written as `new RegExp('=')`.*\n\n    begins_with = value[0]\n\n    if begins_with in [' ', '=']\n      if flag.length > 0\n        @l(n)+\"RegExp(#{strEscape value}, \\\"#{flag}\\\")\"\n      else\n        @l(n)+\"RegExp(#{strEscape value})\"\n    else\n      @l(n)+\"/#{value}/#{flag}\"\n\n  'string': (n) ->\n    @l(n)+ strEscape n.value\n\n  # `call`\n  # A Function call.\n  # `n.left` is an `id`, and `n.right` is a `list`.\n\n  'call': (n) ->\n    if n.right().children.length == 0\n      \"#{@build n.left()}()\"+@l(n)\n    else\n      \"#{@build n.left()}(#{@build n.right()})\"+@l(n)\n\n  # `call_statement`\n  # A `call` that's on it's own line.\n\n  'call_statement': (n) ->\n    left = @build n.left()\n\n    # **Caveat:**\n    # *When calling in this way: `function () { ... }()`,\n    # ensure that there are parenthesis around the anon function\n    # (eg, `(-> ...)()`).*\n\n    left = paren(left)  if n.left().isA('function')\n\n    if n.right().children.length == 0\n      \"#{left}()\"+@l(n)\n    else\n      \"#{left} #{@build n.right()}\"+@l(n)\n\n  # `list`\n  # A parameter list.\n\n  'list': (n, options = {}) ->\n    list = _.map n.children, (item) =>\n      if n.children.length > 1\n        item.is_list_element = true\n      #return @build item # original\n\n      if options.array is true and n.children.length > 0\n        raw = @[item.typeName()](item)\n        c = new Code @, item\n        c.scope raw\n        c = trim c + Code.INDENT\n        if item.typeName() is 'object_init'\n          c = \"{\\n#{Code.INDENT}#{Code.INDENT}#{c}\\n#{Code.INDENT}}\"\n\n        return c\n      else\n        return @build item\n\n    #return @l(n)+list.join(\", \") # original\n    if options.array is true and n.children.length > 0\n      return @l(n) + \"\\n#{Code.INDENT}#{list.join('\\n'+Code.INDENT)}\"\n    else\n      return @l(n)+list.join(\", \")\n\n  'delete': (n) ->\n    ids = _.map(n.children, (el) => @build(el))\n    ids = ids.join(', ')\n    @l(n)+\"delete #{ids}\\n\"\n\n  # `.` (scope resolution?)\n  # For instances such as `object.value`.\n\n  '.': (n) ->\n    # **Caveat:**\n    # *If called as `this.xxx`, it should use the at sign (`n.xxx`).*\n\n    # **Caveat:**\n    # *If called as `x.prototype`, it should use double colons (`x::`).*\n\n    left  = @build n.left()\n    right_obj = n.right()\n    right_obj.property_accessor = true\n    right = @build right_obj\n\n    if n.isThis and n.isPrototype\n      @l(n)+\"@::\"\n    else if n.isThis\n      @l(n)+\"@#{right}\"\n    else if n.isPrototype\n      @l(n)+\"#{left}::\"\n    else if n.left().isPrototype\n      @l(n)+\"#{left}#{right}\"\n    else\n      @l(n)+\"#{left}.#{right}\"\n\n  'try': (n) ->\n    c = new Code\n    c.add 'try'\n    c.scope @body(n.tryBlock)\n\n    _.each n.catchClauses, (clause) =>\n      c.add @build(clause)\n\n    if n.finallyBlock?\n      c.add \"finally\"\n      c.scope @body(n.finallyBlock)\n\n    @l(n)+c\n\n  'catch': (n) ->\n    body_ = @body(n.block)\n    return '' if trim(body_).length == 0\n\n    c = new Code\n\n    if n.varName?\n      c.add \"catch #{n.varName}\"\n    else\n      c.add 'catch'\n\n    c.scope @body(n.block)\n    @l(n)+c\n\n  # `?` (ternary operator)\n  # For `a ? b : c`. Note that these will always be parenthesized, as (I\n  # believe) the order of operations in JS is different in CS.\n\n  '?': (n) ->\n    @l(n)+\"(if #{@build n.left()} then #{@build n.children[1]} else #{@build n.children[2]})\"\n\n  'for': (n) ->\n    c = new Code\n\n    if n.setup?\n      c.add \"#{@build n.setup}\\n\"\n\n    if n.condition?\n      c.add \"while #{@build n.condition}\\n\"\n    else\n      c.add \"loop\"\n\n    c.scope @body(n.body)\n    c.scope @body(n.update)  if n.update?\n    @l(n)+c\n\n  'for_in': (n) ->\n    c = new Code\n\n    c.add \"for #{@build n.iterator} of #{@build n.object}\"\n    #c.scope @body(n.body)\n    if n.body.children.length > 0\n      c.scope @body(n.body)\n    else\n      c.scope \"continue\"\n    @l(n)+c\n\n  'while': (n) ->\n    c = new Code\n\n    keyword   = if n.positive then \"while\" else \"until\"\n    body_     = @body(n.body)\n\n    # *Use `loop` whin something will go on forever (like `while (true)`).*\n    if truthy(n.condition)\n      statement = \"loop\"\n    else\n      statement = \"#{keyword} #{@build n.condition}\"\n\n    if isSingleLine(body_) and statement isnt \"loop\"\n      c.add \"#{trim body_}#{Code.INDENT}#{statement}\\n\"\n    else\n      c.add statement\n      c.scope body_\n    @l(n)+c\n\n  'do': (n) ->\n    c = new Code\n\n    c.add \"loop\"\n    c.scope @body(n.body)\n    c.scope \"break unless #{@build n.condition}\"  if n.condition?\n\n    @l(n)+c\n\n  'if': (n) ->\n    c = new Code\n\n    keyword = if n.positive then \"if\" else \"unless\"\n    body_   = @body(n.thenPart)\n    n.condition.parenthesized = false\n\n    # *Account for `if (xyz) {}`, which should be `xyz`. (#78)*\n    # *Note that `!xyz` still compiles to `xyz` because the `!` will not change anything.*\n    if n.thenPart.isA('block') and n.thenPart.children.length == 0 and !n.elsePart?\n      console.log n.thenPart\n      c.add \"#{@build n.condition}\\n\"\n\n    else if isSingleLine(body_) and !n.elsePart?\n      c.add \"#{trim body_}#{Code.INDENT}#{keyword} #{@build n.condition}\\n\"\n\n    else\n      c.add \"#{keyword} #{@build n.condition}\"\n      c.scope @body(n.thenPart)\n\n      if n.elsePart?\n        if n.elsePart.typeName() == 'if'\n          c.add \"else #{@build(n.elsePart).toString()}\"\n        else\n          c.add @l(n.elsePart)+\"else\\n\"\n          c.scope @body(n.elsePart)\n\n    @l(n)+c\n\n  'switch': (n) ->\n    c = new Code\n\n    c.add \"switch #{@build n.discriminant}\\n\"\n\n    fall_through = false\n    _.each n.cases, (item) =>\n      if item.value == 'default'\n        c.scope @l(item)+\"else\"\n      else\n        if fall_through == true\n          c.add @l(item)+\", #{@build item.caseLabel}\\n\"\n        else\n          c.add @l(item)+\"  when #{@build item.caseLabel}\"\n\n      if @body(item.statements).length == 0\n        fall_through = true\n      else\n        fall_through = false\n        c.add \"\\n\"\n        c.scope @body(item.statements), 2\n\n      first = false\n\n    @l(n)+c\n\n  'existence_check': (n) ->\n    @l(n)+\"#{@build n.left()}?\"\n\n  'array_init': (n) ->\n    options = {array:true}\n    if n.children.length == 0\n      @l(n)+\"[]\"\n    else if n.children.length > 1\n      @l(n)+\"[#{@list n, options}\\n]\"\n    else\n      @l(n)+\"[#{@list n}]\"\n\n  # `property_init`\n  # Belongs to `object_init`;\n  # left is a `identifier`, right can be anything.\n\n  'property_init': (n) ->\n    left = n.left()\n    right = n.right()\n    right.is_property_value = true\n    \"#{@property_identifier left}: #{@build right}\"\n\n  # `object_init`\n  # An object initializer.\n  # Has many `property_init`.\n\n  'object_init': (n, options={}) ->\n    if n.children.length == 0\n      @l(n)+\"{}\"\n\n    else if n.children.length == 1 and not (n.is_property_value or n.is_list_element)\n      @build n.children[0]\n\n    else\n      list = _.map n.children, (item) => @build item\n\n      c = new Code @, n\n      c.scope list.join(\"\\n\")\n      c = \"{#{c}}\"  if options.brackets?\n      c\n\n  # `function`\n  # A function. Can be an anonymous function (`function () { .. }`), or a named\n  # function (`function name() { .. }`).\n\n  'function': (n) ->\n    c = new Code\n\n    params = _.map n.params, (str) =>\n      if str.constructor == String\n        @id_param str\n      else\n        @build str\n\n    if n.name\n      c.add \"#{n.name} = \"\n\n    if n.params.length > 0\n      c.add \"(#{params.join ', '}) ->\"\n    else\n      c.add \"->\"\n\n    body = @body(n.body)\n    if trim(body).length > 0\n      c.scope body\n    else\n      c.add \"\\n\"\n\n    @l(n)+c\n\n  'var': (n) ->\n    list = _.map n.children, (item) =>\n      \"#{unreserve item.value} = #{if item.initializer? then @build(item.initializer) else 'undefined'}\"\n\n    @l(n)+_.compact(list).join(\"\\n\") + \"\\n\"\n\n  # ### Unsupported things\n  #\n  # Due to CoffeeScript limitations, the following things are not supported:\n  #\n  #  * New getter/setter syntax (`x.prototype = { get name() { ... } };`)\n  #  * Break labels (`my_label: ...`)\n  #  * Constants\n\n  'other': (n) ->   @unsupported n, \"#{n.typeName()} is not supported yet\"\n  'getter': (n) ->  @unsupported n, \"getter syntax is not supported; use __defineGetter__\"\n  'setter': (n) ->  @unsupported n, \"setter syntax is not supported; use __defineSetter__\"\n  'label': (n) ->   @unsupported n, \"labels are not supported by CoffeeScript\"\n  'const': (n) ->   @unsupported n, \"consts are not supported by CoffeeScript\"\n\n  'block': (args...) ->\n    @script.apply @, args\n\n  # `unsupported()`\n  # Throws an unsupported error.\n  'unsupported': (node, message) ->\n    throw new UnsupportedError(\"Unsupported: #{message}\", node)\n\n# ## AST manipulation\n# Manipulation of the abstract syntax tree happens here. All these are done on\n# the `build()` step, done just before a node is passed onto `Builders`.\n\nclass Transformer\n  transform: (args...) ->\n    node = args[0]\n    return  if node.transformed?\n    type = node.typeName()\n    fn = @[type]\n\n    if fn\n      fn.apply(this, args)\n      node.transformed = true\n\n  'script': (n) ->\n    n.functions    = []\n    n.nonfunctions = []\n\n    _.each n.children, (item) =>\n      if item.isA('function')\n        n.functions.push item\n      else\n        n.nonfunctions.push item\n\n    last = null\n\n    # *Statements don't need parens, unless they are consecutive object\n    # literals.*\n    _.each n.nonfunctions, (item) =>\n      if item.expression?\n        expr = item.expression\n        if last?.isA('object_init') and expr.isA('object_init')\n          item.parenthesized = true\n        else\n          item.parenthesized = false\n\n        last = expr\n\n  '.': (n) ->\n    if n.left().isA('function')\n      n.left().parenthesized = true\n\n    n.isThis      = n.left().isA('this')\n    n.isPrototype = (n.right().isA('identifier') and n.right().value == 'prototype')\n\n  ';': (n) ->\n    if n.expression?\n      # *Statements don't need parens.*\n      n.expression.parenthesized = false\n\n      # *If the statement only has one function call (eg, `alert(2);`), the\n      # parentheses should be omitted (eg, `alert 2`).*\n      if n.expression.isA('call')\n        n.expression.type = Typenames['call_statement']\n        @call_statement n\n\n  'function': (n) ->\n\n    nonreturns = 0\n    transform_switch = @switch  # we may need this in the walk block below\n\n    # *Unwrap the `return`s.*\n    n.body.walk last: true, (parent, node, list) ->\n\n      # if the last node is a break, we want the one before that\n      transform_switch node if node.isA('switch')\n\n      # Hax\n      lastNode = if list\n        parent[list]\n      else\n        parent.children[parent.children.length-1]\n\n      if node.value and lastNode\n        if node.isA('return')\n          lastNode.type = Typenames[';']\n          lastNode.expression = lastNode.value\n        else if lastNode.isA('if', 'switch', 'block')\n          #console.log \"disregarding nonreturn: #{node.value} and #{lastNode.typeName()}:#{lastNode.value}\"\n        else\n          #console.log \"nonreturn: #{node.value} and #{lastNode.typeName()}:#{lastNode.value}\"\n          nonreturns += 1\n\n    # *Add formerly implicit `return`s*\n    if nonreturns > 0\n      n.body.children.push\n        type: 'return'\n        typeName: -> @type\n        isA: (t) -> t == @type\n\n  'switch': (n) ->\n    _.each n.cases, (item) =>\n      block = item.statements\n      ch    = block.children\n\n      # *CoffeeScript does not need `break` statements on `switch` blocks.*\n      delete ch[ch.length-1] if block.last()?.isA('break')\n\n  'call_statement': (n) ->\n    if n.children[1]\n      _.each n.children[1].children, (child, i) ->\n        if child.isA('function') and i != n.children[1].children.length-1\n          child.parenthesized = true\n\n  'return': (n) ->\n    # *Doing \"return {x:2, y:3}\" should parenthesize the return value.*\n    if n.value and n.value.isA('object_init') and n.value.children.length > 1\n      n.value.parenthesized = true\n\n  'block': (n) ->\n    @script n\n\n  'if': (n) ->\n    # *Account for `if(x) {} else { something }` which should be `something unless x`.*\n    if n.thenPart.isA('block') and n.thenPart.children.length == 0 and (!n.elsePartisA('block') or n.elsePart?.children.length > 0)\n      n.positive = false\n      n.thenPart = n.elsePart\n      delete n.elsePart\n\n    @inversible n\n\n  'while': (n) ->\n    # *A while with a blank body (`while(x){}`) should be accounted for.*\n    # *You can't have empty blocks, so put a `continue` in there. (#78)*\n    if n.body.children.length is 0\n      n.body.children.push n.clone(type: Typenames['continue'], value: 'continue', children: [])\n\n    @inversible n\n\n  'inversible': (n) ->\n    @transform n.condition\n    positive = if n.positive? then n.positive else true\n\n    # *Invert a '!='. (`if (x != y)` => `unless x is y`)*\n    if n.condition.isA('!=')\n      n.condition.type = Typenames['==']\n      n.positive = not positive\n\n    # *Invert a '!'. (`if (!x)` => `unless x`)*\n    else if n.condition.isA('!')\n      n.condition = n.condition.left()\n      n.positive = not positive\n\n    else\n      n.positive = positive\n\n  '==': (n) ->\n    if n.right().isA('null', 'void')\n      n.type     = Typenames['!']\n      n.children = [n.clone(type: Typenames['existence_check'], children: [n.left()])]\n\n  '!=': (n) ->\n    if n.right().isA('null', 'void')\n      n.type     = Typenames['existence_check']\n      n.children = [n.left()]\n\nclass UnsupportedError\n  constructor: (str, src) ->\n    @message = str\n    @cursor  = src.start\n    @line    = src.lineno\n    @source  = src.tokenizer.source\n\n  toString: -> @message\n\n# ## Exports\n\n@Js2coffee = exports =\n  VERSION: pkg.version\n  build: buildCoffee\n  UnsupportedError: UnsupportedError\n\nmodule.exports = exports  if module?\n",
      "content": "# The JavaScript to CoffeeScript compiler.\n#\n# Common usage:\n#\n#     var src = \"var square = function(n) { return n * n };\"\n#\n#     js2coffee = require('js2coffee');\n#     js2coffee.build(src);\n#     //=> \"square = (n) -> n * n\"\n\n# ## Requires\n#\n# Js2coffee relies on Narcissus's parser. (Narcissus is Mozilla's JavaScript\n# engine written in JavaScript).\n\n_ = require('underscore')\n#use extension to be compatible with browserify\npkg = require('../../package.json')\n{parser} = require('./narcissus_packed')\n{Types, Typenames, Node} = require('./node_ext')\n{Code, p, strEscapeDoubleQuotes, strEscapeSingleQuotes, unreserve, unshift, isSingleLine, trim, blockTrim, ltrim, rtrim, strRepeat, paren, truthy, indentLines} = require('./helpers')\n\nstrEscape = undefined \n\n# ## Main entry point\n# This is `require('js2coffee').build()`. It takes a JavaScript source\n# string as an argument, and it returns the CoffeeScript version.\n#\n# 1. Ask Narcissus to break it down into Nodes (`parser.parse`). This\n#    returns a `Node` object of type `script`.\n#\n# 2. This node is now passed onto `Builder#build()`.\n\nbuildCoffee = (str, opts = {}) ->\n  str  = str.replace /\\r/g, ''\n  str += \"\\n\"\n\n  if opts.indent?\n    Code.INDENT = opts.indent\n\n  if opts.single_quotes? and opts.single_quotes is true\n    console.log opts.single_quotes\n    strEscape = strEscapeSingleQuotes\n  else\n    strEscape = strEscapeDoubleQuotes\n\n  builder    = new Builder opts\n  scriptNode = parser.parse str\n\n  output = trim builder.build(scriptNode)\n\n  if opts.no_comments\n    (rtrim line for line in output.split('\\n')).join('\\n')\n\n  else\n    keepLineNumbers = opts.show_src_lineno\n\n    res = []\n    for l in output.split(\"\\n\")\n\n      srclines = []\n      text = l.replace /\\uFEFE([0-9]+).*?\\uFEFE/g,(m,g) ->\n          srclines.push parseInt(g)\n          \"\"\n\n      srclines = _.sortBy(_.uniq(srclines), (i) -> i)\n\n      text = rtrim(text)\n      indent = text.match /^\\s*/\n\n      if srclines.length > 0\n        minline = _.last(srclines)\n\n        precomments = builder.commentsNotDoneTo(minline)\n        if precomments\n          res.push indentLines indent,precomments\n\n      if text\n        if keepLineNumbers\n            text = text + \"#\" +srclines.join(\",\") + \"#  \"\n        res.push rtrim(text + \" \"+ltrim(builder.lineComments(srclines)))\n      else\n        res.push \"\"\n\n    comments = builder.commentsNotDoneTo(1e10)\n    if comments\n      res.push comments\n\n    res.join(\"\\n\")\n\n# ## Builder class\n# This is the main class that proccesses the AST and spits out streng.\n# See the `buildCoffee()` function above for info on how this is used.\n\nclass Builder\n  constructor: (@options={}) ->\n    @transformer = new Transformer\n\n  # `l()`\n  # Inject the source line as a hidden element to be stripped out later.\n\n  l: (n) ->\n    # todo: this could be configurable debug helper\n    # console.log n if n.lineno in [1]\n    if @options.no_comments\n      return ''\n    if n and n.lineno\n       # for DEBUG use this: \"\\uFEFE#{n.lineno},#{n.typeName()}\\uFEFE\"\n       \"\\uFEFE#{n.lineno}\\uFEFE\"\n    else\n      \"\"\n\n  makeComment: (comment) ->\n    if comment.type is \"BLOCK_COMMENT\"\n      c = comment.value.split(\"\\n\")\n\n      if c.length>0 and c[0].length>0 and c[0][0]==\"*\" # docstring ?\n        c = ( line.replace(/^[\\s\\*]*/,'') for line in c )\n        c = ( line.replace(/[\\s]*$/,'') for line in c )\n        #remove empty lines\n        while c.length > 0 and c[0].length==0\n          c.shift()\n        while c.length > 0 and c[c.length-1].length==0\n          c.pop()\n        c.unshift('###')\n        c.push('###')\n      else\n        c = (\"##{line}\" for line in c)\n    else\n        c = [ '#'+comment.value]\n\n    if comment.nlcount>0\n      c.unshift ''\n\n    c.join('\\n')\n\n  commentsNotDoneTo: (lineno) ->\n    res = []\n    loop\n      break if @comments.length is 0\n      c = @comments[0]\n\n      if c.lineno < lineno\n        res.push(@makeComment c)\n        @comments.shift()\n        continue\n      break\n\n    res.join(\"\\n\")\n\n  lineComments: (linenos) ->\n    # TODO: is there a nicer way to do this?\n    selection = (c for c in @comments when c.lineno in linenos)\n    @comments = _.difference(@comments, selection)\n    return (@makeComment c for c in selection).join(\"\\n\")\n\n  # `build()`\n  # The main entry point.\n\n  # This finds the appropriate @builder function for `node` based on it's type,\n  # the passes the node onto that function.\n  #\n  # For instance, for a `function` node, it calls `@builders.function(node)`.\n  # It defaults to `@builders.other` if it can't find a function for it.\n\n  build: (args...) ->\n    node = args[0]\n\n    # get comments from tokenizer\n    if not @comments?\n      @comments = _.sortBy node.tokenizer.comments, (n) ->\n        n.start\n\n    @transform node\n\n    name = 'other'\n    name = node.typeName()  if node != undefined and node.typeName\n\n    fn  = (@[name] or @other)\n    out = fn.apply(this, args)\n\n    if node.parenthesized then paren(out) else out\n\n  # `transform()`\n  # Perform a transformation on the node, if a transformation function is\n  # available.\n\n  transform: (args...) ->\n    @transformer.transform.apply(@transformer, args)\n\n  # `body()`\n  # Works like `@build()`, and is used for code blocks. It cleans up the returned\n  # code block by removing any extraneous spaces and such.\n\n  body: (node, opts={}) ->\n    str = @build(node, opts)\n    str = blockTrim(str)\n    str = unshift(str)\n\n    if str.length > 0 then str else \"\"\n\n  # ## The builders\n  #\n  # Each of these method are passed a Node, and is expected to return\n  # a string representation of it CoffeeScript counterpart.\n  #\n  # These are invoked using the main entry point, `Builder#build()`.\n\n  # `script`\n  # This is the main entry point.\n\n  'script': (n, opts={}) ->\n    c = new Code\n\n    # *Functions must always be declared first in a block.*\n    _.each n.functions,    (item) => c.add @build(item)\n    _.each n.nonfunctions, (item) => c.add @build(item)\n\n    c.toString()\n\n\n  # `property_identifier`\n  # A key in an object literal.\n\n  'property_identifier': (n) ->\n    str = n.value.toString()\n\n    # **Caveat:**\n    # *In object literals like `{ '#foo click': b }`, ensure that the key is\n    # quoted if need be.*\n\n    if str.match(/^([_\\$a-z][_\\$a-z0-9]*)$/i) or str.match(/^[0-9]+$/i)\n      @l(n)+str\n    else\n      @l(n)+strEscape str\n\n  # `identifier`\n  # Any object identifier like a variable name.\n\n  'identifier': (n) ->\n    if n.value is 'undefined'\n      @l(n)+'`undefined`'\n    else if n.property_accessor\n      @l(n)+n.value.toString()\n    else\n      @l(n)+unreserve n.value.toString()\n\n  'number': (n) ->\n    @l(n)+\"#{n.src()}\"\n\n  'id': (n) ->\n    if n.property_accessor\n      @l(n)+n\n    else\n      @l(n)+unreserve n\n\n  # `id_param`\n  # Function parameters. Belongs to `list`.\n\n  'id_param': (n) ->\n    if n.toString() in ['undefined']\n      @l(n)+\"#{n}_\"\n    else\n      @l(n)+@id n\n\n  # `return`\n  # A return statement. Has `n.value` of type `id`.\n\n  'return': (n) ->\n    if not n.value?\n      @l(n)+\"return\\n\"\n\n    else\n      @l(n)+\"return #{@build(n.value)}\\n\"\n\n  # `;` (aka, statement)\n  # A single statement.\n\n  ';': (n) ->\n    # **Caveat:**\n    # Some statements can be blank as some people are silly enough to use `;;`\n    # sometimes. They should be ignored.\n\n    unless n.expression?\n      \"\"\n\n    else if n.expression.typeName() == 'object_init'\n\n      src = @object_init(n.expression)\n      if n.parenthesized\n        src\n      else\n        \"#{unshift(blockTrim(src))}\\n\"\n\n    else\n      @build(n.expression) + \"\\n\"\n\n  # `new` + `new_with_args`\n  # For `new X` and `new X(y)` respctively.\n\n  'new': (n) -> @l(n)+\"new #{@build n.left()}\"\n  'new_with_args': (n) -> @l(n)+\"new #{@build n.left()}(#{@build n.right()})\"\n\n  # ### Unary operators\n\n  'unary_plus': (n) -> \"+#{@build n.left()}\"\n  'unary_minus': (n) -> \"-#{@build n.left()}\"\n\n  # ### Keywords\n\n  'this': (n) -> @l(n)+'this'\n  'null': (n) -> @l(n)+'null'\n  'true': (n) -> @l(n)+'true'\n  'false': (n) -> @l(n)+'false'\n  'void': (n) -> @l(n)+'undefined'\n\n  'debugger': (n) -> @l(n)+\"debugger\\n\"\n  'break': (n) -> @l(n)+\"break\\n\"\n  'continue': (n) -> @l(n)+\"continue\\n\"\n\n  # ### Some simple operators\n\n  '~': (n) ->\n    \"~#{@build n.left()}\"\n\n  'typeof': (n) ->\n    @l(n)+\"typeof #{@build n.left()}\"\n\n  'index': (n) ->\n    right = @build n.right()\n    if _.any(n.children, (child) -> child.typeName() == 'object_init' and child.children.length > 1)\n      right = \"{#{right}}\"\n    @l(n)+\"#{@build n.left()}[#{right}]\"\n\n  'throw': (n) ->\n    @l(n)+\"throw #{@build n.exception}\"\n\n  '!': (n) ->\n    target = n.left()\n    negations = 1\n    ++negations while (target.isA '!') and target = target.left()\n    if (negations & 1) and target.isA '==', '!=', '===', '!==', 'in', 'instanceof' # invertible binary operators\n      target.negated = not target.negated\n      return @build target\n    @l(n)+\"#{if negations & 1 then 'not ' else '!!'}#{@build target}\"\n\n  # ### Binary operators\n  # All of these are rerouted to the `binary_operator` @builder.\n\n  # TODO: make a function that generates these functions, invoked like so:\n  #   in: binop 'in', 'of'\n  #   '+': binop '+'\n  #   and so on...\n\n  in: (n) ->    @binary_operator n, 'of'\n  '+': (n) ->   @binary_operator n, '+'\n  '-': (n) ->   @binary_operator n, '-'\n  '*': (n) ->   @binary_operator n, '*'\n  '/': (n) ->   @binary_operator n, '/'\n  '%': (n) ->   @binary_operator n, '%'\n  '>': (n) ->   @binary_operator n, '>'\n  '<': (n) ->   @binary_operator n, '<'\n  '&': (n) ->   @binary_operator n, '&'\n  '|': (n) ->   @binary_operator n, '|'\n  '^': (n) ->   @binary_operator n, '^'\n  '&&': (n) ->  @binary_operator n, 'and'\n  '||': (n) ->  @binary_operator n, 'or'\n  '<<': (n) ->  @binary_operator n, '<<'\n  '<=': (n) ->  @binary_operator n, '<='\n  '>>': (n) ->  @binary_operator n, '>>'\n  '>=': (n) ->  @binary_operator n, '>='\n  '===': (n) -> @binary_operator n, 'is'\n  '!==': (n) -> @binary_operator n, 'isnt'\n  '>>>': (n) ->  @binary_operator n, '>>>'\n  instanceof: (n) -> @binary_operator n, 'instanceof'\n\n  '==': (n) ->\n    # TODO: throw warning\n    @binary_operator n, 'is'\n\n  '!=': (n) ->\n    # TODO: throw warning\n    @binary_operator n, 'isnt'\n\n  'binary_operator': do ->\n    INVERSIONS =\n      is: 'isnt'\n      in: 'not in'\n      of: 'not of'\n      instanceof: 'not instanceof'\n    INVERSIONS[v] = k for own k, v of INVERSIONS\n    (n, sign) ->\n      sign = INVERSIONS[sign] if n.negated\n      @l(n)+\"#{@build n.left()} #{sign} #{@build n.right()}\"\n\n  # ### Increments and decrements\n  # For `a++` and `--b`.\n\n  '--': (n) -> @increment_decrement n, '--'\n  '++': (n) -> @increment_decrement n, '++'\n\n  'increment_decrement': (n, sign) ->\n    if n.postfix\n      @l(n)+\"#{@build n.left()}#{sign}\"\n    else\n      @l(n)+\"#{sign}#{@build n.left()}\"\n\n  # `=` (aka, assignment)\n  # For `a = b` (but not `var a = b`: that's `var`).\n\n  '=': (n) ->\n    sign = if n.assignOp?\n      Types[n.assignOp] + '='\n    else\n      '='\n\n    @l(n)+\"#{@build n.left()} #{sign} #{@build n.right()}\"\n\n  # `,` (aka, comma)\n  # For `a = 1, b = 2'\n\n  ',': (n) ->\n    list = _.map n.children, (item) => @l(item)+@build(item) + \"\\n\"\n    list.join('')\n\n  # `regexp`\n  # Regular expressions.\n\n  'regexp': (n) ->\n    m     = n.value.toString().match(/^\\/(.*)\\/([a-z]?)/)\n    value = m[1]\n    flag  = m[2]\n\n    # **Caveat:**\n    # *If it begins with `=` or a space, the CoffeeScript parser will choke if\n    # it's written as `/=/`. Hence, they are written as `new RegExp('=')`.*\n\n    begins_with = value[0]\n\n    if begins_with in [' ', '=']\n      if flag.length > 0\n        @l(n)+\"RegExp(#{strEscape value}, \\\"#{flag}\\\")\"\n      else\n        @l(n)+\"RegExp(#{strEscape value})\"\n    else\n      @l(n)+\"/#{value}/#{flag}\"\n\n  'string': (n) ->\n    @l(n)+ strEscape n.value\n\n  # `call`\n  # A Function call.\n  # `n.left` is an `id`, and `n.right` is a `list`.\n\n  'call': (n) ->\n    if n.right().children.length == 0\n      \"#{@build n.left()}()\"+@l(n)\n    else\n      \"#{@build n.left()}(#{@build n.right()})\"+@l(n)\n\n  # `call_statement`\n  # A `call` that's on it's own line.\n\n  'call_statement': (n) ->\n    left = @build n.left()\n\n    # **Caveat:**\n    # *When calling in this way: `function () { ... }()`,\n    # ensure that there are parenthesis around the anon function\n    # (eg, `(-> ...)()`).*\n\n    left = paren(left)  if n.left().isA('function')\n\n    if n.right().children.length == 0\n      \"#{left}()\"+@l(n)\n    else\n      \"#{left} #{@build n.right()}\"+@l(n)\n\n  # `list`\n  # A parameter list.\n\n  'list': (n, options = {}) ->\n    list = _.map n.children, (item) =>\n      if n.children.length > 1\n        item.is_list_element = true\n      #return @build item # original\n\n      if options.array is true and n.children.length > 0\n        raw = @[item.typeName()](item)\n        c = new Code @, item\n        c.scope raw\n        c = trim c + Code.INDENT\n        if item.typeName() is 'object_init'\n          c = \"{\\n#{Code.INDENT}#{Code.INDENT}#{c}\\n#{Code.INDENT}}\"\n\n        return c\n      else\n        return @build item\n\n    #return @l(n)+list.join(\", \") # original\n    if options.array is true and n.children.length > 0\n      return @l(n) + \"\\n#{Code.INDENT}#{list.join('\\n'+Code.INDENT)}\"\n    else\n      return @l(n)+list.join(\", \")\n\n  'delete': (n) ->\n    ids = _.map(n.children, (el) => @build(el))\n    ids = ids.join(', ')\n    @l(n)+\"delete #{ids}\\n\"\n\n  # `.` (scope resolution?)\n  # For instances such as `object.value`.\n\n  '.': (n) ->\n    # **Caveat:**\n    # *If called as `this.xxx`, it should use the at sign (`n.xxx`).*\n\n    # **Caveat:**\n    # *If called as `x.prototype`, it should use double colons (`x::`).*\n\n    left  = @build n.left()\n    right_obj = n.right()\n    right_obj.property_accessor = true\n    right = @build right_obj\n\n    if n.isThis and n.isPrototype\n      @l(n)+\"@::\"\n    else if n.isThis\n      @l(n)+\"@#{right}\"\n    else if n.isPrototype\n      @l(n)+\"#{left}::\"\n    else if n.left().isPrototype\n      @l(n)+\"#{left}#{right}\"\n    else\n      @l(n)+\"#{left}.#{right}\"\n\n  'try': (n) ->\n    c = new Code\n    c.add 'try'\n    c.scope @body(n.tryBlock)\n\n    _.each n.catchClauses, (clause) =>\n      c.add @build(clause)\n\n    if n.finallyBlock?\n      c.add \"finally\"\n      c.scope @body(n.finallyBlock)\n\n    @l(n)+c\n\n  'catch': (n) ->\n    body_ = @body(n.block)\n    return '' if trim(body_).length == 0\n\n    c = new Code\n\n    if n.varName?\n      c.add \"catch #{n.varName}\"\n    else\n      c.add 'catch'\n\n    c.scope @body(n.block)\n    @l(n)+c\n\n  # `?` (ternary operator)\n  # For `a ? b : c`. Note that these will always be parenthesized, as (I\n  # believe) the order of operations in JS is different in CS.\n\n  '?': (n) ->\n    @l(n)+\"(if #{@build n.left()} then #{@build n.children[1]} else #{@build n.children[2]})\"\n\n  'for': (n) ->\n    c = new Code\n\n    if n.setup?\n      c.add \"#{@build n.setup}\\n\"\n\n    if n.condition?\n      c.add \"while #{@build n.condition}\\n\"\n    else\n      c.add \"loop\"\n\n    c.scope @body(n.body)\n    c.scope @body(n.update)  if n.update?\n    @l(n)+c\n\n  'for_in': (n) ->\n    c = new Code\n\n    c.add \"for #{@build n.iterator} of #{@build n.object}\"\n    #c.scope @body(n.body)\n    if n.body.children.length > 0\n      c.scope @body(n.body)\n    else\n      c.scope \"continue\"\n    @l(n)+c\n\n  'while': (n) ->\n    c = new Code\n\n    keyword   = if n.positive then \"while\" else \"until\"\n    body_     = @body(n.body)\n\n    # *Use `loop` whin something will go on forever (like `while (true)`).*\n    if truthy(n.condition)\n      statement = \"loop\"\n    else\n      statement = \"#{keyword} #{@build n.condition}\"\n\n    if isSingleLine(body_) and statement isnt \"loop\"\n      c.add \"#{trim body_}#{Code.INDENT}#{statement}\\n\"\n    else\n      c.add statement\n      c.scope body_\n    @l(n)+c\n\n  'do': (n) ->\n    c = new Code\n\n    c.add \"loop\"\n    c.scope @body(n.body)\n    c.scope \"break unless #{@build n.condition}\"  if n.condition?\n\n    @l(n)+c\n\n  'if': (n) ->\n    c = new Code\n\n    keyword = if n.positive then \"if\" else \"unless\"\n    body_   = @body(n.thenPart)\n    n.condition.parenthesized = false\n\n    # *Account for `if (xyz) {}`, which should be `xyz`. (#78)*\n    # *Note that `!xyz` still compiles to `xyz` because the `!` will not change anything.*\n    if n.thenPart.isA('block') and n.thenPart.children.length == 0 and !n.elsePart?\n      console.log n.thenPart\n      c.add \"#{@build n.condition}\\n\"\n\n    else if isSingleLine(body_) and !n.elsePart?\n      c.add \"#{trim body_}#{Code.INDENT}#{keyword} #{@build n.condition}\\n\"\n\n    else\n      c.add \"#{keyword} #{@build n.condition}\"\n      c.scope @body(n.thenPart)\n\n      if n.elsePart?\n        if n.elsePart.typeName() == 'if'\n          c.add \"else #{@build(n.elsePart).toString()}\"\n        else\n          c.add @l(n.elsePart)+\"else\\n\"\n          c.scope @body(n.elsePart)\n\n    @l(n)+c\n\n  'switch': (n) ->\n    c = new Code\n\n    c.add \"switch #{@build n.discriminant}\\n\"\n\n    fall_through = false\n    _.each n.cases, (item) =>\n      if item.value == 'default'\n        c.scope @l(item)+\"else\"\n      else\n        if fall_through == true\n          c.add @l(item)+\", #{@build item.caseLabel}\\n\"\n        else\n          c.add @l(item)+\"  when #{@build item.caseLabel}\"\n\n      if @body(item.statements).length == 0\n        fall_through = true\n      else\n        fall_through = false\n        c.add \"\\n\"\n        c.scope @body(item.statements), 2\n\n      first = false\n\n    @l(n)+c\n\n  'existence_check': (n) ->\n    @l(n)+\"#{@build n.left()}?\"\n\n  'array_init': (n) ->\n    options = {array:true}\n    if n.children.length == 0\n      @l(n)+\"[]\"\n    else if n.children.length > 1\n      @l(n)+\"[#{@list n, options}\\n]\"\n    else\n      @l(n)+\"[#{@list n}]\"\n\n  # `property_init`\n  # Belongs to `object_init`;\n  # left is a `identifier`, right can be anything.\n\n  'property_init': (n) ->\n    left = n.left()\n    right = n.right()\n    right.is_property_value = true\n    \"#{@property_identifier left}: #{@build right}\"\n\n  # `object_init`\n  # An object initializer.\n  # Has many `property_init`.\n\n  'object_init': (n, options={}) ->\n    if n.children.length == 0\n      @l(n)+\"{}\"\n\n    else if n.children.length == 1 and not (n.is_property_value or n.is_list_element)\n      @build n.children[0]\n\n    else\n      list = _.map n.children, (item) => @build item\n\n      c = new Code @, n\n      c.scope list.join(\"\\n\")\n      c = \"{#{c}}\"  if options.brackets?\n      c\n\n  # `function`\n  # A function. Can be an anonymous function (`function () { .. }`), or a named\n  # function (`function name() { .. }`).\n\n  'function': (n) ->\n    c = new Code\n\n    params = _.map n.params, (str) =>\n      if str.constructor == String\n        @id_param str\n      else\n        @build str\n\n    if n.name\n      c.add \"#{n.name} = \"\n\n    if n.params.length > 0\n      c.add \"(#{params.join ', '}) ->\"\n    else\n      c.add \"->\"\n\n    body = @body(n.body)\n    if trim(body).length > 0\n      c.scope body\n    else\n      c.add \"\\n\"\n\n    @l(n)+c\n\n  'var': (n) ->\n    list = _.map n.children, (item) =>\n      \"#{unreserve item.value} = #{if item.initializer? then @build(item.initializer) else 'undefined'}\"\n\n    @l(n)+_.compact(list).join(\"\\n\") + \"\\n\"\n\n  # ### Unsupported things\n  #\n  # Due to CoffeeScript limitations, the following things are not supported:\n  #\n  #  * New getter/setter syntax (`x.prototype = { get name() { ... } };`)\n  #  * Break labels (`my_label: ...`)\n  #  * Constants\n\n  'other': (n) ->   @unsupported n, \"#{n.typeName()} is not supported yet\"\n  'getter': (n) ->  @unsupported n, \"getter syntax is not supported; use __defineGetter__\"\n  'setter': (n) ->  @unsupported n, \"setter syntax is not supported; use __defineSetter__\"\n  'label': (n) ->   @unsupported n, \"labels are not supported by CoffeeScript\"\n  'const': (n) ->   @unsupported n, \"consts are not supported by CoffeeScript\"\n\n  'block': (args...) ->\n    @script.apply @, args\n\n  # `unsupported()`\n  # Throws an unsupported error.\n  'unsupported': (node, message) ->\n    throw new UnsupportedError(\"Unsupported: #{message}\", node)\n\n# ## AST manipulation\n# Manipulation of the abstract syntax tree happens here. All these are done on\n# the `build()` step, done just before a node is passed onto `Builders`.\n\nclass Transformer\n  transform: (args...) ->\n    node = args[0]\n    return  if node.transformed?\n    type = node.typeName()\n    fn = @[type]\n\n    if fn\n      fn.apply(this, args)\n      node.transformed = true\n\n  'script': (n) ->\n    n.functions    = []\n    n.nonfunctions = []\n\n    _.each n.children, (item) =>\n      if item.isA('function')\n        n.functions.push item\n      else\n        n.nonfunctions.push item\n\n    last = null\n\n    # *Statements don't need parens, unless they are consecutive object\n    # literals.*\n    _.each n.nonfunctions, (item) =>\n      if item.expression?\n        expr = item.expression\n        if last?.isA('object_init') and expr.isA('object_init')\n          item.parenthesized = true\n        else\n          item.parenthesized = false\n\n        last = expr\n\n  '.': (n) ->\n    if n.left().isA('function')\n      n.left().parenthesized = true\n\n    n.isThis      = n.left().isA('this')\n    n.isPrototype = (n.right().isA('identifier') and n.right().value == 'prototype')\n\n  ';': (n) ->\n    if n.expression?\n      # *Statements don't need parens.*\n      n.expression.parenthesized = false\n\n      # *If the statement only has one function call (eg, `alert(2);`), the\n      # parentheses should be omitted (eg, `alert 2`).*\n      if n.expression.isA('call')\n        n.expression.type = Typenames['call_statement']\n        @call_statement n\n\n  'function': (n) ->\n\n    nonreturns = 0\n    transform_switch = @switch  # we may need this in the walk block below\n\n    # *Unwrap the `return`s.*\n    n.body.walk last: true, (parent, node, list) ->\n\n      # if the last node is a break, we want the one before that\n      transform_switch node if node.isA('switch')\n\n      # Hax\n      lastNode = if list\n        parent[list]\n      else\n        parent.children[parent.children.length-1]\n\n      if node.value and lastNode\n        if node.isA('return')\n          lastNode.type = Typenames[';']\n          lastNode.expression = lastNode.value\n        else if lastNode.isA('if', 'switch', 'block')\n          #console.log \"disregarding nonreturn: #{node.value} and #{lastNode.typeName()}:#{lastNode.value}\"\n        else\n          #console.log \"nonreturn: #{node.value} and #{lastNode.typeName()}:#{lastNode.value}\"\n          nonreturns += 1\n\n    # *Add formerly implicit `return`s*\n    if nonreturns > 0\n      n.body.children.push\n        type: 'return'\n        typeName: -> @type\n        isA: (t) -> t == @type\n\n  'switch': (n) ->\n    _.each n.cases, (item) =>\n      block = item.statements\n      ch    = block.children\n\n      # *CoffeeScript does not need `break` statements on `switch` blocks.*\n      delete ch[ch.length-1] if block.last()?.isA('break')\n\n  'call_statement': (n) ->\n    if n.children[1]\n      _.each n.children[1].children, (child, i) ->\n        if child.isA('function') and i != n.children[1].children.length-1\n          child.parenthesized = true\n\n  'return': (n) ->\n    # *Doing \"return {x:2, y:3}\" should parenthesize the return value.*\n    if n.value and n.value.isA('object_init') and n.value.children.length > 1\n      n.value.parenthesized = true\n\n  'block': (n) ->\n    @script n\n\n  'if': (n) ->\n    # *Account for `if(x) {} else { something }` which should be `something unless x`.*\n    if n.thenPart.isA('block') and n.thenPart.children.length == 0 and (!n.elsePartisA('block') or n.elsePart?.children.length > 0)\n      n.positive = false\n      n.thenPart = n.elsePart\n      delete n.elsePart\n\n    @inversible n\n\n  'while': (n) ->\n    # *A while with a blank body (`while(x){}`) should be accounted for.*\n    # *You can't have empty blocks, so put a `continue` in there. (#78)*\n    if n.body.children.length is 0\n      n.body.children.push n.clone(type: Typenames['continue'], value: 'continue', children: [])\n\n    @inversible n\n\n  'inversible': (n) ->\n    @transform n.condition\n    positive = if n.positive? then n.positive else true\n\n    # *Invert a '!='. (`if (x != y)` => `unless x is y`)*\n    if n.condition.isA('!=')\n      n.condition.type = Typenames['==']\n      n.positive = not positive\n\n    # *Invert a '!'. (`if (!x)` => `unless x`)*\n    else if n.condition.isA('!')\n      n.condition = n.condition.left()\n      n.positive = not positive\n\n    else\n      n.positive = positive\n\n  '==': (n) ->\n    if n.right().isA('null', 'void')\n      n.type     = Typenames['!']\n      n.children = [n.clone(type: Typenames['existence_check'], children: [n.left()])]\n\n  '!=': (n) ->\n    if n.right().isA('null', 'void')\n      n.type     = Typenames['existence_check']\n      n.children = [n.left()]\n\nclass UnsupportedError\n  constructor: (str, src) ->\n    @message = str\n    @cursor  = src.start\n    @line    = src.lineno\n    @source  = src.tokenizer.source\n\n  toString: -> @message\n\n# ## Exports\n\n@Js2coffee = exports =\n  VERSION: pkg.version\n  build: buildCoffee\n  UnsupportedError: UnsupportedError\n\nmodule.exports = exports  if module?\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "js2coffee.js",
      "date": "2014-01-20T02:05:18.250Z",
      "slug": "lib-js2coffee",
      "url": "/lib/js2coffee.js",
      "urls": [
        "/lib/js2coffee.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "# The JavaScript to CoffeeScript compiler.\n#\n# Common usage:\n#\n#     var src = \"var square = function(n) { return n * n };\"\n#\n#     js2coffee = require('js2coffee');\n#     js2coffee.build(src);\n#     //=> \"square = (n) -> n * n\"\n\n# ## Requires\n#\n# Js2coffee relies on Narcissus's parser. (Narcissus is Mozilla's JavaScript\n# engine written in JavaScript).\n\n_ = require('underscore')\n#use extension to be compatible with browserify\npkg = require('../../package.json')\n{parser} = require('./narcissus_packed')\n{Types, Typenames, Node} = require('./node_ext')\n{Code, p, strEscapeDoubleQuotes, strEscapeSingleQuotes, unreserve, unshift, isSingleLine, trim, blockTrim, ltrim, rtrim, strRepeat, paren, truthy, indentLines} = require('./helpers')\n\nstrEscape = undefined \n\n# ## Main entry point\n# This is `require('js2coffee').build()`. It takes a JavaScript source\n# string as an argument, and it returns the CoffeeScript version.\n#\n# 1. Ask Narcissus to break it down into Nodes (`parser.parse`). This\n#    returns a `Node` object of type `script`.\n#\n# 2. This node is now passed onto `Builder#build()`.\n\nbuildCoffee = (str, opts = {}) ->\n  str  = str.replace /\\r/g, ''\n  str += \"\\n\"\n\n  if opts.indent?\n    Code.INDENT = opts.indent\n\n  if opts.single_quotes? and opts.single_quotes is true\n    console.log opts.single_quotes\n    strEscape = strEscapeSingleQuotes\n  else\n    strEscape = strEscapeDoubleQuotes\n\n  builder    = new Builder opts\n  scriptNode = parser.parse str\n\n  output = trim builder.build(scriptNode)\n\n  if opts.no_comments\n    (rtrim line for line in output.split('\\n')).join('\\n')\n\n  else\n    keepLineNumbers = opts.show_src_lineno\n\n    res = []\n    for l in output.split(\"\\n\")\n\n      srclines = []\n      text = l.replace /\\uFEFE([0-9]+).*?\\uFEFE/g,(m,g) ->\n          srclines.push parseInt(g)\n          \"\"\n\n      srclines = _.sortBy(_.uniq(srclines), (i) -> i)\n\n      text = rtrim(text)\n      indent = text.match /^\\s*/\n\n      if srclines.length > 0\n        minline = _.last(srclines)\n\n        precomments = builder.commentsNotDoneTo(minline)\n        if precomments\n          res.push indentLines indent,precomments\n\n      if text\n        if keepLineNumbers\n            text = text + \"#\" +srclines.join(\",\") + \"#  \"\n        res.push rtrim(text + \" \"+ltrim(builder.lineComments(srclines)))\n      else\n        res.push \"\"\n\n    comments = builder.commentsNotDoneTo(1e10)\n    if comments\n      res.push comments\n\n    res.join(\"\\n\")\n\n# ## Builder class\n# This is the main class that proccesses the AST and spits out streng.\n# See the `buildCoffee()` function above for info on how this is used.\n\nclass Builder\n  constructor: (@options={}) ->\n    @transformer = new Transformer\n\n  # `l()`\n  # Inject the source line as a hidden element to be stripped out later.\n\n  l: (n) ->\n    # todo: this could be configurable debug helper\n    # console.log n if n.lineno in [1]\n    if @options.no_comments\n      return ''\n    if n and n.lineno\n       # for DEBUG use this: \"\\uFEFE#{n.lineno},#{n.typeName()}\\uFEFE\"\n       \"\\uFEFE#{n.lineno}\\uFEFE\"\n    else\n      \"\"\n\n  makeComment: (comment) ->\n    if comment.type is \"BLOCK_COMMENT\"\n      c = comment.value.split(\"\\n\")\n\n      if c.length>0 and c[0].length>0 and c[0][0]==\"*\" # docstring ?\n        c = ( line.replace(/^[\\s\\*]*/,'') for line in c )\n        c = ( line.replace(/[\\s]*$/,'') for line in c )\n        #remove empty lines\n        while c.length > 0 and c[0].length==0\n          c.shift()\n        while c.length > 0 and c[c.length-1].length==0\n          c.pop()\n        c.unshift('###')\n        c.push('###')\n      else\n        c = (\"##{line}\" for line in c)\n    else\n        c = [ '#'+comment.value]\n\n    if comment.nlcount>0\n      c.unshift ''\n\n    c.join('\\n')\n\n  commentsNotDoneTo: (lineno) ->\n    res = []\n    loop\n      break if @comments.length is 0\n      c = @comments[0]\n\n      if c.lineno < lineno\n        res.push(@makeComment c)\n        @comments.shift()\n        continue\n      break\n\n    res.join(\"\\n\")\n\n  lineComments: (linenos) ->\n    # TODO: is there a nicer way to do this?\n    selection = (c for c in @comments when c.lineno in linenos)\n    @comments = _.difference(@comments, selection)\n    return (@makeComment c for c in selection).join(\"\\n\")\n\n  # `build()`\n  # The main entry point.\n\n  # This finds the appropriate @builder function for `node` based on it's type,\n  # the passes the node onto that function.\n  #\n  # For instance, for a `function` node, it calls `@builders.function(node)`.\n  # It defaults to `@builders.other` if it can't find a function for it.\n\n  build: (args...) ->\n    node = args[0]\n\n    # get comments from tokenizer\n    if not @comments?\n      @comments = _.sortBy node.tokenizer.comments, (n) ->\n        n.start\n\n    @transform node\n\n    name = 'other'\n    name = node.typeName()  if node != undefined and node.typeName\n\n    fn  = (@[name] or @other)\n    out = fn.apply(this, args)\n\n    if node.parenthesized then paren(out) else out\n\n  # `transform()`\n  # Perform a transformation on the node, if a transformation function is\n  # available.\n\n  transform: (args...) ->\n    @transformer.transform.apply(@transformer, args)\n\n  # `body()`\n  # Works like `@build()`, and is used for code blocks. It cleans up the returned\n  # code block by removing any extraneous spaces and such.\n\n  body: (node, opts={}) ->\n    str = @build(node, opts)\n    str = blockTrim(str)\n    str = unshift(str)\n\n    if str.length > 0 then str else \"\"\n\n  # ## The builders\n  #\n  # Each of these method are passed a Node, and is expected to return\n  # a string representation of it CoffeeScript counterpart.\n  #\n  # These are invoked using the main entry point, `Builder#build()`.\n\n  # `script`\n  # This is the main entry point.\n\n  'script': (n, opts={}) ->\n    c = new Code\n\n    # *Functions must always be declared first in a block.*\n    _.each n.functions,    (item) => c.add @build(item)\n    _.each n.nonfunctions, (item) => c.add @build(item)\n\n    c.toString()\n\n\n  # `property_identifier`\n  # A key in an object literal.\n\n  'property_identifier': (n) ->\n    str = n.value.toString()\n\n    # **Caveat:**\n    # *In object literals like `{ '#foo click': b }`, ensure that the key is\n    # quoted if need be.*\n\n    if str.match(/^([_\\$a-z][_\\$a-z0-9]*)$/i) or str.match(/^[0-9]+$/i)\n      @l(n)+str\n    else\n      @l(n)+strEscape str\n\n  # `identifier`\n  # Any object identifier like a variable name.\n\n  'identifier': (n) ->\n    if n.value is 'undefined'\n      @l(n)+'`undefined`'\n    else if n.property_accessor\n      @l(n)+n.value.toString()\n    else\n      @l(n)+unreserve n.value.toString()\n\n  'number': (n) ->\n    @l(n)+\"#{n.src()}\"\n\n  'id': (n) ->\n    if n.property_accessor\n      @l(n)+n\n    else\n      @l(n)+unreserve n\n\n  # `id_param`\n  # Function parameters. Belongs to `list`.\n\n  'id_param': (n) ->\n    if n.toString() in ['undefined']\n      @l(n)+\"#{n}_\"\n    else\n      @l(n)+@id n\n\n  # `return`\n  # A return statement. Has `n.value` of type `id`.\n\n  'return': (n) ->\n    if not n.value?\n      @l(n)+\"return\\n\"\n\n    else\n      @l(n)+\"return #{@build(n.value)}\\n\"\n\n  # `;` (aka, statement)\n  # A single statement.\n\n  ';': (n) ->\n    # **Caveat:**\n    # Some statements can be blank as some people are silly enough to use `;;`\n    # sometimes. They should be ignored.\n\n    unless n.expression?\n      \"\"\n\n    else if n.expression.typeName() == 'object_init'\n\n      src = @object_init(n.expression)\n      if n.parenthesized\n        src\n      else\n        \"#{unshift(blockTrim(src))}\\n\"\n\n    else\n      @build(n.expression) + \"\\n\"\n\n  # `new` + `new_with_args`\n  # For `new X` and `new X(y)` respctively.\n\n  'new': (n) -> @l(n)+\"new #{@build n.left()}\"\n  'new_with_args': (n) -> @l(n)+\"new #{@build n.left()}(#{@build n.right()})\"\n\n  # ### Unary operators\n\n  'unary_plus': (n) -> \"+#{@build n.left()}\"\n  'unary_minus': (n) -> \"-#{@build n.left()}\"\n\n  # ### Keywords\n\n  'this': (n) -> @l(n)+'this'\n  'null': (n) -> @l(n)+'null'\n  'true': (n) -> @l(n)+'true'\n  'false': (n) -> @l(n)+'false'\n  'void': (n) -> @l(n)+'undefined'\n\n  'debugger': (n) -> @l(n)+\"debugger\\n\"\n  'break': (n) -> @l(n)+\"break\\n\"\n  'continue': (n) -> @l(n)+\"continue\\n\"\n\n  # ### Some simple operators\n\n  '~': (n) ->\n    \"~#{@build n.left()}\"\n\n  'typeof': (n) ->\n    @l(n)+\"typeof #{@build n.left()}\"\n\n  'index': (n) ->\n    right = @build n.right()\n    if _.any(n.children, (child) -> child.typeName() == 'object_init' and child.children.length > 1)\n      right = \"{#{right}}\"\n    @l(n)+\"#{@build n.left()}[#{right}]\"\n\n  'throw': (n) ->\n    @l(n)+\"throw #{@build n.exception}\"\n\n  '!': (n) ->\n    target = n.left()\n    negations = 1\n    ++negations while (target.isA '!') and target = target.left()\n    if (negations & 1) and target.isA '==', '!=', '===', '!==', 'in', 'instanceof' # invertible binary operators\n      target.negated = not target.negated\n      return @build target\n    @l(n)+\"#{if negations & 1 then 'not ' else '!!'}#{@build target}\"\n\n  # ### Binary operators\n  # All of these are rerouted to the `binary_operator` @builder.\n\n  # TODO: make a function that generates these functions, invoked like so:\n  #   in: binop 'in', 'of'\n  #   '+': binop '+'\n  #   and so on...\n\n  in: (n) ->    @binary_operator n, 'of'\n  '+': (n) ->   @binary_operator n, '+'\n  '-': (n) ->   @binary_operator n, '-'\n  '*': (n) ->   @binary_operator n, '*'\n  '/': (n) ->   @binary_operator n, '/'\n  '%': (n) ->   @binary_operator n, '%'\n  '>': (n) ->   @binary_operator n, '>'\n  '<': (n) ->   @binary_operator n, '<'\n  '&': (n) ->   @binary_operator n, '&'\n  '|': (n) ->   @binary_operator n, '|'\n  '^': (n) ->   @binary_operator n, '^'\n  '&&': (n) ->  @binary_operator n, 'and'\n  '||': (n) ->  @binary_operator n, 'or'\n  '<<': (n) ->  @binary_operator n, '<<'\n  '<=': (n) ->  @binary_operator n, '<='\n  '>>': (n) ->  @binary_operator n, '>>'\n  '>=': (n) ->  @binary_operator n, '>='\n  '===': (n) -> @binary_operator n, 'is'\n  '!==': (n) -> @binary_operator n, 'isnt'\n  '>>>': (n) ->  @binary_operator n, '>>>'\n  instanceof: (n) -> @binary_operator n, 'instanceof'\n\n  '==': (n) ->\n    # TODO: throw warning\n    @binary_operator n, 'is'\n\n  '!=': (n) ->\n    # TODO: throw warning\n    @binary_operator n, 'isnt'\n\n  'binary_operator': do ->\n    INVERSIONS =\n      is: 'isnt'\n      in: 'not in'\n      of: 'not of'\n      instanceof: 'not instanceof'\n    INVERSIONS[v] = k for own k, v of INVERSIONS\n    (n, sign) ->\n      sign = INVERSIONS[sign] if n.negated\n      @l(n)+\"#{@build n.left()} #{sign} #{@build n.right()}\"\n\n  # ### Increments and decrements\n  # For `a++` and `--b`.\n\n  '--': (n) -> @increment_decrement n, '--'\n  '++': (n) -> @increment_decrement n, '++'\n\n  'increment_decrement': (n, sign) ->\n    if n.postfix\n      @l(n)+\"#{@build n.left()}#{sign}\"\n    else\n      @l(n)+\"#{sign}#{@build n.left()}\"\n\n  # `=` (aka, assignment)\n  # For `a = b` (but not `var a = b`: that's `var`).\n\n  '=': (n) ->\n    sign = if n.assignOp?\n      Types[n.assignOp] + '='\n    else\n      '='\n\n    @l(n)+\"#{@build n.left()} #{sign} #{@build n.right()}\"\n\n  # `,` (aka, comma)\n  # For `a = 1, b = 2'\n\n  ',': (n) ->\n    list = _.map n.children, (item) => @l(item)+@build(item) + \"\\n\"\n    list.join('')\n\n  # `regexp`\n  # Regular expressions.\n\n  'regexp': (n) ->\n    m     = n.value.toString().match(/^\\/(.*)\\/([a-z]?)/)\n    value = m[1]\n    flag  = m[2]\n\n    # **Caveat:**\n    # *If it begins with `=` or a space, the CoffeeScript parser will choke if\n    # it's written as `/=/`. Hence, they are written as `new RegExp('=')`.*\n\n    begins_with = value[0]\n\n    if begins_with in [' ', '=']\n      if flag.length > 0\n        @l(n)+\"RegExp(#{strEscape value}, \\\"#{flag}\\\")\"\n      else\n        @l(n)+\"RegExp(#{strEscape value})\"\n    else\n      @l(n)+\"/#{value}/#{flag}\"\n\n  'string': (n) ->\n    @l(n)+ strEscape n.value\n\n  # `call`\n  # A Function call.\n  # `n.left` is an `id`, and `n.right` is a `list`.\n\n  'call': (n) ->\n    if n.right().children.length == 0\n      \"#{@build n.left()}()\"+@l(n)\n    else\n      \"#{@build n.left()}(#{@build n.right()})\"+@l(n)\n\n  # `call_statement`\n  # A `call` that's on it's own line.\n\n  'call_statement': (n) ->\n    left = @build n.left()\n\n    # **Caveat:**\n    # *When calling in this way: `function () { ... }()`,\n    # ensure that there are parenthesis around the anon function\n    # (eg, `(-> ...)()`).*\n\n    left = paren(left)  if n.left().isA('function')\n\n    if n.right().children.length == 0\n      \"#{left}()\"+@l(n)\n    else\n      \"#{left} #{@build n.right()}\"+@l(n)\n\n  # `list`\n  # A parameter list.\n\n  'list': (n, options = {}) ->\n    list = _.map n.children, (item) =>\n      if n.children.length > 1\n        item.is_list_element = true\n      #return @build item # original\n\n      if options.array is true and n.children.length > 0\n        raw = @[item.typeName()](item)\n        c = new Code @, item\n        c.scope raw\n        c = trim c + Code.INDENT\n        if item.typeName() is 'object_init'\n          c = \"{\\n#{Code.INDENT}#{Code.INDENT}#{c}\\n#{Code.INDENT}}\"\n\n        return c\n      else\n        return @build item\n\n    #return @l(n)+list.join(\", \") # original\n    if options.array is true and n.children.length > 0\n      return @l(n) + \"\\n#{Code.INDENT}#{list.join('\\n'+Code.INDENT)}\"\n    else\n      return @l(n)+list.join(\", \")\n\n  'delete': (n) ->\n    ids = _.map(n.children, (el) => @build(el))\n    ids = ids.join(', ')\n    @l(n)+\"delete #{ids}\\n\"\n\n  # `.` (scope resolution?)\n  # For instances such as `object.value`.\n\n  '.': (n) ->\n    # **Caveat:**\n    # *If called as `this.xxx`, it should use the at sign (`n.xxx`).*\n\n    # **Caveat:**\n    # *If called as `x.prototype`, it should use double colons (`x::`).*\n\n    left  = @build n.left()\n    right_obj = n.right()\n    right_obj.property_accessor = true\n    right = @build right_obj\n\n    if n.isThis and n.isPrototype\n      @l(n)+\"@::\"\n    else if n.isThis\n      @l(n)+\"@#{right}\"\n    else if n.isPrototype\n      @l(n)+\"#{left}::\"\n    else if n.left().isPrototype\n      @l(n)+\"#{left}#{right}\"\n    else\n      @l(n)+\"#{left}.#{right}\"\n\n  'try': (n) ->\n    c = new Code\n    c.add 'try'\n    c.scope @body(n.tryBlock)\n\n    _.each n.catchClauses, (clause) =>\n      c.add @build(clause)\n\n    if n.finallyBlock?\n      c.add \"finally\"\n      c.scope @body(n.finallyBlock)\n\n    @l(n)+c\n\n  'catch': (n) ->\n    body_ = @body(n.block)\n    return '' if trim(body_).length == 0\n\n    c = new Code\n\n    if n.varName?\n      c.add \"catch #{n.varName}\"\n    else\n      c.add 'catch'\n\n    c.scope @body(n.block)\n    @l(n)+c\n\n  # `?` (ternary operator)\n  # For `a ? b : c`. Note that these will always be parenthesized, as (I\n  # believe) the order of operations in JS is different in CS.\n\n  '?': (n) ->\n    @l(n)+\"(if #{@build n.left()} then #{@build n.children[1]} else #{@build n.children[2]})\"\n\n  'for': (n) ->\n    c = new Code\n\n    if n.setup?\n      c.add \"#{@build n.setup}\\n\"\n\n    if n.condition?\n      c.add \"while #{@build n.condition}\\n\"\n    else\n      c.add \"loop\"\n\n    c.scope @body(n.body)\n    c.scope @body(n.update)  if n.update?\n    @l(n)+c\n\n  'for_in': (n) ->\n    c = new Code\n\n    c.add \"for #{@build n.iterator} of #{@build n.object}\"\n    #c.scope @body(n.body)\n    if n.body.children.length > 0\n      c.scope @body(n.body)\n    else\n      c.scope \"continue\"\n    @l(n)+c\n\n  'while': (n) ->\n    c = new Code\n\n    keyword   = if n.positive then \"while\" else \"until\"\n    body_     = @body(n.body)\n\n    # *Use `loop` whin something will go on forever (like `while (true)`).*\n    if truthy(n.condition)\n      statement = \"loop\"\n    else\n      statement = \"#{keyword} #{@build n.condition}\"\n\n    if isSingleLine(body_) and statement isnt \"loop\"\n      c.add \"#{trim body_}#{Code.INDENT}#{statement}\\n\"\n    else\n      c.add statement\n      c.scope body_\n    @l(n)+c\n\n  'do': (n) ->\n    c = new Code\n\n    c.add \"loop\"\n    c.scope @body(n.body)\n    c.scope \"break unless #{@build n.condition}\"  if n.condition?\n\n    @l(n)+c\n\n  'if': (n) ->\n    c = new Code\n\n    keyword = if n.positive then \"if\" else \"unless\"\n    body_   = @body(n.thenPart)\n    n.condition.parenthesized = false\n\n    # *Account for `if (xyz) {}`, which should be `xyz`. (#78)*\n    # *Note that `!xyz` still compiles to `xyz` because the `!` will not change anything.*\n    if n.thenPart.isA('block') and n.thenPart.children.length == 0 and !n.elsePart?\n      console.log n.thenPart\n      c.add \"#{@build n.condition}\\n\"\n\n    else if isSingleLine(body_) and !n.elsePart?\n      c.add \"#{trim body_}#{Code.INDENT}#{keyword} #{@build n.condition}\\n\"\n\n    else\n      c.add \"#{keyword} #{@build n.condition}\"\n      c.scope @body(n.thenPart)\n\n      if n.elsePart?\n        if n.elsePart.typeName() == 'if'\n          c.add \"else #{@build(n.elsePart).toString()}\"\n        else\n          c.add @l(n.elsePart)+\"else\\n\"\n          c.scope @body(n.elsePart)\n\n    @l(n)+c\n\n  'switch': (n) ->\n    c = new Code\n\n    c.add \"switch #{@build n.discriminant}\\n\"\n\n    fall_through = false\n    _.each n.cases, (item) =>\n      if item.value == 'default'\n        c.scope @l(item)+\"else\"\n      else\n        if fall_through == true\n          c.add @l(item)+\", #{@build item.caseLabel}\\n\"\n        else\n          c.add @l(item)+\"  when #{@build item.caseLabel}\"\n\n      if @body(item.statements).length == 0\n        fall_through = true\n      else\n        fall_through = false\n        c.add \"\\n\"\n        c.scope @body(item.statements), 2\n\n      first = false\n\n    @l(n)+c\n\n  'existence_check': (n) ->\n    @l(n)+\"#{@build n.left()}?\"\n\n  'array_init': (n) ->\n    options = {array:true}\n    if n.children.length == 0\n      @l(n)+\"[]\"\n    else if n.children.length > 1\n      @l(n)+\"[#{@list n, options}\\n]\"\n    else\n      @l(n)+\"[#{@list n}]\"\n\n  # `property_init`\n  # Belongs to `object_init`;\n  # left is a `identifier`, right can be anything.\n\n  'property_init': (n) ->\n    left = n.left()\n    right = n.right()\n    right.is_property_value = true\n    \"#{@property_identifier left}: #{@build right}\"\n\n  # `object_init`\n  # An object initializer.\n  # Has many `property_init`.\n\n  'object_init': (n, options={}) ->\n    if n.children.length == 0\n      @l(n)+\"{}\"\n\n    else if n.children.length == 1 and not (n.is_property_value or n.is_list_element)\n      @build n.children[0]\n\n    else\n      list = _.map n.children, (item) => @build item\n\n      c = new Code @, n\n      c.scope list.join(\"\\n\")\n      c = \"{#{c}}\"  if options.brackets?\n      c\n\n  # `function`\n  # A function. Can be an anonymous function (`function () { .. }`), or a named\n  # function (`function name() { .. }`).\n\n  'function': (n) ->\n    c = new Code\n\n    params = _.map n.params, (str) =>\n      if str.constructor == String\n        @id_param str\n      else\n        @build str\n\n    if n.name\n      c.add \"#{n.name} = \"\n\n    if n.params.length > 0\n      c.add \"(#{params.join ', '}) ->\"\n    else\n      c.add \"->\"\n\n    body = @body(n.body)\n    if trim(body).length > 0\n      c.scope body\n    else\n      c.add \"\\n\"\n\n    @l(n)+c\n\n  'var': (n) ->\n    list = _.map n.children, (item) =>\n      \"#{unreserve item.value} = #{if item.initializer? then @build(item.initializer) else 'undefined'}\"\n\n    @l(n)+_.compact(list).join(\"\\n\") + \"\\n\"\n\n  # ### Unsupported things\n  #\n  # Due to CoffeeScript limitations, the following things are not supported:\n  #\n  #  * New getter/setter syntax (`x.prototype = { get name() { ... } };`)\n  #  * Break labels (`my_label: ...`)\n  #  * Constants\n\n  'other': (n) ->   @unsupported n, \"#{n.typeName()} is not supported yet\"\n  'getter': (n) ->  @unsupported n, \"getter syntax is not supported; use __defineGetter__\"\n  'setter': (n) ->  @unsupported n, \"setter syntax is not supported; use __defineSetter__\"\n  'label': (n) ->   @unsupported n, \"labels are not supported by CoffeeScript\"\n  'const': (n) ->   @unsupported n, \"consts are not supported by CoffeeScript\"\n\n  'block': (args...) ->\n    @script.apply @, args\n\n  # `unsupported()`\n  # Throws an unsupported error.\n  'unsupported': (node, message) ->\n    throw new UnsupportedError(\"Unsupported: #{message}\", node)\n\n# ## AST manipulation\n# Manipulation of the abstract syntax tree happens here. All these are done on\n# the `build()` step, done just before a node is passed onto `Builders`.\n\nclass Transformer\n  transform: (args...) ->\n    node = args[0]\n    return  if node.transformed?\n    type = node.typeName()\n    fn = @[type]\n\n    if fn\n      fn.apply(this, args)\n      node.transformed = true\n\n  'script': (n) ->\n    n.functions    = []\n    n.nonfunctions = []\n\n    _.each n.children, (item) =>\n      if item.isA('function')\n        n.functions.push item\n      else\n        n.nonfunctions.push item\n\n    last = null\n\n    # *Statements don't need parens, unless they are consecutive object\n    # literals.*\n    _.each n.nonfunctions, (item) =>\n      if item.expression?\n        expr = item.expression\n        if last?.isA('object_init') and expr.isA('object_init')\n          item.parenthesized = true\n        else\n          item.parenthesized = false\n\n        last = expr\n\n  '.': (n) ->\n    if n.left().isA('function')\n      n.left().parenthesized = true\n\n    n.isThis      = n.left().isA('this')\n    n.isPrototype = (n.right().isA('identifier') and n.right().value == 'prototype')\n\n  ';': (n) ->\n    if n.expression?\n      # *Statements don't need parens.*\n      n.expression.parenthesized = false\n\n      # *If the statement only has one function call (eg, `alert(2);`), the\n      # parentheses should be omitted (eg, `alert 2`).*\n      if n.expression.isA('call')\n        n.expression.type = Typenames['call_statement']\n        @call_statement n\n\n  'function': (n) ->\n\n    nonreturns = 0\n    transform_switch = @switch  # we may need this in the walk block below\n\n    # *Unwrap the `return`s.*\n    n.body.walk last: true, (parent, node, list) ->\n\n      # if the last node is a break, we want the one before that\n      transform_switch node if node.isA('switch')\n\n      # Hax\n      lastNode = if list\n        parent[list]\n      else\n        parent.children[parent.children.length-1]\n\n      if node.value and lastNode\n        if node.isA('return')\n          lastNode.type = Typenames[';']\n          lastNode.expression = lastNode.value\n        else if lastNode.isA('if', 'switch', 'block')\n          #console.log \"disregarding nonreturn: #{node.value} and #{lastNode.typeName()}:#{lastNode.value}\"\n        else\n          #console.log \"nonreturn: #{node.value} and #{lastNode.typeName()}:#{lastNode.value}\"\n          nonreturns += 1\n\n    # *Add formerly implicit `return`s*\n    if nonreturns > 0\n      n.body.children.push\n        type: 'return'\n        typeName: -> @type\n        isA: (t) -> t == @type\n\n  'switch': (n) ->\n    _.each n.cases, (item) =>\n      block = item.statements\n      ch    = block.children\n\n      # *CoffeeScript does not need `break` statements on `switch` blocks.*\n      delete ch[ch.length-1] if block.last()?.isA('break')\n\n  'call_statement': (n) ->\n    if n.children[1]\n      _.each n.children[1].children, (child, i) ->\n        if child.isA('function') and i != n.children[1].children.length-1\n          child.parenthesized = true\n\n  'return': (n) ->\n    # *Doing \"return {x:2, y:3}\" should parenthesize the return value.*\n    if n.value and n.value.isA('object_init') and n.value.children.length > 1\n      n.value.parenthesized = true\n\n  'block': (n) ->\n    @script n\n\n  'if': (n) ->\n    # *Account for `if(x) {} else { something }` which should be `something unless x`.*\n    if n.thenPart.isA('block') and n.thenPart.children.length == 0 and (!n.elsePartisA('block') or n.elsePart?.children.length > 0)\n      n.positive = false\n      n.thenPart = n.elsePart\n      delete n.elsePart\n\n    @inversible n\n\n  'while': (n) ->\n    # *A while with a blank body (`while(x){}`) should be accounted for.*\n    # *You can't have empty blocks, so put a `continue` in there. (#78)*\n    if n.body.children.length is 0\n      n.body.children.push n.clone(type: Typenames['continue'], value: 'continue', children: [])\n\n    @inversible n\n\n  'inversible': (n) ->\n    @transform n.condition\n    positive = if n.positive? then n.positive else true\n\n    # *Invert a '!='. (`if (x != y)` => `unless x is y`)*\n    if n.condition.isA('!=')\n      n.condition.type = Typenames['==']\n      n.positive = not positive\n\n    # *Invert a '!'. (`if (!x)` => `unless x`)*\n    else if n.condition.isA('!')\n      n.condition = n.condition.left()\n      n.positive = not positive\n\n    else\n      n.positive = positive\n\n  '==': (n) ->\n    if n.right().isA('null', 'void')\n      n.type     = Typenames['!']\n      n.children = [n.clone(type: Typenames['existence_check'], children: [n.left()])]\n\n  '!=': (n) ->\n    if n.right().isA('null', 'void')\n      n.type     = Typenames['existence_check']\n      n.children = [n.left()]\n\nclass UnsupportedError\n  constructor: (str, src) ->\n    @message = str\n    @cursor  = src.start\n    @line    = src.lineno\n    @source  = src.tokenizer.source\n\n  toString: -> @message\n\n# ## Exports\n\n@Js2coffee = exports =\n  VERSION: pkg.version\n  build: buildCoffee\n  UnsupportedError: UnsupportedError\n\nmodule.exports = exports  if module?\n",
      "rendered": true,
      "contentRendered": "(function() {\n  var Builder, Code, Node, Transformer, Typenames, Types, UnsupportedError, blockTrim, buildCoffee, exports, indentLines, isSingleLine, ltrim, p, paren, parser, pkg, rtrim, strEscape, strEscapeDoubleQuotes, strEscapeSingleQuotes, strRepeat, trim, truthy, unreserve, unshift, _, _ref, _ref1,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty;\n\n  _ = require('underscore');\n\n  pkg = require('../../package.json');\n\n  parser = require('./narcissus_packed').parser;\n\n  _ref = require('./node_ext'), Types = _ref.Types, Typenames = _ref.Typenames, Node = _ref.Node;\n\n  _ref1 = require('./helpers'), Code = _ref1.Code, p = _ref1.p, strEscapeDoubleQuotes = _ref1.strEscapeDoubleQuotes, strEscapeSingleQuotes = _ref1.strEscapeSingleQuotes, unreserve = _ref1.unreserve, unshift = _ref1.unshift, isSingleLine = _ref1.isSingleLine, trim = _ref1.trim, blockTrim = _ref1.blockTrim, ltrim = _ref1.ltrim, rtrim = _ref1.rtrim, strRepeat = _ref1.strRepeat, paren = _ref1.paren, truthy = _ref1.truthy, indentLines = _ref1.indentLines;\n\n  strEscape = void 0;\n\n  buildCoffee = function(str, opts) {\n    var builder, comments, indent, keepLineNumbers, l, line, minline, output, precomments, res, scriptNode, srclines, text, _i, _len, _ref2;\n    if (opts == null) {\n      opts = {};\n    }\n    str = str.replace(/\\r/g, '');\n    str += \"\\n\";\n    if (opts.indent != null) {\n      Code.INDENT = opts.indent;\n    }\n    if ((opts.single_quotes != null) && opts.single_quotes === true) {\n      console.log(opts.single_quotes);\n      strEscape = strEscapeSingleQuotes;\n    } else {\n      strEscape = strEscapeDoubleQuotes;\n    }\n    builder = new Builder(opts);\n    scriptNode = parser.parse(str);\n    output = trim(builder.build(scriptNode));\n    if (opts.no_comments) {\n      return ((function() {\n        var _i, _len, _ref2, _results;\n        _ref2 = output.split('\\n');\n        _results = [];\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          line = _ref2[_i];\n          _results.push(rtrim(line));\n        }\n        return _results;\n      })()).join('\\n');\n    } else {\n      keepLineNumbers = opts.show_src_lineno;\n      res = [];\n      _ref2 = output.split(\"\\n\");\n      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n        l = _ref2[_i];\n        srclines = [];\n        text = l.replace(/\\uFEFE([0-9]+).*?\\uFEFE/g, function(m, g) {\n          srclines.push(parseInt(g));\n          return \"\";\n        });\n        srclines = _.sortBy(_.uniq(srclines), function(i) {\n          return i;\n        });\n        text = rtrim(text);\n        indent = text.match(/^\\s*/);\n        if (srclines.length > 0) {\n          minline = _.last(srclines);\n          precomments = builder.commentsNotDoneTo(minline);\n          if (precomments) {\n            res.push(indentLines(indent, precomments));\n          }\n        }\n        if (text) {\n          if (keepLineNumbers) {\n            text = text + \"#\" + srclines.join(\",\") + \"#  \";\n          }\n          res.push(rtrim(text + \" \" + ltrim(builder.lineComments(srclines))));\n        } else {\n          res.push(\"\");\n        }\n      }\n      comments = builder.commentsNotDoneTo(1e10);\n      if (comments) {\n        res.push(comments);\n      }\n      return res.join(\"\\n\");\n    }\n  };\n\n  Builder = (function() {\n    function Builder(options) {\n      this.options = options != null ? options : {};\n      this.transformer = new Transformer;\n    }\n\n    Builder.prototype.l = function(n) {\n      if (this.options.no_comments) {\n        return '';\n      }\n      if (n && n.lineno) {\n        return \"\\uFEFE\" + n.lineno + \"\\uFEFE\";\n      } else {\n        return \"\";\n      }\n    };\n\n    Builder.prototype.makeComment = function(comment) {\n      var c, line;\n      if (comment.type === \"BLOCK_COMMENT\") {\n        c = comment.value.split(\"\\n\");\n        if (c.length > 0 && c[0].length > 0 && c[0][0] === \"*\") {\n          c = (function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = c.length; _i < _len; _i++) {\n              line = c[_i];\n              _results.push(line.replace(/^[\\s\\*]*/, ''));\n            }\n            return _results;\n          })();\n          c = (function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = c.length; _i < _len; _i++) {\n              line = c[_i];\n              _results.push(line.replace(/[\\s]*$/, ''));\n            }\n            return _results;\n          })();\n          while (c.length > 0 && c[0].length === 0) {\n            c.shift();\n          }\n          while (c.length > 0 && c[c.length - 1].length === 0) {\n            c.pop();\n          }\n          c.unshift('###');\n          c.push('###');\n        } else {\n          c = (function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = c.length; _i < _len; _i++) {\n              line = c[_i];\n              _results.push(\"#\" + line);\n            }\n            return _results;\n          })();\n        }\n      } else {\n        c = ['#' + comment.value];\n      }\n      if (comment.nlcount > 0) {\n        c.unshift('');\n      }\n      return c.join('\\n');\n    };\n\n    Builder.prototype.commentsNotDoneTo = function(lineno) {\n      var c, res;\n      res = [];\n      while (true) {\n        if (this.comments.length === 0) {\n          break;\n        }\n        c = this.comments[0];\n        if (c.lineno < lineno) {\n          res.push(this.makeComment(c));\n          this.comments.shift();\n          continue;\n        }\n        break;\n      }\n      return res.join(\"\\n\");\n    };\n\n    Builder.prototype.lineComments = function(linenos) {\n      var c, selection;\n      selection = (function() {\n        var _i, _len, _ref2, _ref3, _results;\n        _ref2 = this.comments;\n        _results = [];\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          c = _ref2[_i];\n          if (_ref3 = c.lineno, __indexOf.call(linenos, _ref3) >= 0) {\n            _results.push(c);\n          }\n        }\n        return _results;\n      }).call(this);\n      this.comments = _.difference(this.comments, selection);\n      return ((function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = selection.length; _i < _len; _i++) {\n          c = selection[_i];\n          _results.push(this.makeComment(c));\n        }\n        return _results;\n      }).call(this)).join(\"\\n\");\n    };\n\n    Builder.prototype.build = function() {\n      var args, fn, name, node, out;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      node = args[0];\n      if (this.comments == null) {\n        this.comments = _.sortBy(node.tokenizer.comments, function(n) {\n          return n.start;\n        });\n      }\n      this.transform(node);\n      name = 'other';\n      if (node !== void 0 && node.typeName) {\n        name = node.typeName();\n      }\n      fn = this[name] || this.other;\n      out = fn.apply(this, args);\n      if (node.parenthesized) {\n        return paren(out);\n      } else {\n        return out;\n      }\n    };\n\n    Builder.prototype.transform = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return this.transformer.transform.apply(this.transformer, args);\n    };\n\n    Builder.prototype.body = function(node, opts) {\n      var str;\n      if (opts == null) {\n        opts = {};\n      }\n      str = this.build(node, opts);\n      str = blockTrim(str);\n      str = unshift(str);\n      if (str.length > 0) {\n        return str;\n      } else {\n        return \"\";\n      }\n    };\n\n    Builder.prototype['script'] = function(n, opts) {\n      var c,\n        _this = this;\n      if (opts == null) {\n        opts = {};\n      }\n      c = new Code;\n      _.each(n.functions, function(item) {\n        return c.add(_this.build(item));\n      });\n      _.each(n.nonfunctions, function(item) {\n        return c.add(_this.build(item));\n      });\n      return c.toString();\n    };\n\n    Builder.prototype['property_identifier'] = function(n) {\n      var str;\n      str = n.value.toString();\n      if (str.match(/^([_\\$a-z][_\\$a-z0-9]*)$/i) || str.match(/^[0-9]+$/i)) {\n        return this.l(n) + str;\n      } else {\n        return this.l(n) + strEscape(str);\n      }\n    };\n\n    Builder.prototype['identifier'] = function(n) {\n      if (n.value === 'undefined') {\n        return this.l(n) + '`undefined`';\n      } else if (n.property_accessor) {\n        return this.l(n) + n.value.toString();\n      } else {\n        return this.l(n) + unreserve(n.value.toString());\n      }\n    };\n\n    Builder.prototype['number'] = function(n) {\n      return this.l(n) + (\"\" + (n.src()));\n    };\n\n    Builder.prototype['id'] = function(n) {\n      if (n.property_accessor) {\n        return this.l(n) + n;\n      } else {\n        return this.l(n) + unreserve(n);\n      }\n    };\n\n    Builder.prototype['id_param'] = function(n) {\n      var _ref2;\n      if ((_ref2 = n.toString()) === 'undefined') {\n        return this.l(n) + (\"\" + n + \"_\");\n      } else {\n        return this.l(n) + this.id(n);\n      }\n    };\n\n    Builder.prototype['return'] = function(n) {\n      if (n.value == null) {\n        return this.l(n) + \"return\\n\";\n      } else {\n        return this.l(n) + (\"return \" + (this.build(n.value)) + \"\\n\");\n      }\n    };\n\n    Builder.prototype[';'] = function(n) {\n      var src;\n      if (n.expression == null) {\n        return \"\";\n      } else if (n.expression.typeName() === 'object_init') {\n        src = this.object_init(n.expression);\n        if (n.parenthesized) {\n          return src;\n        } else {\n          return \"\" + (unshift(blockTrim(src))) + \"\\n\";\n        }\n      } else {\n        return this.build(n.expression) + \"\\n\";\n      }\n    };\n\n    Builder.prototype['new'] = function(n) {\n      return this.l(n) + (\"new \" + (this.build(n.left())));\n    };\n\n    Builder.prototype['new_with_args'] = function(n) {\n      return this.l(n) + (\"new \" + (this.build(n.left())) + \"(\" + (this.build(n.right())) + \")\");\n    };\n\n    Builder.prototype['unary_plus'] = function(n) {\n      return \"+\" + (this.build(n.left()));\n    };\n\n    Builder.prototype['unary_minus'] = function(n) {\n      return \"-\" + (this.build(n.left()));\n    };\n\n    Builder.prototype['this'] = function(n) {\n      return this.l(n) + 'this';\n    };\n\n    Builder.prototype['null'] = function(n) {\n      return this.l(n) + 'null';\n    };\n\n    Builder.prototype['true'] = function(n) {\n      return this.l(n) + 'true';\n    };\n\n    Builder.prototype['false'] = function(n) {\n      return this.l(n) + 'false';\n    };\n\n    Builder.prototype['void'] = function(n) {\n      return this.l(n) + 'undefined';\n    };\n\n    Builder.prototype['debugger'] = function(n) {\n      return this.l(n) + \"debugger\\n\";\n    };\n\n    Builder.prototype['break'] = function(n) {\n      return this.l(n) + \"break\\n\";\n    };\n\n    Builder.prototype['continue'] = function(n) {\n      return this.l(n) + \"continue\\n\";\n    };\n\n    Builder.prototype['~'] = function(n) {\n      return \"~\" + (this.build(n.left()));\n    };\n\n    Builder.prototype['typeof'] = function(n) {\n      return this.l(n) + (\"typeof \" + (this.build(n.left())));\n    };\n\n    Builder.prototype['index'] = function(n) {\n      var right;\n      right = this.build(n.right());\n      if (_.any(n.children, function(child) {\n        return child.typeName() === 'object_init' && child.children.length > 1;\n      })) {\n        right = \"{\" + right + \"}\";\n      }\n      return this.l(n) + (\"\" + (this.build(n.left())) + \"[\" + right + \"]\");\n    };\n\n    Builder.prototype['throw'] = function(n) {\n      return this.l(n) + (\"throw \" + (this.build(n.exception)));\n    };\n\n    Builder.prototype['!'] = function(n) {\n      var negations, target;\n      target = n.left();\n      negations = 1;\n      while ((target.isA('!')) && (target = target.left())) {\n        ++negations;\n      }\n      if ((negations & 1) && target.isA('==', '!=', '===', '!==', 'in', 'instanceof')) {\n        target.negated = !target.negated;\n        return this.build(target);\n      }\n      return this.l(n) + (\"\" + (negations & 1 ? 'not ' : '!!') + (this.build(target)));\n    };\n\n    Builder.prototype[\"in\"] = function(n) {\n      return this.binary_operator(n, 'of');\n    };\n\n    Builder.prototype['+'] = function(n) {\n      return this.binary_operator(n, '+');\n    };\n\n    Builder.prototype['-'] = function(n) {\n      return this.binary_operator(n, '-');\n    };\n\n    Builder.prototype['*'] = function(n) {\n      return this.binary_operator(n, '*');\n    };\n\n    Builder.prototype['/'] = function(n) {\n      return this.binary_operator(n, '/');\n    };\n\n    Builder.prototype['%'] = function(n) {\n      return this.binary_operator(n, '%');\n    };\n\n    Builder.prototype['>'] = function(n) {\n      return this.binary_operator(n, '>');\n    };\n\n    Builder.prototype['<'] = function(n) {\n      return this.binary_operator(n, '<');\n    };\n\n    Builder.prototype['&'] = function(n) {\n      return this.binary_operator(n, '&');\n    };\n\n    Builder.prototype['|'] = function(n) {\n      return this.binary_operator(n, '|');\n    };\n\n    Builder.prototype['^'] = function(n) {\n      return this.binary_operator(n, '^');\n    };\n\n    Builder.prototype['&&'] = function(n) {\n      return this.binary_operator(n, 'and');\n    };\n\n    Builder.prototype['||'] = function(n) {\n      return this.binary_operator(n, 'or');\n    };\n\n    Builder.prototype['<<'] = function(n) {\n      return this.binary_operator(n, '<<');\n    };\n\n    Builder.prototype['<='] = function(n) {\n      return this.binary_operator(n, '<=');\n    };\n\n    Builder.prototype['>>'] = function(n) {\n      return this.binary_operator(n, '>>');\n    };\n\n    Builder.prototype['>='] = function(n) {\n      return this.binary_operator(n, '>=');\n    };\n\n    Builder.prototype['==='] = function(n) {\n      return this.binary_operator(n, 'is');\n    };\n\n    Builder.prototype['!=='] = function(n) {\n      return this.binary_operator(n, 'isnt');\n    };\n\n    Builder.prototype['>>>'] = function(n) {\n      return this.binary_operator(n, '>>>');\n    };\n\n    Builder.prototype[\"instanceof\"] = function(n) {\n      return this.binary_operator(n, 'instanceof');\n    };\n\n    Builder.prototype['=='] = function(n) {\n      return this.binary_operator(n, 'is');\n    };\n\n    Builder.prototype['!='] = function(n) {\n      return this.binary_operator(n, 'isnt');\n    };\n\n    Builder.prototype['binary_operator'] = (function() {\n      var INVERSIONS, k, v;\n      INVERSIONS = {\n        is: 'isnt',\n        \"in\": 'not in',\n        of: 'not of',\n        \"instanceof\": 'not instanceof'\n      };\n      for (k in INVERSIONS) {\n        if (!__hasProp.call(INVERSIONS, k)) continue;\n        v = INVERSIONS[k];\n        INVERSIONS[v] = k;\n      }\n      return function(n, sign) {\n        if (n.negated) {\n          sign = INVERSIONS[sign];\n        }\n        return this.l(n) + (\"\" + (this.build(n.left())) + \" \" + sign + \" \" + (this.build(n.right())));\n      };\n    })();\n\n    Builder.prototype['--'] = function(n) {\n      return this.increment_decrement(n, '--');\n    };\n\n    Builder.prototype['++'] = function(n) {\n      return this.increment_decrement(n, '++');\n    };\n\n    Builder.prototype['increment_decrement'] = function(n, sign) {\n      if (n.postfix) {\n        return this.l(n) + (\"\" + (this.build(n.left())) + sign);\n      } else {\n        return this.l(n) + (\"\" + sign + (this.build(n.left())));\n      }\n    };\n\n    Builder.prototype['='] = function(n) {\n      var sign;\n      sign = n.assignOp != null ? Types[n.assignOp] + '=' : '=';\n      return this.l(n) + (\"\" + (this.build(n.left())) + \" \" + sign + \" \" + (this.build(n.right())));\n    };\n\n    Builder.prototype[','] = function(n) {\n      var list,\n        _this = this;\n      list = _.map(n.children, function(item) {\n        return _this.l(item) + _this.build(item) + \"\\n\";\n      });\n      return list.join('');\n    };\n\n    Builder.prototype['regexp'] = function(n) {\n      var begins_with, flag, m, value;\n      m = n.value.toString().match(/^\\/(.*)\\/([a-z]?)/);\n      value = m[1];\n      flag = m[2];\n      begins_with = value[0];\n      if (begins_with === ' ' || begins_with === '=') {\n        if (flag.length > 0) {\n          return this.l(n) + (\"RegExp(\" + (strEscape(value)) + \", \\\"\" + flag + \"\\\")\");\n        } else {\n          return this.l(n) + (\"RegExp(\" + (strEscape(value)) + \")\");\n        }\n      } else {\n        return this.l(n) + (\"/\" + value + \"/\" + flag);\n      }\n    };\n\n    Builder.prototype['string'] = function(n) {\n      return this.l(n) + strEscape(n.value);\n    };\n\n    Builder.prototype['call'] = function(n) {\n      if (n.right().children.length === 0) {\n        return (\"\" + (this.build(n.left())) + \"()\") + this.l(n);\n      } else {\n        return (\"\" + (this.build(n.left())) + \"(\" + (this.build(n.right())) + \")\") + this.l(n);\n      }\n    };\n\n    Builder.prototype['call_statement'] = function(n) {\n      var left;\n      left = this.build(n.left());\n      if (n.left().isA('function')) {\n        left = paren(left);\n      }\n      if (n.right().children.length === 0) {\n        return (\"\" + left + \"()\") + this.l(n);\n      } else {\n        return (\"\" + left + \" \" + (this.build(n.right()))) + this.l(n);\n      }\n    };\n\n    Builder.prototype['list'] = function(n, options) {\n      var list,\n        _this = this;\n      if (options == null) {\n        options = {};\n      }\n      list = _.map(n.children, function(item) {\n        var c, raw;\n        if (n.children.length > 1) {\n          item.is_list_element = true;\n        }\n        if (options.array === true && n.children.length > 0) {\n          raw = _this[item.typeName()](item);\n          c = new Code(_this, item);\n          c.scope(raw);\n          c = trim(c + Code.INDENT);\n          if (item.typeName() === 'object_init') {\n            c = \"{\\n\" + Code.INDENT + Code.INDENT + c + \"\\n\" + Code.INDENT + \"}\";\n          }\n          return c;\n        } else {\n          return _this.build(item);\n        }\n      });\n      if (options.array === true && n.children.length > 0) {\n        return this.l(n) + (\"\\n\" + Code.INDENT + (list.join('\\n' + Code.INDENT)));\n      } else {\n        return this.l(n) + list.join(\", \");\n      }\n    };\n\n    Builder.prototype['delete'] = function(n) {\n      var ids,\n        _this = this;\n      ids = _.map(n.children, function(el) {\n        return _this.build(el);\n      });\n      ids = ids.join(', ');\n      return this.l(n) + (\"delete \" + ids + \"\\n\");\n    };\n\n    Builder.prototype['.'] = function(n) {\n      var left, right, right_obj;\n      left = this.build(n.left());\n      right_obj = n.right();\n      right_obj.property_accessor = true;\n      right = this.build(right_obj);\n      if (n.isThis && n.isPrototype) {\n        return this.l(n) + \"@::\";\n      } else if (n.isThis) {\n        return this.l(n) + (\"@\" + right);\n      } else if (n.isPrototype) {\n        return this.l(n) + (\"\" + left + \"::\");\n      } else if (n.left().isPrototype) {\n        return this.l(n) + (\"\" + left + right);\n      } else {\n        return this.l(n) + (\"\" + left + \".\" + right);\n      }\n    };\n\n    Builder.prototype['try'] = function(n) {\n      var c,\n        _this = this;\n      c = new Code;\n      c.add('try');\n      c.scope(this.body(n.tryBlock));\n      _.each(n.catchClauses, function(clause) {\n        return c.add(_this.build(clause));\n      });\n      if (n.finallyBlock != null) {\n        c.add(\"finally\");\n        c.scope(this.body(n.finallyBlock));\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['catch'] = function(n) {\n      var body_, c;\n      body_ = this.body(n.block);\n      if (trim(body_).length === 0) {\n        return '';\n      }\n      c = new Code;\n      if (n.varName != null) {\n        c.add(\"catch \" + n.varName);\n      } else {\n        c.add('catch');\n      }\n      c.scope(this.body(n.block));\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['?'] = function(n) {\n      return this.l(n) + (\"(if \" + (this.build(n.left())) + \" then \" + (this.build(n.children[1])) + \" else \" + (this.build(n.children[2])) + \")\");\n    };\n\n    Builder.prototype['for'] = function(n) {\n      var c;\n      c = new Code;\n      if (n.setup != null) {\n        c.add(\"\" + (this.build(n.setup)) + \"\\n\");\n      }\n      if (n.condition != null) {\n        c.add(\"while \" + (this.build(n.condition)) + \"\\n\");\n      } else {\n        c.add(\"loop\");\n      }\n      c.scope(this.body(n.body));\n      if (n.update != null) {\n        c.scope(this.body(n.update));\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['for_in'] = function(n) {\n      var c;\n      c = new Code;\n      c.add(\"for \" + (this.build(n.iterator)) + \" of \" + (this.build(n.object)));\n      if (n.body.children.length > 0) {\n        c.scope(this.body(n.body));\n      } else {\n        c.scope(\"continue\");\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['while'] = function(n) {\n      var body_, c, keyword, statement;\n      c = new Code;\n      keyword = n.positive ? \"while\" : \"until\";\n      body_ = this.body(n.body);\n      if (truthy(n.condition)) {\n        statement = \"loop\";\n      } else {\n        statement = \"\" + keyword + \" \" + (this.build(n.condition));\n      }\n      if (isSingleLine(body_) && statement !== \"loop\") {\n        c.add(\"\" + (trim(body_)) + Code.INDENT + statement + \"\\n\");\n      } else {\n        c.add(statement);\n        c.scope(body_);\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['do'] = function(n) {\n      var c;\n      c = new Code;\n      c.add(\"loop\");\n      c.scope(this.body(n.body));\n      if (n.condition != null) {\n        c.scope(\"break unless \" + (this.build(n.condition)));\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['if'] = function(n) {\n      var body_, c, keyword;\n      c = new Code;\n      keyword = n.positive ? \"if\" : \"unless\";\n      body_ = this.body(n.thenPart);\n      n.condition.parenthesized = false;\n      if (n.thenPart.isA('block') && n.thenPart.children.length === 0 && (n.elsePart == null)) {\n        console.log(n.thenPart);\n        c.add(\"\" + (this.build(n.condition)) + \"\\n\");\n      } else if (isSingleLine(body_) && (n.elsePart == null)) {\n        c.add(\"\" + (trim(body_)) + Code.INDENT + keyword + \" \" + (this.build(n.condition)) + \"\\n\");\n      } else {\n        c.add(\"\" + keyword + \" \" + (this.build(n.condition)));\n        c.scope(this.body(n.thenPart));\n        if (n.elsePart != null) {\n          if (n.elsePart.typeName() === 'if') {\n            c.add(\"else \" + (this.build(n.elsePart).toString()));\n          } else {\n            c.add(this.l(n.elsePart) + \"else\\n\");\n            c.scope(this.body(n.elsePart));\n          }\n        }\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['switch'] = function(n) {\n      var c, fall_through,\n        _this = this;\n      c = new Code;\n      c.add(\"switch \" + (this.build(n.discriminant)) + \"\\n\");\n      fall_through = false;\n      _.each(n.cases, function(item) {\n        var first;\n        if (item.value === 'default') {\n          c.scope(_this.l(item) + \"else\");\n        } else {\n          if (fall_through === true) {\n            c.add(_this.l(item) + (\", \" + (_this.build(item.caseLabel)) + \"\\n\"));\n          } else {\n            c.add(_this.l(item) + (\"  when \" + (_this.build(item.caseLabel))));\n          }\n        }\n        if (_this.body(item.statements).length === 0) {\n          fall_through = true;\n        } else {\n          fall_through = false;\n          c.add(\"\\n\");\n          c.scope(_this.body(item.statements), 2);\n        }\n        return first = false;\n      });\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['existence_check'] = function(n) {\n      return this.l(n) + (\"\" + (this.build(n.left())) + \"?\");\n    };\n\n    Builder.prototype['array_init'] = function(n) {\n      var options;\n      options = {\n        array: true\n      };\n      if (n.children.length === 0) {\n        return this.l(n) + \"[]\";\n      } else if (n.children.length > 1) {\n        return this.l(n) + (\"[\" + (this.list(n, options)) + \"\\n]\");\n      } else {\n        return this.l(n) + (\"[\" + (this.list(n)) + \"]\");\n      }\n    };\n\n    Builder.prototype['property_init'] = function(n) {\n      var left, right;\n      left = n.left();\n      right = n.right();\n      right.is_property_value = true;\n      return \"\" + (this.property_identifier(left)) + \": \" + (this.build(right));\n    };\n\n    Builder.prototype['object_init'] = function(n, options) {\n      var c, list,\n        _this = this;\n      if (options == null) {\n        options = {};\n      }\n      if (n.children.length === 0) {\n        return this.l(n) + \"{}\";\n      } else if (n.children.length === 1 && !(n.is_property_value || n.is_list_element)) {\n        return this.build(n.children[0]);\n      } else {\n        list = _.map(n.children, function(item) {\n          return _this.build(item);\n        });\n        c = new Code(this, n);\n        c.scope(list.join(\"\\n\"));\n        if (options.brackets != null) {\n          c = \"{\" + c + \"}\";\n        }\n        return c;\n      }\n    };\n\n    Builder.prototype['function'] = function(n) {\n      var body, c, params,\n        _this = this;\n      c = new Code;\n      params = _.map(n.params, function(str) {\n        if (str.constructor === String) {\n          return _this.id_param(str);\n        } else {\n          return _this.build(str);\n        }\n      });\n      if (n.name) {\n        c.add(\"\" + n.name + \" = \");\n      }\n      if (n.params.length > 0) {\n        c.add(\"(\" + (params.join(', ')) + \") ->\");\n      } else {\n        c.add(\"->\");\n      }\n      body = this.body(n.body);\n      if (trim(body).length > 0) {\n        c.scope(body);\n      } else {\n        c.add(\"\\n\");\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['var'] = function(n) {\n      var list,\n        _this = this;\n      list = _.map(n.children, function(item) {\n        return \"\" + (unreserve(item.value)) + \" = \" + (item.initializer != null ? _this.build(item.initializer) : 'undefined');\n      });\n      return this.l(n) + _.compact(list).join(\"\\n\") + \"\\n\";\n    };\n\n    Builder.prototype['other'] = function(n) {\n      return this.unsupported(n, \"\" + (n.typeName()) + \" is not supported yet\");\n    };\n\n    Builder.prototype['getter'] = function(n) {\n      return this.unsupported(n, \"getter syntax is not supported; use __defineGetter__\");\n    };\n\n    Builder.prototype['setter'] = function(n) {\n      return this.unsupported(n, \"setter syntax is not supported; use __defineSetter__\");\n    };\n\n    Builder.prototype['label'] = function(n) {\n      return this.unsupported(n, \"labels are not supported by CoffeeScript\");\n    };\n\n    Builder.prototype['const'] = function(n) {\n      return this.unsupported(n, \"consts are not supported by CoffeeScript\");\n    };\n\n    Builder.prototype['block'] = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return this.script.apply(this, args);\n    };\n\n    Builder.prototype['unsupported'] = function(node, message) {\n      throw new UnsupportedError(\"Unsupported: \" + message, node);\n    };\n\n    return Builder;\n\n  })();\n\n  Transformer = (function() {\n    function Transformer() {}\n\n    Transformer.prototype.transform = function() {\n      var args, fn, node, type;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      node = args[0];\n      if (node.transformed != null) {\n        return;\n      }\n      type = node.typeName();\n      fn = this[type];\n      if (fn) {\n        fn.apply(this, args);\n        return node.transformed = true;\n      }\n    };\n\n    Transformer.prototype['script'] = function(n) {\n      var last,\n        _this = this;\n      n.functions = [];\n      n.nonfunctions = [];\n      _.each(n.children, function(item) {\n        if (item.isA('function')) {\n          return n.functions.push(item);\n        } else {\n          return n.nonfunctions.push(item);\n        }\n      });\n      last = null;\n      return _.each(n.nonfunctions, function(item) {\n        var expr;\n        if (item.expression != null) {\n          expr = item.expression;\n          if ((last != null ? last.isA('object_init') : void 0) && expr.isA('object_init')) {\n            item.parenthesized = true;\n          } else {\n            item.parenthesized = false;\n          }\n          return last = expr;\n        }\n      });\n    };\n\n    Transformer.prototype['.'] = function(n) {\n      if (n.left().isA('function')) {\n        n.left().parenthesized = true;\n      }\n      n.isThis = n.left().isA('this');\n      return n.isPrototype = n.right().isA('identifier') && n.right().value === 'prototype';\n    };\n\n    Transformer.prototype[';'] = function(n) {\n      if (n.expression != null) {\n        n.expression.parenthesized = false;\n        if (n.expression.isA('call')) {\n          n.expression.type = Typenames['call_statement'];\n          return this.call_statement(n);\n        }\n      }\n    };\n\n    Transformer.prototype['function'] = function(n) {\n      var nonreturns, transform_switch;\n      nonreturns = 0;\n      transform_switch = this[\"switch\"];\n      n.body.walk({\n        last: true\n      }, function(parent, node, list) {\n        var lastNode;\n        if (node.isA('switch')) {\n          transform_switch(node);\n        }\n        lastNode = list ? parent[list] : parent.children[parent.children.length - 1];\n        if (node.value && lastNode) {\n          if (node.isA('return')) {\n            lastNode.type = Typenames[';'];\n            return lastNode.expression = lastNode.value;\n          } else if (lastNode.isA('if', 'switch', 'block')) {\n\n          } else {\n            return nonreturns += 1;\n          }\n        }\n      });\n      if (nonreturns > 0) {\n        return n.body.children.push({\n          type: 'return',\n          typeName: function() {\n            return this.type;\n          },\n          isA: function(t) {\n            return t === this.type;\n          }\n        });\n      }\n    };\n\n    Transformer.prototype['switch'] = function(n) {\n      var _this = this;\n      return _.each(n.cases, function(item) {\n        var block, ch, _ref2;\n        block = item.statements;\n        ch = block.children;\n        if ((_ref2 = block.last()) != null ? _ref2.isA('break') : void 0) {\n          return delete ch[ch.length - 1];\n        }\n      });\n    };\n\n    Transformer.prototype['call_statement'] = function(n) {\n      if (n.children[1]) {\n        return _.each(n.children[1].children, function(child, i) {\n          if (child.isA('function') && i !== n.children[1].children.length - 1) {\n            return child.parenthesized = true;\n          }\n        });\n      }\n    };\n\n    Transformer.prototype['return'] = function(n) {\n      if (n.value && n.value.isA('object_init') && n.value.children.length > 1) {\n        return n.value.parenthesized = true;\n      }\n    };\n\n    Transformer.prototype['block'] = function(n) {\n      return this.script(n);\n    };\n\n    Transformer.prototype['if'] = function(n) {\n      var _ref2;\n      if (n.thenPart.isA('block') && n.thenPart.children.length === 0 && (!n.elsePartisA('block') || ((_ref2 = n.elsePart) != null ? _ref2.children.length : void 0) > 0)) {\n        n.positive = false;\n        n.thenPart = n.elsePart;\n        delete n.elsePart;\n      }\n      return this.inversible(n);\n    };\n\n    Transformer.prototype['while'] = function(n) {\n      if (n.body.children.length === 0) {\n        n.body.children.push(n.clone({\n          type: Typenames['continue'],\n          value: 'continue',\n          children: []\n        }));\n      }\n      return this.inversible(n);\n    };\n\n    Transformer.prototype['inversible'] = function(n) {\n      var positive;\n      this.transform(n.condition);\n      positive = n.positive != null ? n.positive : true;\n      if (n.condition.isA('!=')) {\n        n.condition.type = Typenames['=='];\n        return n.positive = !positive;\n      } else if (n.condition.isA('!')) {\n        n.condition = n.condition.left();\n        return n.positive = !positive;\n      } else {\n        return n.positive = positive;\n      }\n    };\n\n    Transformer.prototype['=='] = function(n) {\n      if (n.right().isA('null', 'void')) {\n        n.type = Typenames['!'];\n        return n.children = [\n          n.clone({\n            type: Typenames['existence_check'],\n            children: [n.left()]\n          })\n        ];\n      }\n    };\n\n    Transformer.prototype['!='] = function(n) {\n      if (n.right().isA('null', 'void')) {\n        n.type = Typenames['existence_check'];\n        return n.children = [n.left()];\n      }\n    };\n\n    return Transformer;\n\n  })();\n\n  UnsupportedError = (function() {\n    function UnsupportedError(str, src) {\n      this.message = str;\n      this.cursor = src.start;\n      this.line = src.lineno;\n      this.source = src.tokenizer.source;\n    }\n\n    UnsupportedError.prototype.toString = function() {\n      return this.message;\n    };\n\n    return UnsupportedError;\n\n  })();\n\n  this.Js2coffee = exports = {\n    VERSION: pkg.version,\n    build: buildCoffee,\n    UnsupportedError: UnsupportedError\n  };\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = exports;\n  }\n\n}).call(this);\n",
      "contentRenderedWithoutLayouts": "(function() {\n  var Builder, Code, Node, Transformer, Typenames, Types, UnsupportedError, blockTrim, buildCoffee, exports, indentLines, isSingleLine, ltrim, p, paren, parser, pkg, rtrim, strEscape, strEscapeDoubleQuotes, strEscapeSingleQuotes, strRepeat, trim, truthy, unreserve, unshift, _, _ref, _ref1,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice,\n    __hasProp = {}.hasOwnProperty;\n\n  _ = require('underscore');\n\n  pkg = require('../../package.json');\n\n  parser = require('./narcissus_packed').parser;\n\n  _ref = require('./node_ext'), Types = _ref.Types, Typenames = _ref.Typenames, Node = _ref.Node;\n\n  _ref1 = require('./helpers'), Code = _ref1.Code, p = _ref1.p, strEscapeDoubleQuotes = _ref1.strEscapeDoubleQuotes, strEscapeSingleQuotes = _ref1.strEscapeSingleQuotes, unreserve = _ref1.unreserve, unshift = _ref1.unshift, isSingleLine = _ref1.isSingleLine, trim = _ref1.trim, blockTrim = _ref1.blockTrim, ltrim = _ref1.ltrim, rtrim = _ref1.rtrim, strRepeat = _ref1.strRepeat, paren = _ref1.paren, truthy = _ref1.truthy, indentLines = _ref1.indentLines;\n\n  strEscape = void 0;\n\n  buildCoffee = function(str, opts) {\n    var builder, comments, indent, keepLineNumbers, l, line, minline, output, precomments, res, scriptNode, srclines, text, _i, _len, _ref2;\n    if (opts == null) {\n      opts = {};\n    }\n    str = str.replace(/\\r/g, '');\n    str += \"\\n\";\n    if (opts.indent != null) {\n      Code.INDENT = opts.indent;\n    }\n    if ((opts.single_quotes != null) && opts.single_quotes === true) {\n      console.log(opts.single_quotes);\n      strEscape = strEscapeSingleQuotes;\n    } else {\n      strEscape = strEscapeDoubleQuotes;\n    }\n    builder = new Builder(opts);\n    scriptNode = parser.parse(str);\n    output = trim(builder.build(scriptNode));\n    if (opts.no_comments) {\n      return ((function() {\n        var _i, _len, _ref2, _results;\n        _ref2 = output.split('\\n');\n        _results = [];\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          line = _ref2[_i];\n          _results.push(rtrim(line));\n        }\n        return _results;\n      })()).join('\\n');\n    } else {\n      keepLineNumbers = opts.show_src_lineno;\n      res = [];\n      _ref2 = output.split(\"\\n\");\n      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n        l = _ref2[_i];\n        srclines = [];\n        text = l.replace(/\\uFEFE([0-9]+).*?\\uFEFE/g, function(m, g) {\n          srclines.push(parseInt(g));\n          return \"\";\n        });\n        srclines = _.sortBy(_.uniq(srclines), function(i) {\n          return i;\n        });\n        text = rtrim(text);\n        indent = text.match(/^\\s*/);\n        if (srclines.length > 0) {\n          minline = _.last(srclines);\n          precomments = builder.commentsNotDoneTo(minline);\n          if (precomments) {\n            res.push(indentLines(indent, precomments));\n          }\n        }\n        if (text) {\n          if (keepLineNumbers) {\n            text = text + \"#\" + srclines.join(\",\") + \"#  \";\n          }\n          res.push(rtrim(text + \" \" + ltrim(builder.lineComments(srclines))));\n        } else {\n          res.push(\"\");\n        }\n      }\n      comments = builder.commentsNotDoneTo(1e10);\n      if (comments) {\n        res.push(comments);\n      }\n      return res.join(\"\\n\");\n    }\n  };\n\n  Builder = (function() {\n    function Builder(options) {\n      this.options = options != null ? options : {};\n      this.transformer = new Transformer;\n    }\n\n    Builder.prototype.l = function(n) {\n      if (this.options.no_comments) {\n        return '';\n      }\n      if (n && n.lineno) {\n        return \"\\uFEFE\" + n.lineno + \"\\uFEFE\";\n      } else {\n        return \"\";\n      }\n    };\n\n    Builder.prototype.makeComment = function(comment) {\n      var c, line;\n      if (comment.type === \"BLOCK_COMMENT\") {\n        c = comment.value.split(\"\\n\");\n        if (c.length > 0 && c[0].length > 0 && c[0][0] === \"*\") {\n          c = (function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = c.length; _i < _len; _i++) {\n              line = c[_i];\n              _results.push(line.replace(/^[\\s\\*]*/, ''));\n            }\n            return _results;\n          })();\n          c = (function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = c.length; _i < _len; _i++) {\n              line = c[_i];\n              _results.push(line.replace(/[\\s]*$/, ''));\n            }\n            return _results;\n          })();\n          while (c.length > 0 && c[0].length === 0) {\n            c.shift();\n          }\n          while (c.length > 0 && c[c.length - 1].length === 0) {\n            c.pop();\n          }\n          c.unshift('###');\n          c.push('###');\n        } else {\n          c = (function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = c.length; _i < _len; _i++) {\n              line = c[_i];\n              _results.push(\"#\" + line);\n            }\n            return _results;\n          })();\n        }\n      } else {\n        c = ['#' + comment.value];\n      }\n      if (comment.nlcount > 0) {\n        c.unshift('');\n      }\n      return c.join('\\n');\n    };\n\n    Builder.prototype.commentsNotDoneTo = function(lineno) {\n      var c, res;\n      res = [];\n      while (true) {\n        if (this.comments.length === 0) {\n          break;\n        }\n        c = this.comments[0];\n        if (c.lineno < lineno) {\n          res.push(this.makeComment(c));\n          this.comments.shift();\n          continue;\n        }\n        break;\n      }\n      return res.join(\"\\n\");\n    };\n\n    Builder.prototype.lineComments = function(linenos) {\n      var c, selection;\n      selection = (function() {\n        var _i, _len, _ref2, _ref3, _results;\n        _ref2 = this.comments;\n        _results = [];\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          c = _ref2[_i];\n          if (_ref3 = c.lineno, __indexOf.call(linenos, _ref3) >= 0) {\n            _results.push(c);\n          }\n        }\n        return _results;\n      }).call(this);\n      this.comments = _.difference(this.comments, selection);\n      return ((function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = selection.length; _i < _len; _i++) {\n          c = selection[_i];\n          _results.push(this.makeComment(c));\n        }\n        return _results;\n      }).call(this)).join(\"\\n\");\n    };\n\n    Builder.prototype.build = function() {\n      var args, fn, name, node, out;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      node = args[0];\n      if (this.comments == null) {\n        this.comments = _.sortBy(node.tokenizer.comments, function(n) {\n          return n.start;\n        });\n      }\n      this.transform(node);\n      name = 'other';\n      if (node !== void 0 && node.typeName) {\n        name = node.typeName();\n      }\n      fn = this[name] || this.other;\n      out = fn.apply(this, args);\n      if (node.parenthesized) {\n        return paren(out);\n      } else {\n        return out;\n      }\n    };\n\n    Builder.prototype.transform = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return this.transformer.transform.apply(this.transformer, args);\n    };\n\n    Builder.prototype.body = function(node, opts) {\n      var str;\n      if (opts == null) {\n        opts = {};\n      }\n      str = this.build(node, opts);\n      str = blockTrim(str);\n      str = unshift(str);\n      if (str.length > 0) {\n        return str;\n      } else {\n        return \"\";\n      }\n    };\n\n    Builder.prototype['script'] = function(n, opts) {\n      var c,\n        _this = this;\n      if (opts == null) {\n        opts = {};\n      }\n      c = new Code;\n      _.each(n.functions, function(item) {\n        return c.add(_this.build(item));\n      });\n      _.each(n.nonfunctions, function(item) {\n        return c.add(_this.build(item));\n      });\n      return c.toString();\n    };\n\n    Builder.prototype['property_identifier'] = function(n) {\n      var str;\n      str = n.value.toString();\n      if (str.match(/^([_\\$a-z][_\\$a-z0-9]*)$/i) || str.match(/^[0-9]+$/i)) {\n        return this.l(n) + str;\n      } else {\n        return this.l(n) + strEscape(str);\n      }\n    };\n\n    Builder.prototype['identifier'] = function(n) {\n      if (n.value === 'undefined') {\n        return this.l(n) + '`undefined`';\n      } else if (n.property_accessor) {\n        return this.l(n) + n.value.toString();\n      } else {\n        return this.l(n) + unreserve(n.value.toString());\n      }\n    };\n\n    Builder.prototype['number'] = function(n) {\n      return this.l(n) + (\"\" + (n.src()));\n    };\n\n    Builder.prototype['id'] = function(n) {\n      if (n.property_accessor) {\n        return this.l(n) + n;\n      } else {\n        return this.l(n) + unreserve(n);\n      }\n    };\n\n    Builder.prototype['id_param'] = function(n) {\n      var _ref2;\n      if ((_ref2 = n.toString()) === 'undefined') {\n        return this.l(n) + (\"\" + n + \"_\");\n      } else {\n        return this.l(n) + this.id(n);\n      }\n    };\n\n    Builder.prototype['return'] = function(n) {\n      if (n.value == null) {\n        return this.l(n) + \"return\\n\";\n      } else {\n        return this.l(n) + (\"return \" + (this.build(n.value)) + \"\\n\");\n      }\n    };\n\n    Builder.prototype[';'] = function(n) {\n      var src;\n      if (n.expression == null) {\n        return \"\";\n      } else if (n.expression.typeName() === 'object_init') {\n        src = this.object_init(n.expression);\n        if (n.parenthesized) {\n          return src;\n        } else {\n          return \"\" + (unshift(blockTrim(src))) + \"\\n\";\n        }\n      } else {\n        return this.build(n.expression) + \"\\n\";\n      }\n    };\n\n    Builder.prototype['new'] = function(n) {\n      return this.l(n) + (\"new \" + (this.build(n.left())));\n    };\n\n    Builder.prototype['new_with_args'] = function(n) {\n      return this.l(n) + (\"new \" + (this.build(n.left())) + \"(\" + (this.build(n.right())) + \")\");\n    };\n\n    Builder.prototype['unary_plus'] = function(n) {\n      return \"+\" + (this.build(n.left()));\n    };\n\n    Builder.prototype['unary_minus'] = function(n) {\n      return \"-\" + (this.build(n.left()));\n    };\n\n    Builder.prototype['this'] = function(n) {\n      return this.l(n) + 'this';\n    };\n\n    Builder.prototype['null'] = function(n) {\n      return this.l(n) + 'null';\n    };\n\n    Builder.prototype['true'] = function(n) {\n      return this.l(n) + 'true';\n    };\n\n    Builder.prototype['false'] = function(n) {\n      return this.l(n) + 'false';\n    };\n\n    Builder.prototype['void'] = function(n) {\n      return this.l(n) + 'undefined';\n    };\n\n    Builder.prototype['debugger'] = function(n) {\n      return this.l(n) + \"debugger\\n\";\n    };\n\n    Builder.prototype['break'] = function(n) {\n      return this.l(n) + \"break\\n\";\n    };\n\n    Builder.prototype['continue'] = function(n) {\n      return this.l(n) + \"continue\\n\";\n    };\n\n    Builder.prototype['~'] = function(n) {\n      return \"~\" + (this.build(n.left()));\n    };\n\n    Builder.prototype['typeof'] = function(n) {\n      return this.l(n) + (\"typeof \" + (this.build(n.left())));\n    };\n\n    Builder.prototype['index'] = function(n) {\n      var right;\n      right = this.build(n.right());\n      if (_.any(n.children, function(child) {\n        return child.typeName() === 'object_init' && child.children.length > 1;\n      })) {\n        right = \"{\" + right + \"}\";\n      }\n      return this.l(n) + (\"\" + (this.build(n.left())) + \"[\" + right + \"]\");\n    };\n\n    Builder.prototype['throw'] = function(n) {\n      return this.l(n) + (\"throw \" + (this.build(n.exception)));\n    };\n\n    Builder.prototype['!'] = function(n) {\n      var negations, target;\n      target = n.left();\n      negations = 1;\n      while ((target.isA('!')) && (target = target.left())) {\n        ++negations;\n      }\n      if ((negations & 1) && target.isA('==', '!=', '===', '!==', 'in', 'instanceof')) {\n        target.negated = !target.negated;\n        return this.build(target);\n      }\n      return this.l(n) + (\"\" + (negations & 1 ? 'not ' : '!!') + (this.build(target)));\n    };\n\n    Builder.prototype[\"in\"] = function(n) {\n      return this.binary_operator(n, 'of');\n    };\n\n    Builder.prototype['+'] = function(n) {\n      return this.binary_operator(n, '+');\n    };\n\n    Builder.prototype['-'] = function(n) {\n      return this.binary_operator(n, '-');\n    };\n\n    Builder.prototype['*'] = function(n) {\n      return this.binary_operator(n, '*');\n    };\n\n    Builder.prototype['/'] = function(n) {\n      return this.binary_operator(n, '/');\n    };\n\n    Builder.prototype['%'] = function(n) {\n      return this.binary_operator(n, '%');\n    };\n\n    Builder.prototype['>'] = function(n) {\n      return this.binary_operator(n, '>');\n    };\n\n    Builder.prototype['<'] = function(n) {\n      return this.binary_operator(n, '<');\n    };\n\n    Builder.prototype['&'] = function(n) {\n      return this.binary_operator(n, '&');\n    };\n\n    Builder.prototype['|'] = function(n) {\n      return this.binary_operator(n, '|');\n    };\n\n    Builder.prototype['^'] = function(n) {\n      return this.binary_operator(n, '^');\n    };\n\n    Builder.prototype['&&'] = function(n) {\n      return this.binary_operator(n, 'and');\n    };\n\n    Builder.prototype['||'] = function(n) {\n      return this.binary_operator(n, 'or');\n    };\n\n    Builder.prototype['<<'] = function(n) {\n      return this.binary_operator(n, '<<');\n    };\n\n    Builder.prototype['<='] = function(n) {\n      return this.binary_operator(n, '<=');\n    };\n\n    Builder.prototype['>>'] = function(n) {\n      return this.binary_operator(n, '>>');\n    };\n\n    Builder.prototype['>='] = function(n) {\n      return this.binary_operator(n, '>=');\n    };\n\n    Builder.prototype['==='] = function(n) {\n      return this.binary_operator(n, 'is');\n    };\n\n    Builder.prototype['!=='] = function(n) {\n      return this.binary_operator(n, 'isnt');\n    };\n\n    Builder.prototype['>>>'] = function(n) {\n      return this.binary_operator(n, '>>>');\n    };\n\n    Builder.prototype[\"instanceof\"] = function(n) {\n      return this.binary_operator(n, 'instanceof');\n    };\n\n    Builder.prototype['=='] = function(n) {\n      return this.binary_operator(n, 'is');\n    };\n\n    Builder.prototype['!='] = function(n) {\n      return this.binary_operator(n, 'isnt');\n    };\n\n    Builder.prototype['binary_operator'] = (function() {\n      var INVERSIONS, k, v;\n      INVERSIONS = {\n        is: 'isnt',\n        \"in\": 'not in',\n        of: 'not of',\n        \"instanceof\": 'not instanceof'\n      };\n      for (k in INVERSIONS) {\n        if (!__hasProp.call(INVERSIONS, k)) continue;\n        v = INVERSIONS[k];\n        INVERSIONS[v] = k;\n      }\n      return function(n, sign) {\n        if (n.negated) {\n          sign = INVERSIONS[sign];\n        }\n        return this.l(n) + (\"\" + (this.build(n.left())) + \" \" + sign + \" \" + (this.build(n.right())));\n      };\n    })();\n\n    Builder.prototype['--'] = function(n) {\n      return this.increment_decrement(n, '--');\n    };\n\n    Builder.prototype['++'] = function(n) {\n      return this.increment_decrement(n, '++');\n    };\n\n    Builder.prototype['increment_decrement'] = function(n, sign) {\n      if (n.postfix) {\n        return this.l(n) + (\"\" + (this.build(n.left())) + sign);\n      } else {\n        return this.l(n) + (\"\" + sign + (this.build(n.left())));\n      }\n    };\n\n    Builder.prototype['='] = function(n) {\n      var sign;\n      sign = n.assignOp != null ? Types[n.assignOp] + '=' : '=';\n      return this.l(n) + (\"\" + (this.build(n.left())) + \" \" + sign + \" \" + (this.build(n.right())));\n    };\n\n    Builder.prototype[','] = function(n) {\n      var list,\n        _this = this;\n      list = _.map(n.children, function(item) {\n        return _this.l(item) + _this.build(item) + \"\\n\";\n      });\n      return list.join('');\n    };\n\n    Builder.prototype['regexp'] = function(n) {\n      var begins_with, flag, m, value;\n      m = n.value.toString().match(/^\\/(.*)\\/([a-z]?)/);\n      value = m[1];\n      flag = m[2];\n      begins_with = value[0];\n      if (begins_with === ' ' || begins_with === '=') {\n        if (flag.length > 0) {\n          return this.l(n) + (\"RegExp(\" + (strEscape(value)) + \", \\\"\" + flag + \"\\\")\");\n        } else {\n          return this.l(n) + (\"RegExp(\" + (strEscape(value)) + \")\");\n        }\n      } else {\n        return this.l(n) + (\"/\" + value + \"/\" + flag);\n      }\n    };\n\n    Builder.prototype['string'] = function(n) {\n      return this.l(n) + strEscape(n.value);\n    };\n\n    Builder.prototype['call'] = function(n) {\n      if (n.right().children.length === 0) {\n        return (\"\" + (this.build(n.left())) + \"()\") + this.l(n);\n      } else {\n        return (\"\" + (this.build(n.left())) + \"(\" + (this.build(n.right())) + \")\") + this.l(n);\n      }\n    };\n\n    Builder.prototype['call_statement'] = function(n) {\n      var left;\n      left = this.build(n.left());\n      if (n.left().isA('function')) {\n        left = paren(left);\n      }\n      if (n.right().children.length === 0) {\n        return (\"\" + left + \"()\") + this.l(n);\n      } else {\n        return (\"\" + left + \" \" + (this.build(n.right()))) + this.l(n);\n      }\n    };\n\n    Builder.prototype['list'] = function(n, options) {\n      var list,\n        _this = this;\n      if (options == null) {\n        options = {};\n      }\n      list = _.map(n.children, function(item) {\n        var c, raw;\n        if (n.children.length > 1) {\n          item.is_list_element = true;\n        }\n        if (options.array === true && n.children.length > 0) {\n          raw = _this[item.typeName()](item);\n          c = new Code(_this, item);\n          c.scope(raw);\n          c = trim(c + Code.INDENT);\n          if (item.typeName() === 'object_init') {\n            c = \"{\\n\" + Code.INDENT + Code.INDENT + c + \"\\n\" + Code.INDENT + \"}\";\n          }\n          return c;\n        } else {\n          return _this.build(item);\n        }\n      });\n      if (options.array === true && n.children.length > 0) {\n        return this.l(n) + (\"\\n\" + Code.INDENT + (list.join('\\n' + Code.INDENT)));\n      } else {\n        return this.l(n) + list.join(\", \");\n      }\n    };\n\n    Builder.prototype['delete'] = function(n) {\n      var ids,\n        _this = this;\n      ids = _.map(n.children, function(el) {\n        return _this.build(el);\n      });\n      ids = ids.join(', ');\n      return this.l(n) + (\"delete \" + ids + \"\\n\");\n    };\n\n    Builder.prototype['.'] = function(n) {\n      var left, right, right_obj;\n      left = this.build(n.left());\n      right_obj = n.right();\n      right_obj.property_accessor = true;\n      right = this.build(right_obj);\n      if (n.isThis && n.isPrototype) {\n        return this.l(n) + \"@::\";\n      } else if (n.isThis) {\n        return this.l(n) + (\"@\" + right);\n      } else if (n.isPrototype) {\n        return this.l(n) + (\"\" + left + \"::\");\n      } else if (n.left().isPrototype) {\n        return this.l(n) + (\"\" + left + right);\n      } else {\n        return this.l(n) + (\"\" + left + \".\" + right);\n      }\n    };\n\n    Builder.prototype['try'] = function(n) {\n      var c,\n        _this = this;\n      c = new Code;\n      c.add('try');\n      c.scope(this.body(n.tryBlock));\n      _.each(n.catchClauses, function(clause) {\n        return c.add(_this.build(clause));\n      });\n      if (n.finallyBlock != null) {\n        c.add(\"finally\");\n        c.scope(this.body(n.finallyBlock));\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['catch'] = function(n) {\n      var body_, c;\n      body_ = this.body(n.block);\n      if (trim(body_).length === 0) {\n        return '';\n      }\n      c = new Code;\n      if (n.varName != null) {\n        c.add(\"catch \" + n.varName);\n      } else {\n        c.add('catch');\n      }\n      c.scope(this.body(n.block));\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['?'] = function(n) {\n      return this.l(n) + (\"(if \" + (this.build(n.left())) + \" then \" + (this.build(n.children[1])) + \" else \" + (this.build(n.children[2])) + \")\");\n    };\n\n    Builder.prototype['for'] = function(n) {\n      var c;\n      c = new Code;\n      if (n.setup != null) {\n        c.add(\"\" + (this.build(n.setup)) + \"\\n\");\n      }\n      if (n.condition != null) {\n        c.add(\"while \" + (this.build(n.condition)) + \"\\n\");\n      } else {\n        c.add(\"loop\");\n      }\n      c.scope(this.body(n.body));\n      if (n.update != null) {\n        c.scope(this.body(n.update));\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['for_in'] = function(n) {\n      var c;\n      c = new Code;\n      c.add(\"for \" + (this.build(n.iterator)) + \" of \" + (this.build(n.object)));\n      if (n.body.children.length > 0) {\n        c.scope(this.body(n.body));\n      } else {\n        c.scope(\"continue\");\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['while'] = function(n) {\n      var body_, c, keyword, statement;\n      c = new Code;\n      keyword = n.positive ? \"while\" : \"until\";\n      body_ = this.body(n.body);\n      if (truthy(n.condition)) {\n        statement = \"loop\";\n      } else {\n        statement = \"\" + keyword + \" \" + (this.build(n.condition));\n      }\n      if (isSingleLine(body_) && statement !== \"loop\") {\n        c.add(\"\" + (trim(body_)) + Code.INDENT + statement + \"\\n\");\n      } else {\n        c.add(statement);\n        c.scope(body_);\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['do'] = function(n) {\n      var c;\n      c = new Code;\n      c.add(\"loop\");\n      c.scope(this.body(n.body));\n      if (n.condition != null) {\n        c.scope(\"break unless \" + (this.build(n.condition)));\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['if'] = function(n) {\n      var body_, c, keyword;\n      c = new Code;\n      keyword = n.positive ? \"if\" : \"unless\";\n      body_ = this.body(n.thenPart);\n      n.condition.parenthesized = false;\n      if (n.thenPart.isA('block') && n.thenPart.children.length === 0 && (n.elsePart == null)) {\n        console.log(n.thenPart);\n        c.add(\"\" + (this.build(n.condition)) + \"\\n\");\n      } else if (isSingleLine(body_) && (n.elsePart == null)) {\n        c.add(\"\" + (trim(body_)) + Code.INDENT + keyword + \" \" + (this.build(n.condition)) + \"\\n\");\n      } else {\n        c.add(\"\" + keyword + \" \" + (this.build(n.condition)));\n        c.scope(this.body(n.thenPart));\n        if (n.elsePart != null) {\n          if (n.elsePart.typeName() === 'if') {\n            c.add(\"else \" + (this.build(n.elsePart).toString()));\n          } else {\n            c.add(this.l(n.elsePart) + \"else\\n\");\n            c.scope(this.body(n.elsePart));\n          }\n        }\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['switch'] = function(n) {\n      var c, fall_through,\n        _this = this;\n      c = new Code;\n      c.add(\"switch \" + (this.build(n.discriminant)) + \"\\n\");\n      fall_through = false;\n      _.each(n.cases, function(item) {\n        var first;\n        if (item.value === 'default') {\n          c.scope(_this.l(item) + \"else\");\n        } else {\n          if (fall_through === true) {\n            c.add(_this.l(item) + (\", \" + (_this.build(item.caseLabel)) + \"\\n\"));\n          } else {\n            c.add(_this.l(item) + (\"  when \" + (_this.build(item.caseLabel))));\n          }\n        }\n        if (_this.body(item.statements).length === 0) {\n          fall_through = true;\n        } else {\n          fall_through = false;\n          c.add(\"\\n\");\n          c.scope(_this.body(item.statements), 2);\n        }\n        return first = false;\n      });\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['existence_check'] = function(n) {\n      return this.l(n) + (\"\" + (this.build(n.left())) + \"?\");\n    };\n\n    Builder.prototype['array_init'] = function(n) {\n      var options;\n      options = {\n        array: true\n      };\n      if (n.children.length === 0) {\n        return this.l(n) + \"[]\";\n      } else if (n.children.length > 1) {\n        return this.l(n) + (\"[\" + (this.list(n, options)) + \"\\n]\");\n      } else {\n        return this.l(n) + (\"[\" + (this.list(n)) + \"]\");\n      }\n    };\n\n    Builder.prototype['property_init'] = function(n) {\n      var left, right;\n      left = n.left();\n      right = n.right();\n      right.is_property_value = true;\n      return \"\" + (this.property_identifier(left)) + \": \" + (this.build(right));\n    };\n\n    Builder.prototype['object_init'] = function(n, options) {\n      var c, list,\n        _this = this;\n      if (options == null) {\n        options = {};\n      }\n      if (n.children.length === 0) {\n        return this.l(n) + \"{}\";\n      } else if (n.children.length === 1 && !(n.is_property_value || n.is_list_element)) {\n        return this.build(n.children[0]);\n      } else {\n        list = _.map(n.children, function(item) {\n          return _this.build(item);\n        });\n        c = new Code(this, n);\n        c.scope(list.join(\"\\n\"));\n        if (options.brackets != null) {\n          c = \"{\" + c + \"}\";\n        }\n        return c;\n      }\n    };\n\n    Builder.prototype['function'] = function(n) {\n      var body, c, params,\n        _this = this;\n      c = new Code;\n      params = _.map(n.params, function(str) {\n        if (str.constructor === String) {\n          return _this.id_param(str);\n        } else {\n          return _this.build(str);\n        }\n      });\n      if (n.name) {\n        c.add(\"\" + n.name + \" = \");\n      }\n      if (n.params.length > 0) {\n        c.add(\"(\" + (params.join(', ')) + \") ->\");\n      } else {\n        c.add(\"->\");\n      }\n      body = this.body(n.body);\n      if (trim(body).length > 0) {\n        c.scope(body);\n      } else {\n        c.add(\"\\n\");\n      }\n      return this.l(n) + c;\n    };\n\n    Builder.prototype['var'] = function(n) {\n      var list,\n        _this = this;\n      list = _.map(n.children, function(item) {\n        return \"\" + (unreserve(item.value)) + \" = \" + (item.initializer != null ? _this.build(item.initializer) : 'undefined');\n      });\n      return this.l(n) + _.compact(list).join(\"\\n\") + \"\\n\";\n    };\n\n    Builder.prototype['other'] = function(n) {\n      return this.unsupported(n, \"\" + (n.typeName()) + \" is not supported yet\");\n    };\n\n    Builder.prototype['getter'] = function(n) {\n      return this.unsupported(n, \"getter syntax is not supported; use __defineGetter__\");\n    };\n\n    Builder.prototype['setter'] = function(n) {\n      return this.unsupported(n, \"setter syntax is not supported; use __defineSetter__\");\n    };\n\n    Builder.prototype['label'] = function(n) {\n      return this.unsupported(n, \"labels are not supported by CoffeeScript\");\n    };\n\n    Builder.prototype['const'] = function(n) {\n      return this.unsupported(n, \"consts are not supported by CoffeeScript\");\n    };\n\n    Builder.prototype['block'] = function() {\n      var args;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return this.script.apply(this, args);\n    };\n\n    Builder.prototype['unsupported'] = function(node, message) {\n      throw new UnsupportedError(\"Unsupported: \" + message, node);\n    };\n\n    return Builder;\n\n  })();\n\n  Transformer = (function() {\n    function Transformer() {}\n\n    Transformer.prototype.transform = function() {\n      var args, fn, node, type;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      node = args[0];\n      if (node.transformed != null) {\n        return;\n      }\n      type = node.typeName();\n      fn = this[type];\n      if (fn) {\n        fn.apply(this, args);\n        return node.transformed = true;\n      }\n    };\n\n    Transformer.prototype['script'] = function(n) {\n      var last,\n        _this = this;\n      n.functions = [];\n      n.nonfunctions = [];\n      _.each(n.children, function(item) {\n        if (item.isA('function')) {\n          return n.functions.push(item);\n        } else {\n          return n.nonfunctions.push(item);\n        }\n      });\n      last = null;\n      return _.each(n.nonfunctions, function(item) {\n        var expr;\n        if (item.expression != null) {\n          expr = item.expression;\n          if ((last != null ? last.isA('object_init') : void 0) && expr.isA('object_init')) {\n            item.parenthesized = true;\n          } else {\n            item.parenthesized = false;\n          }\n          return last = expr;\n        }\n      });\n    };\n\n    Transformer.prototype['.'] = function(n) {\n      if (n.left().isA('function')) {\n        n.left().parenthesized = true;\n      }\n      n.isThis = n.left().isA('this');\n      return n.isPrototype = n.right().isA('identifier') && n.right().value === 'prototype';\n    };\n\n    Transformer.prototype[';'] = function(n) {\n      if (n.expression != null) {\n        n.expression.parenthesized = false;\n        if (n.expression.isA('call')) {\n          n.expression.type = Typenames['call_statement'];\n          return this.call_statement(n);\n        }\n      }\n    };\n\n    Transformer.prototype['function'] = function(n) {\n      var nonreturns, transform_switch;\n      nonreturns = 0;\n      transform_switch = this[\"switch\"];\n      n.body.walk({\n        last: true\n      }, function(parent, node, list) {\n        var lastNode;\n        if (node.isA('switch')) {\n          transform_switch(node);\n        }\n        lastNode = list ? parent[list] : parent.children[parent.children.length - 1];\n        if (node.value && lastNode) {\n          if (node.isA('return')) {\n            lastNode.type = Typenames[';'];\n            return lastNode.expression = lastNode.value;\n          } else if (lastNode.isA('if', 'switch', 'block')) {\n\n          } else {\n            return nonreturns += 1;\n          }\n        }\n      });\n      if (nonreturns > 0) {\n        return n.body.children.push({\n          type: 'return',\n          typeName: function() {\n            return this.type;\n          },\n          isA: function(t) {\n            return t === this.type;\n          }\n        });\n      }\n    };\n\n    Transformer.prototype['switch'] = function(n) {\n      var _this = this;\n      return _.each(n.cases, function(item) {\n        var block, ch, _ref2;\n        block = item.statements;\n        ch = block.children;\n        if ((_ref2 = block.last()) != null ? _ref2.isA('break') : void 0) {\n          return delete ch[ch.length - 1];\n        }\n      });\n    };\n\n    Transformer.prototype['call_statement'] = function(n) {\n      if (n.children[1]) {\n        return _.each(n.children[1].children, function(child, i) {\n          if (child.isA('function') && i !== n.children[1].children.length - 1) {\n            return child.parenthesized = true;\n          }\n        });\n      }\n    };\n\n    Transformer.prototype['return'] = function(n) {\n      if (n.value && n.value.isA('object_init') && n.value.children.length > 1) {\n        return n.value.parenthesized = true;\n      }\n    };\n\n    Transformer.prototype['block'] = function(n) {\n      return this.script(n);\n    };\n\n    Transformer.prototype['if'] = function(n) {\n      var _ref2;\n      if (n.thenPart.isA('block') && n.thenPart.children.length === 0 && (!n.elsePartisA('block') || ((_ref2 = n.elsePart) != null ? _ref2.children.length : void 0) > 0)) {\n        n.positive = false;\n        n.thenPart = n.elsePart;\n        delete n.elsePart;\n      }\n      return this.inversible(n);\n    };\n\n    Transformer.prototype['while'] = function(n) {\n      if (n.body.children.length === 0) {\n        n.body.children.push(n.clone({\n          type: Typenames['continue'],\n          value: 'continue',\n          children: []\n        }));\n      }\n      return this.inversible(n);\n    };\n\n    Transformer.prototype['inversible'] = function(n) {\n      var positive;\n      this.transform(n.condition);\n      positive = n.positive != null ? n.positive : true;\n      if (n.condition.isA('!=')) {\n        n.condition.type = Typenames['=='];\n        return n.positive = !positive;\n      } else if (n.condition.isA('!')) {\n        n.condition = n.condition.left();\n        return n.positive = !positive;\n      } else {\n        return n.positive = positive;\n      }\n    };\n\n    Transformer.prototype['=='] = function(n) {\n      if (n.right().isA('null', 'void')) {\n        n.type = Typenames['!'];\n        return n.children = [\n          n.clone({\n            type: Typenames['existence_check'],\n            children: [n.left()]\n          })\n        ];\n      }\n    };\n\n    Transformer.prototype['!='] = function(n) {\n      if (n.right().isA('null', 'void')) {\n        n.type = Typenames['existence_check'];\n        return n.children = [n.left()];\n      }\n    };\n\n    return Transformer;\n\n  })();\n\n  UnsupportedError = (function() {\n    function UnsupportedError(str, src) {\n      this.message = str;\n      this.cursor = src.start;\n      this.line = src.lineno;\n      this.source = src.tokenizer.source;\n    }\n\n    UnsupportedError.prototype.toString = function() {\n      return this.message;\n    };\n\n    return UnsupportedError;\n\n  })();\n\n  this.Js2coffee = exports = {\n    VERSION: pkg.version,\n    build: buildCoffee,\n    UnsupportedError: UnsupportedError\n  };\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = exports;\n  }\n\n}).call(this);\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/lib/narcissus_packed.js",
      "relativePath": "lib/narcissus_packed.js",
      "basename": "narcissus_packed",
      "outBasename": "narcissus_packed",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "narcissus_packed.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/lib",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/lib/narcissus_packed.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/lib",
      "outFilename": "narcissus_packed.js",
      "relativeOutPath": "lib/narcissus_packed.js",
      "relativeDirPath": "lib",
      "relativeOutDirPath": "lib",
      "relativeBase": "lib/narcissus_packed",
      "relativeOutBase": "lib/narcissus_packed",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:18.271Z",
      "rtime": "2014-01-20T02:05:24.542Z",
      "wtime": "2014-01-20T02:05:25.715Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/* vim: set sw=4 ts=4 et tw=78: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (typeof module == 'undefined') {\n  this.Narcissus = new Object;\n}\n\nvar Narcissus = {\n    options: {\n        version: 185,\n    },\n    hostGlobal: this\n};\n\nNarcissus.definitions = (function() {\n\n    var tokens = [\n        // End of source.\n        \"END\",\n\n        // Operators and punctuators.  Some pair-wise order matters, e.g. (+, -)\n        // and (UNARY_PLUS, UNARY_MINUS).\n        \"\\n\", \";\",\n        \",\",\n        \"=\",\n        \"?\", \":\", \"CONDITIONAL\",\n        \"||\",\n        \"&&\",\n        \"|\",\n        \"^\",\n        \"&\",\n        \"==\", \"!=\", \"===\", \"!==\",\n        \"<\", \"<=\", \">=\", \">\",\n        \"<<\", \">>\", \">>>\",\n        \"+\", \"-\",\n        \"*\", \"/\", \"%\",\n        \"!\", \"~\", \"UNARY_PLUS\", \"UNARY_MINUS\",\n        \"++\", \"--\",\n        \".\",\n        \"[\", \"]\",\n        \"{\", \"}\",\n        \"(\", \")\",\n\n        // Nonterminal tree node type codes.\n        \"SCRIPT\", \"BLOCK\", \"LABEL\", \"FOR_IN\", \"CALL\", \"NEW_WITH_ARGS\", \"INDEX\",\n        \"ARRAY_INIT\", \"OBJECT_INIT\", \"PROPERTY_INIT\", \"GETTER\", \"SETTER\",\n        \"GROUP\", \"LIST\", \"LET_BLOCK\", \"ARRAY_COMP\", \"GENERATOR\", \"COMP_TAIL\",\n\n        // Terminals.\n        \"IDENTIFIER\", \"NUMBER\", \"STRING\", \"REGEXP\",\n\n        // Keywords.\n        \"break\",\n        \"case\", \"catch\", \"const\", \"continue\",\n        \"debugger\", \"default\", \"delete\", \"do\",\n        \"else\",\n        \"false\", \"finally\", \"for\", \"function\",\n        \"if\", \"in\", \"instanceof\",\n        \"let\",\n        \"new\", \"null\",\n        \"return\",\n        \"switch\",\n        \"this\", \"throw\", \"true\", \"try\", \"typeof\",\n        \"var\", \"void\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    var statementStartTokens = [\n        \"break\",\n        \"const\", \"continue\",\n        \"debugger\", \"do\",\n        \"for\",\n        \"if\",\n        \"return\",\n        \"switch\",\n        \"throw\", \"try\",\n        \"var\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    // Operator and punctuator mapping from token to tree node type name.\n    // NB: because the lexer doesn't backtrack, all token prefixes must themselves\n    // be valid tokens (e.g. !== is acceptable because its prefixes are the valid\n    // tokens != and !).\n    var opTypeNames = {\n        '\\n':   \"NEWLINE\",\n        ';':    \"SEMICOLON\",\n        ',':    \"COMMA\",\n        '?':    \"HOOK\",\n        ':':    \"COLON\",\n        '||':   \"OR\",\n        '&&':   \"AND\",\n        '|':    \"BITWISE_OR\",\n        '^':    \"BITWISE_XOR\",\n        '&':    \"BITWISE_AND\",\n        '===':  \"STRICT_EQ\",\n        '==':   \"EQ\",\n        '=':    \"ASSIGN\",\n        '!==':  \"STRICT_NE\",\n        '!=':   \"NE\",\n        '<<':   \"LSH\",\n        '<=':   \"LE\",\n        '<':    \"LT\",\n        '>>>':  \"URSH\",\n        '>>':   \"RSH\",\n        '>=':   \"GE\",\n        '>':    \"GT\",\n        '++':   \"INCREMENT\",\n        '--':   \"DECREMENT\",\n        '+':    \"PLUS\",\n        '-':    \"MINUS\",\n        '*':    \"MUL\",\n        '/':    \"DIV\",\n        '%':    \"MOD\",\n        '!':    \"NOT\",\n        '~':    \"BITWISE_NOT\",\n        '.':    \"DOT\",\n        '[':    \"LEFT_BRACKET\",\n        ']':    \"RIGHT_BRACKET\",\n        '{':    \"LEFT_CURLY\",\n        '}':    \"RIGHT_CURLY\",\n        '(':    \"LEFT_PAREN\",\n        ')':    \"RIGHT_PAREN\"\n    };\n\n    // Hash of keyword identifier to tokens index.  NB: we must null __proto__ to\n    // avoid toString, etc. namespace pollution.\n    var keywords = {__proto__: null};\n\n    // Define const END, etc., based on the token names.  Also map name to index.\n    var tokenIds = {};\n\n    // Building up a string to be eval'd in different contexts.\n    var consts = \"const \";\n    for (var i = 0, j = tokens.length; i < j; i++) {\n        if (i > 0)\n            consts += \", \";\n        var t = tokens[i];\n        var name;\n        if (/^[a-z]/.test(t)) {\n            name = t.toUpperCase();\n            keywords[t] = i;\n        } else {\n            name = (/^\\W/.test(t) ? opTypeNames[t] : t);\n        }\n        consts += name + \" = \" + i;\n        tokenIds[name] = i;\n        tokens[t] = i;\n    }\n    consts += \";\";\n\n    var isStatementStartCode = {__proto__: null};\n    for (i = 0, j = statementStartTokens.length; i < j; i++)\n        isStatementStartCode[keywords[statementStartTokens[i]]] = true;\n\n    // Map assignment operators to their indexes in the tokens array.\n    var assignOps = ['|', '^', '&', '<<', '>>', '>>>', '+', '-', '*', '/', '%'];\n\n    for (i = 0, j = assignOps.length; i < j; i++) {\n        t = assignOps[i];\n        assignOps[t] = tokens[t];\n    }\n\n    function defineGetter(obj, prop, fn, dontDelete, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { get: fn, configurable: !dontDelete, enumerable: !dontEnum });\n    }\n\n    function defineProperty(obj, prop, val, dontDelete, readOnly, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { value: val, writable: !readOnly, configurable: !dontDelete,\n                                enumerable: !dontEnum });\n    }\n\n    // Returns true if fn is a native function.  (Note: SpiderMonkey specific.)\n    function isNativeCode(fn) {\n        // Relies on the toString method to identify native code.\n        return ((typeof fn) === \"function\") && fn.toString().match(/\\[native code\\]/);\n    }\n\n    function getPropertyDescriptor(obj, name) {\n        while (obj) {\n            if (({}).hasOwnProperty.call(obj, name))\n                return Object.getOwnPropertyDescriptor(obj, name);\n            obj = Object.getPrototypeOf(obj);\n        }\n    }\n\n    function getOwnProperties(obj) {\n        var map = {};\n        for (var name in Object.getOwnPropertyNames(obj))\n            map[name] = Object.getOwnPropertyDescriptor(obj, name);\n        return map;\n    }\n\n    function makePassthruHandler(obj) {\n        // Handler copied from\n        // http://wiki.ecmascript.org/doku.php?id=harmony:proxies&s=proxy%20object#examplea_no-op_forwarding_proxy\n        return {\n            getOwnPropertyDescriptor: function(name) {\n                var desc = Object.getOwnPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getPropertyDescriptor: function(name) {\n                var desc = getPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getOwnPropertyNames: function() {\n                return Object.getOwnPropertyNames(obj);\n            },\n            defineProperty: function(name, desc) {\n                Object.defineProperty(obj, name, desc);\n            },\n            \"delete\": function(name) { return delete obj[name]; },\n            fix: function() {\n                if (Object.isFrozen(obj)) {\n                    return getOwnProperties(obj);\n                }\n\n                // As long as obj is not frozen, the proxy won't allow itself to be fixed.\n                return undefined; // will cause a TypeError to be thrown\n            },\n\n            has: function(name) { return name in obj; },\n            hasOwn: function(name) { return ({}).hasOwnProperty.call(obj, name); },\n            get: function(receiver, name) { return obj[name]; },\n\n            // bad behavior when set fails in non-strict mode\n            set: function(receiver, name, val) { obj[name] = val; return true; },\n            enumerate: function() {\n                var result = [];\n                for (name in obj) { result.push(name); };\n                return result;\n            },\n            keys: function() { return Object.keys(obj); }\n        };\n    }\n\n    // default function used when looking for a property in the global object\n    function noPropFound() { return undefined; }\n\n    var hasOwnProperty = ({}).hasOwnProperty;\n\n    function StringMap() {\n        this.table = Object.create(null, {});\n        this.size = 0;\n    }\n\n    StringMap.prototype = {\n        has: function(x) { return hasOwnProperty.call(this.table, x); },\n        set: function(x, v) {\n            if (!hasOwnProperty.call(this.table, x))\n                this.size++;\n            this.table[x] = v;\n        },\n        get: function(x) { return this.table[x]; },\n        getDef: function(x, thunk) {\n            if (!hasOwnProperty.call(this.table, x)) {\n                this.size++;\n                this.table[x] = thunk();\n            }\n            return this.table[x];\n        },\n        forEach: function(f) {\n            var table = this.table;\n            for (var key in table)\n                f.call(this, key, table[key]);\n        },\n        toString: function() { return \"[object StringMap]\" }\n    };\n\n    // non-destructive stack\n    function Stack(elts) {\n        this.elts = elts || null;\n    }\n\n    Stack.prototype = {\n        push: function(x) {\n            return new Stack({ top: x, rest: this.elts });\n        },\n        top: function() {\n            if (!this.elts)\n                throw new Error(\"empty stack\");\n            return this.elts.top;\n        },\n        isEmpty: function() {\n            return this.top === null;\n        },\n        find: function(test) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                if (test(elts.top))\n                    return elts.top;\n            }\n            return null;\n        },\n        has: function(x) {\n            return Boolean(this.find(function(elt) { return elt === x }));\n        },\n        forEach: function(f) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                f(elts.top);\n            }\n        }\n    };\n\n    return {\n        tokens: tokens,\n        opTypeNames: opTypeNames,\n        keywords: keywords,\n        isStatementStartCode: isStatementStartCode,\n        tokenIds: tokenIds,\n        consts: consts,\n        assignOps: assignOps,\n        defineGetter: defineGetter,\n        defineProperty: defineProperty,\n        isNativeCode: isNativeCode,\n        makePassthruHandler: makePassthruHandler,\n        noPropFound: noPropFound,\n        StringMap: StringMap,\n        Stack: Stack\n    };\n}());\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Lexical scanner.\n */\n\nNarcissus.lexer = (function() {\n\n    var definitions = Narcissus.definitions;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    // Build up a trie of operator tokens.\n    var opTokens = {};\n    for (var op in definitions.opTypeNames) {\n        if (op === '\\n' || op === '.')\n            continue;\n\n        var node = opTokens;\n        for (var i = 0; i < op.length; i++) {\n            var ch = op[i];\n            if (!(ch in node))\n                node[ch] = {};\n            node = node[ch];\n            node.op = op;\n        }\n    }\n\n    /*\n     * Tokenizer :: (source, filename, line number) -> Tokenizer\n     */\n    function Tokenizer(s, f, l) {\n        this.cursor = 0;\n        this.source = String(s);\n        this.tokens = [];\n        this.tokenIndex = 0;\n        this.lookahead = 0;\n        this.scanNewlines = false;\n        this.unexpectedEOF = false;\n        this.filename = f || \"\";\n        this.lineno = l || 1;\n        this.comments = [];\n    }\n\n    Tokenizer.prototype = {\n        get done() {\n            // We need to set scanOperand to true here because the first thing\n            // might be a regexp.\n            return this.peek(true) === END;\n        },\n\n        get token() {\n            return this.tokens[this.tokenIndex];\n        },\n\n        match: function (tt, scanOperand) {\n            return this.get(scanOperand) === tt || this.unget();\n        },\n\n        mustMatch: function (tt) {\n            if (!this.match(tt)) {\n                throw this.newSyntaxError(\"Missing \" +\n                                          definitions.tokens[tt].toLowerCase());\n            }\n            return this.token;\n        },\n\n        peek: function (scanOperand) {\n            var tt, next;\n            if (this.lookahead) {\n                next = this.tokens[(this.tokenIndex + this.lookahead) & 3];\n                tt = (this.scanNewlines && next.lineno !== this.lineno)\n                     ? NEWLINE\n                     : next.type;\n            } else {\n                tt = this.get(scanOperand);\n                this.unget();\n            }\n            return tt;\n        },\n\n        peekOnSameLine: function (scanOperand) {\n            this.scanNewlines = true;\n            var tt = this.peek(scanOperand);\n            this.scanNewlines = false;\n            return tt;\n        },\n\n        // Eat comments and whitespace.\n        // toka: returns list of skipped comments\n        skip: function () {\n            var input = this.source;\n            var cstart;\n            var clineno;\n            var comments = [];\n            var comment;\n            var nlcount = 0;\n\n            for (;;) {\n                var ch = input[this.cursor++];\n                var next = input[this.cursor];\n                if (ch === '\\n' && !this.scanNewlines) {\n                    this.lineno++;\n                    nlcount++;\n                } else if (ch === '/' && next === '*') {\n                    cstart = this.cursor;\n                    clineno = this.lineno;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated comment\");\n\n                        if (ch === '*') {\n                            next = input[this.cursor];\n                            if (next === '/') {\n                                this.cursor++;\n                                comment = {\n                                    type: \"BLOCK_COMMENT\",\n                                    nlcount: nlcount,\n                                    start:cstart-1, end:this.cursor, lineno:clineno, endlineno: this.lineno,\n                                    value: input.substring(cstart+1,this.cursor-2)\n                                }\n                                // comments.push(comment);\n                                this.comments.push(comment);\n                                nlcount = 0;\n                                break;\n                            }\n                        } else if (ch === '\\n') {\n                            this.lineno++;\n                        }\n                    }\n                } else if (ch === '/' && next === '/') {\n                    cstart = this.cursor;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined) {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            // comments.push(comment);\n                            this.comments.push(comment);\n                            return;\n                            // return comments;\n                        }\n                        if (ch === '\\n') {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            //comments.push(  );\n                            this.comments.push(comment);\n                            nlcount = 0;\n                            this.lineno++;\n                            break;\n                        }\n                    }\n                } else if (ch !== ' ' && ch !== '\\t') {\n                    this.cursor--;\n                    // return comments;\n                    return;\n                }\n            }\n        },\n\n        // Lex the exponential part of a number, if present. Return true iff an\n        // exponential part was found.\n        lexExponent: function() {\n            var input = this.source;\n            var next = input[this.cursor];\n            if (next === 'e' || next === 'E') {\n                this.cursor++;\n                ch = input[this.cursor++];\n                if (ch === '+' || ch === '-')\n                    ch = input[this.cursor++];\n\n                if (ch < '0' || ch > '9')\n                    throw this.newSyntaxError(\"Missing exponent\");\n\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                return true;\n            }\n\n            return false;\n        },\n\n        lexZeroNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            ch = input[this.cursor++];\n            if (ch === '.') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n                token.value = parseFloat(token.start, this.cursor);\n            } else if (ch === 'x' || ch === 'X') {\n                do {\n                    ch = input[this.cursor++];\n                } while ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||\n                         (ch >= 'A' && ch <= 'F'));\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else if (ch >= '0' && ch <= '7') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '7');\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else {\n                this.cursor--;\n                this.lexExponent();     // 0E1, &c.\n                token.value = 0;\n            }\n        },\n\n        lexNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            var floating = false;\n            do {\n                ch = input[this.cursor++];\n                if (ch === '.' && !floating) {\n                    floating = true;\n                    ch = input[this.cursor++];\n                }\n            } while (ch >= '0' && ch <= '9');\n\n            this.cursor--;\n\n            var exponent = this.lexExponent();\n            floating = floating || exponent;\n\n            var str = input.substring(token.start, this.cursor);\n            token.value = floating ? parseFloat(str) : parseInt(str);\n        },\n\n        lexDot: function (ch) {\n            var token = this.token, input = this.source;\n            var next = input[this.cursor];\n            if (next >= '0' && next <= '9') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n\n                token.type = NUMBER;\n                token.value = parseFloat(token.start, this.cursor);\n            } else {\n                token.type = DOT;\n                token.assignOp = null;\n                token.value = '.';\n            }\n        },\n\n        lexString: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = STRING;\n\n            var hasEscapes = false;\n            var delim = ch;\n            while ((ch = input[this.cursor++]) !== delim) {\n                // [JS2COFFEE] Fixed to make it work on a browser\n                if (this.cursor >= input.length)\n                    throw this.newSyntaxError(\"Unterminated string literal\");\n                if (ch === '\\\\') {\n                    hasEscapes = true;\n                    if (++this.cursor == input.length)\n                        throw this.newSyntaxError(\"Unterminated string literal\");\n                }\n            }\n\n            token.value = hasEscapes\n                          ? eval(input.substring(token.start, this.cursor))\n                          : input.substring(token.start + 1, this.cursor - 1);\n        },\n\n        lexRegExp: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = REGEXP;\n\n            do {\n                ch = input[this.cursor++];\n                if (ch === '\\\\') {\n                    this.cursor++;\n                } else if (ch === '[') {\n                    do {\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated character class\");\n\n                        if (ch === '\\\\')\n                            this.cursor++;\n\n                        ch = input[this.cursor++];\n                    } while (ch !== ']');\n                } else if (ch === undefined) {\n                    throw this.newSyntaxError(\"Unterminated regex\");\n                }\n            } while (ch !== '/');\n\n            do {\n                ch = input[this.cursor++];\n            } while (ch >= 'a' && ch <= 'z');\n\n            this.cursor--;\n\n            token.value = eval(input.substring(token.start, this.cursor));\n        },\n\n        lexOp: function (ch) {\n            var token = this.token, input = this.source;\n\n            // A bit ugly, but it seems wasteful to write a trie lookup routine\n            // for only 3 characters...\n            var node = opTokens[ch];\n            var next = input[this.cursor];\n            if (next in node) {\n                node = node[next];\n                this.cursor++;\n                next = input[this.cursor];\n                if (next in node) {\n                    node = node[next];\n                    this.cursor++;\n                    next = input[this.cursor];\n                }\n            }\n\n            var op = node.op;\n            if (definitions.assignOps[op] && input[this.cursor] === '=') {\n                this.cursor++;\n                token.type = ASSIGN;\n                token.assignOp = definitions.tokenIds[definitions.opTypeNames[op]];\n                op += '=';\n            } else {\n                token.type = definitions.tokenIds[definitions.opTypeNames[op]];\n                token.assignOp = null;\n            }\n\n            token.value = op;\n        },\n\n        // FIXME: Unicode escape sequences\n        // FIXME: Unicode identifiers\n        lexIdent: function (ch) {\n            var token = this.token, input = this.source;\n\n            do {\n                ch = input[this.cursor++];\n            } while ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n                     (ch >= '0' && ch <= '9') || ch === '$' || ch === '_');\n\n            this.cursor--;  // Put the non-word character back.\n\n            var id = input.substring(token.start, this.cursor);\n            token.type = definitions.keywords[id] || IDENTIFIER;\n            token.value = id;\n        },\n\n        /*\n         * Tokenizer.get :: void -> token type\n         *\n         * Consume input *only* if there is no lookahead.\n         * Dispatch to the appropriate lexing function depending on the input.\n         */\n        get: function (scanOperand) {\n            var token;\n            while (this.lookahead) {\n                --this.lookahead;\n                this.tokenIndex = (this.tokenIndex + 1) & 3;\n                token = this.tokens[this.tokenIndex];\n                if (token.type !== NEWLINE || this.scanNewlines)\n                    return token.type;\n            }\n\n            // var comments =\n            this.skip();\n\n            this.tokenIndex = (this.tokenIndex + 1) & 3;\n            token = this.tokens[this.tokenIndex];\n            if (!token)\n                this.tokens[this.tokenIndex] = token = {};\n\n            var input = this.source;\n            if (this.cursor === input.length)\n                return token.type = END;\n\n            token.start = this.cursor;\n            token.lineno = this.lineno;\n\n            var ch = input[this.cursor++];\n            if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '$' || ch === '_') {\n                this.lexIdent(ch);\n            } else if (scanOperand && ch === '/') {\n                this.lexRegExp(ch);\n            } else if (ch in opTokens) {\n                this.lexOp(ch);\n            } else if (ch === '.') {\n                this.lexDot(ch);\n            } else if (ch >= '1' && ch <= '9') {\n                this.lexNumber(ch);\n            } else if (ch === '0') {\n                this.lexZeroNumber(ch);\n            } else if (ch === '\"' || ch === \"'\") {\n                this.lexString(ch);\n            } else if (this.scanNewlines && ch === '\\n') {\n                token.type = NEWLINE;\n                token.value = '\\n';\n                this.lineno++;\n            } else {\n                throw this.newSyntaxError(\"Illegal token\");\n            }\n\n            token.end = this.cursor;\n            // token.comments = [comments,this.skip()];\n            return token.type;\n        },\n\n        /*\n         * Tokenizer.unget :: void -> undefined\n         *\n         * Match depends on unget returning undefined.\n         */\n        unget: function () {\n            if (++this.lookahead === 4) throw \"PANIC: too much lookahead!\";\n            this.tokenIndex = (this.tokenIndex - 1) & 3;\n        },\n\n        newSyntaxError: function (m) {\n            var e = new SyntaxError(m, this.filename, this.lineno);\n            e.source = this.source;\n            e.cursor = this.lookahead\n                       ? this.tokens[(this.tokenIndex + this.lookahead) & 3].start\n                       : this.cursor;\n            return e;\n        },\n    };\n\n    return { Tokenizer: Tokenizer };\n\n}());\n\n/* -*- Mode: JS; tab-width: 4; indent-tabs-mode: nil; -*-\n * vim: set sw=4 ts=4 et tw=78:\n * ***** BEGIN LICENSE BLOCK *****\n *\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Parser.\n */\n\nNarcissus.parser = (function() {\n\n    var lexer = Narcissus.lexer;\n    var definitions = Narcissus.definitions;\n\n    const StringMap = definitions.StringMap;\n    const Stack = definitions.Stack;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    /*\n     * pushDestructuringVarDecls :: (node, hoisting node) -> void\n     *\n     * Recursively add all destructured declarations to varDecls.\n     */\n    function pushDestructuringVarDecls(n, s) {\n        for (var i in n) {\n            var sub = n[i];\n            if (sub.type === IDENTIFIER) {\n                s.varDecls.push(sub);\n            } else {\n                pushDestructuringVarDecls(sub, s);\n            }\n        }\n    }\n\n    // NESTING_TOP: top-level\n    // NESTING_SHALLOW: nested within static forms such as { ... } or labeled statement\n    // NESTING_DEEP: nested within dynamic forms such as if, loops, etc.\n    const NESTING_TOP = 0, NESTING_SHALLOW = 1, NESTING_DEEP = 2;\n\n    function StaticContext(parentScript, parentBlock, inFunction, inForLoopInit, nesting) {\n        this.parentScript = parentScript;\n        this.parentBlock = parentBlock;\n        this.inFunction = inFunction;\n        this.inForLoopInit = inForLoopInit;\n        this.nesting = nesting;\n        this.allLabels = new Stack();\n        this.currentLabels = new Stack();\n        this.labeledTargets = new Stack();\n        this.defaultTarget = null;\n        Narcissus.options.ecma3OnlyMode && (this.ecma3OnlyMode = true);\n        Narcissus.options.parenFreeMode && (this.parenFreeMode = true);\n    }\n\n    StaticContext.prototype = {\n        ecma3OnlyMode: false,\n        parenFreeMode: false,\n        // non-destructive update via prototype extension\n        update: function(ext) {\n            var desc = {};\n            for (var key in ext) {\n                desc[key] = {\n                    value: ext[key],\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                }\n            }\n            return Object.create(this, desc);\n        },\n        pushLabel: function(label) {\n            return this.update({ currentLabels: this.currentLabels.push(label),\n                                 allLabels: this.allLabels.push(label) });\n        },\n        pushTarget: function(target) {\n            var isDefaultTarget = target.isLoop || target.type === SWITCH;\n\n            if (this.currentLabels.isEmpty()) {\n                return isDefaultTarget\n                     ? this.update({ defaultTarget: target })\n                     : this;\n            }\n\n            target.labels = new StringMap();\n            this.currentLabels.forEach(function(label) {\n                target.labels.set(label, true);\n            });\n            return this.update({ currentLabels: new Stack(),\n                                 labeledTargets: this.labeledTargets.push(target),\n                                 defaultTarget: isDefaultTarget\n                                                ? target\n                                                : this.defaultTarget });\n        },\n        nest: function(atLeast) {\n            var nesting = Math.max(this.nesting, atLeast);\n            return (nesting !== this.nesting)\n                 ? this.update({ nesting: nesting })\n                 : this;\n        }\n    };\n\n    /*\n     * Script :: (tokenizer, boolean) -> node\n     *\n     * Parses the toplevel and function bodies.\n     */\n    function Script(t, inFunction) {\n        var n = new Node(t, scriptInit());\n        var x = new StaticContext(n, n, inFunction, false, NESTING_TOP);\n        Statements(t, x, n);\n        return n;\n    }\n\n    // We extend Array slightly with a top-of-stack method.\n    definitions.defineProperty(Array.prototype, \"top\",\n                               function() {\n                                   return this.length && this[this.length-1];\n                               }, false, false, true);\n\n    /*\n     * Node :: (tokenizer, optional init object) -> node\n     */\n    function Node(t, init) {\n        var token = t.token;\n        if (token) {\n            // If init.type exists it will override token.type.\n            this.type = token.type;\n            this.value = token.value;\n            this.lineno = token.lineno;\n\n            // Start and end are file positions for error handling.\n            this.start = token.start;\n            this.end = token.end;\n\n        } else {\n            this.lineno = t.lineno;\n        }\n\n        // Node uses a tokenizer for debugging (getSource, filename getter).\n        this.tokenizer = t;\n        this.children = [];\n\n        for (var prop in init)\n            this[prop] = init[prop];\n    }\n\n    var Np = Node.prototype = {};\n    Np.constructor = Node;\n    Np.toSource = Object.prototype.toSource;\n\n    // Always use push to add operands to an expression, to update start and end.\n    Np.push = function (kid) {\n        // kid can be null e.g. [1, , 2].\n        if (kid !== null) {\n            if (kid.start < this.start)\n                this.start = kid.start;\n            if (this.end < kid.end)\n                this.end = kid.end;\n        }\n        return this.children.push(kid);\n    }\n\n    Node.indentLevel = 0;\n\n    function tokenString(tt) {\n        var t = definitions.tokens[tt];\n        return /^\\W/.test(t) ? definitions.opTypeNames[t] : t.toUpperCase();\n    }\n\n    Np.toString = function () {\n        var a = [];\n        for (var i in this) {\n            if (this.hasOwnProperty(i) && i !== 'type' && i !== 'target')\n                a.push({id: i, value: this[i]});\n        }\n        a.sort(function (a,b) { return (a.id < b.id) ? -1 : 1; });\n        const INDENTATION = \"    \";\n        var n = ++Node.indentLevel;\n        var s = \"{\\n\" + INDENTATION.repeat(n) + \"type: \" + tokenString(this.type);\n        for (i = 0; i < a.length; i++)\n            s += \",\\n\" + INDENTATION.repeat(n) + a[i].id + \": \" + a[i].value;\n        n = --Node.indentLevel;\n        s += \"\\n\" + INDENTATION.repeat(n) + \"}\";\n        return s;\n    }\n\n    Np.getSource = function () {\n        return this.tokenizer.source.slice(this.start, this.end);\n    };\n\n    /*\n     * Helper init objects for common nodes.\n     */\n\n    const LOOP_INIT = { isLoop: true };\n\n    function blockInit() {\n        return { type: BLOCK, varDecls: [] };\n    }\n\n    function scriptInit() {\n        return { type: SCRIPT,\n                 funDecls: [],\n                 varDecls: [],\n                 modDecls: [],\n                 impDecls: [],\n                 expDecls: [],\n                 loadDeps: [],\n                 hasEmptyReturn: false,\n                 hasReturnWithValue: false,\n                 isGenerator: false };\n    }\n\n    definitions.defineGetter(Np, \"filename\",\n                             function() {\n                                 return this.tokenizer.filename;\n                             });\n\n    definitions.defineGetter(Np, \"length\",\n                             function() {\n                                 throw new Error(\"Node.prototype.length is gone; \" +\n                                                 \"use n.children.length instead\");\n                             });\n\n    definitions.defineProperty(String.prototype, \"repeat\",\n                               function(n) {\n                                   var s = \"\", t = this + s;\n                                   while (--n >= 0)\n                                       s += t;\n                                   return s;\n                               }, false, false, true);\n\n    function MaybeLeftParen(t, x) {\n        if (x.parenFreeMode)\n            return t.match(LEFT_PAREN) ? LEFT_PAREN : END;\n        return t.mustMatch(LEFT_PAREN).type;\n    }\n\n    function MaybeRightParen(t, p) {\n        if (p === LEFT_PAREN)\n            t.mustMatch(RIGHT_PAREN);\n    }\n\n    /*\n     * Statements :: (tokenizer, compiler context, node) -> void\n     *\n     * Parses a sequence of Statements.\n     */\n    function Statements(t, x, n) {\n        try {\n            while (!t.done && t.peek(true) !== RIGHT_CURLY)\n            { n.push(Statement(t, x)); }\n        } catch (e) {\n            if (t.done)\n            { t.unexpectedEOF = true; }\n            throw(e);\n        }\n    }\n\n    function Block(t, x) {\n        t.mustMatch(LEFT_CURLY);\n        var n = new Node(t, blockInit());\n        Statements(t, x.update({ parentBlock: n }).pushTarget(n), n);\n        t.mustMatch(RIGHT_CURLY);\n        return n;\n    }\n\n    const DECLARED_FORM = 0, EXPRESSED_FORM = 1, STATEMENT_FORM = 2;\n\n    /*\n     * Statement :: (tokenizer, compiler context) -> node\n     *\n     * Parses a Statement.\n     */\n    function Statement(t, x) {\n        var i, label, n, n2, p, c, ss, tt = t.get(true), tt2, x2, x3;\n\n        // Cases for statements ending in a right curly return early, avoiding the\n        // common semicolon insertion magic after this switch.\n        switch (tt) {\n          case FUNCTION:\n            // DECLARED_FORM extends funDecls of x, STATEMENT_FORM doesn't.\n            return FunctionDefinition(t, x, true,\n                                      (x.nesting !== NESTING_TOP)\n                                      ? STATEMENT_FORM\n                                      : DECLARED_FORM);\n\n          case LEFT_CURLY:\n            n = new Node(t, blockInit());\n            Statements(t, x.update({ parentBlock: n }).pushTarget(n).nest(NESTING_SHALLOW), n);\n            t.mustMatch(RIGHT_CURLY);\n            return n;\n\n          case IF:\n            n = new Node(t);\n            n.condition = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            n.thenPart = Statement(t, x2);\n            n.elsePart = t.match(ELSE) ? Statement(t, x2) : null;\n            return n;\n\n          case SWITCH:\n            // This allows CASEs after a DEFAULT, which is in the standard.\n            n = new Node(t, { cases: [], defaultIndex: -1 });\n            n.discriminant = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            t.mustMatch(LEFT_CURLY);\n            while ((tt = t.get()) !== RIGHT_CURLY) {\n                switch (tt) {\n                  case DEFAULT:\n                    if (n.defaultIndex >= 0)\n                        throw t.newSyntaxError(\"More than one switch default\");\n                    // FALL THROUGH\n                  case CASE:\n                    n2 = new Node(t);\n                    if (tt === DEFAULT)\n                        n.defaultIndex = n.cases.length;\n                    else\n                        n2.caseLabel = Expression(t, x2, COLON);\n                    break;\n\n                  default:\n                    throw t.newSyntaxError(\"Invalid switch case\");\n                }\n                t.mustMatch(COLON);\n                n2.statements = new Node(t, blockInit());\n                while ((tt=t.peek(true)) !== CASE && tt !== DEFAULT &&\n                        tt !== RIGHT_CURLY)\n                    n2.statements.push(Statement(t, x2));\n                n.cases.push(n2);\n            }\n            return n;\n\n          case FOR:\n            n = new Node(t, LOOP_INIT);\n            if (t.match(IDENTIFIER)) {\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(LEFT_PAREN);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            x3 = x.update({ inForLoopInit: true });\n            if ((tt = t.peek()) !== SEMICOLON) {\n                if (tt === VAR || tt === CONST) {\n                    t.get();\n                    n2 = Variables(t, x3);\n                } else if (tt === LET) {\n                    t.get();\n                    if (t.peek() === LEFT_PAREN) {\n                        n2 = LetBlock(t, x3, false);\n                    } else {\n                        // Let in for head, we need to add an implicit block\n                        // around the rest of the for.\n                        x3.parentBlock = n;\n                        n.varDecls = [];\n                        n2 = Variables(t, x3);\n                    }\n                } else {\n                    n2 = Expression(t, x3);\n                }\n            }\n            if (n2 && t.match(IN)) {\n                n.type = FOR_IN;\n                n.object = Expression(t, x3);\n                if (n2.type === VAR || n2.type === LET) {\n                    c = n2.children;\n\n                    // Destructuring turns one decl into multiples, so either\n                    // there must be only one destructuring or only one\n                    // decl.\n                    if (c.length !== 1 && n2.destructurings.length !== 1) {\n                        throw new SyntaxError(\"Invalid for..in left-hand side\",\n                                              t.filename, n2.lineno);\n                    }\n                    if (n2.destructurings.length > 0) {\n                        n.iterator = n2.destructurings[0];\n                    } else {\n                        n.iterator = c[0];\n                    }\n                    n.varDecl = n2;\n                } else {\n                    if (n2.type === ARRAY_INIT || n2.type === OBJECT_INIT) {\n                        n2.destructuredNames = checkDestructuring(t, x3, n2);\n                    }\n                    n.iterator = n2;\n                }\n            } else {\n                n.setup = n2;\n                t.mustMatch(SEMICOLON);\n                if (n.isEach)\n                    throw t.newSyntaxError(\"Invalid for each..in loop\");\n                n.condition = (t.peek() === SEMICOLON)\n                              ? null\n                              : Expression(t, x3);\n                t.mustMatch(SEMICOLON);\n                tt2 = t.peek();\n                n.update = (x.parenFreeMode\n                            ? tt2 === LEFT_CURLY || definitions.isStatementStartCode[tt2]\n                            : tt2 === RIGHT_PAREN)\n                           ? null\n                           : Expression(t, x3);\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(RIGHT_PAREN);\n            n.body = Statement(t, x2);\n            return n;\n\n          case WHILE:\n            n = new Node(t, { isLoop: true });\n            n.condition = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case DO:\n            n = new Node(t, { isLoop: true });\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            t.mustMatch(WHILE);\n            n.condition = HeadExpression(t, x);\n            if (!x.ecmaStrictMode) {\n                // <script language=\"JavaScript\"> (without version hints) may need\n                // automatic semicolon insertion without a newline after do-while.\n                // See http://bugzilla.mozilla.org/show_bug.cgi?id=238945.\n                t.match(SEMICOLON);\n                return n;\n            }\n            break;\n\n          case BREAK:\n          case CONTINUE:\n            n = new Node(t);\n\n            // handle the |foo: break foo;| corner case\n            x2 = x.pushTarget(n);\n\n            if (t.peekOnSameLine() === IDENTIFIER) {\n                t.get();\n                n.label = t.token.value;\n            }\n\n            n.target = n.label\n                     ? x2.labeledTargets.find(function(target) { return target.labels.has(n.label) })\n                     : x2.defaultTarget;\n\n            if (!n.target)\n                throw t.newSyntaxError(\"Invalid \" + ((tt === BREAK) ? \"break\" : \"continue\"));\n            if (!n.target.isLoop && tt === CONTINUE)\n                throw t.newSyntaxError(\"Invalid continue\");\n\n            break;\n\n          case TRY:\n            n = new Node(t, { catchClauses: [] });\n            n.tryBlock = Block(t, x);\n            while (t.match(CATCH)) {\n                n2 = new Node(t);\n                p = MaybeLeftParen(t, x);\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured catch identifiers.\n                    t.unget();\n                    n2.varName = DestructuringExpression(t, x, true);\n                    break;\n                  case IDENTIFIER:\n                    n2.varName = t.token.value;\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing identifier in catch\");\n                    break;\n                }\n                if (t.match(IF)) {\n                    if (x.ecma3OnlyMode)\n                        throw t.newSyntaxError(\"Illegal catch guard\");\n                    if (n.catchClauses.length && !n.catchClauses.top().guard)\n                        throw t.newSyntaxError(\"Guarded catch after unguarded\");\n                    n2.guard = Expression(t, x);\n                }\n                MaybeRightParen(t, p);\n                n2.block = Block(t, x);\n                n.catchClauses.push(n2);\n            }\n            if (t.match(FINALLY))\n                n.finallyBlock = Block(t, x);\n            if (!n.catchClauses.length && !n.finallyBlock)\n                throw t.newSyntaxError(\"Invalid try statement\");\n            return n;\n\n          case CATCH:\n          case FINALLY:\n            throw t.newSyntaxError(definitions.tokens[tt] + \" without preceding try\");\n\n          case THROW:\n            n = new Node(t);\n            n.exception = Expression(t, x);\n            break;\n\n          case RETURN:\n            n = ReturnOrYield(t, x);\n            break;\n\n          case WITH:\n            n = new Node(t);\n            n.object = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case VAR:\n          case CONST:\n            n = Variables(t, x);\n            break;\n\n          case LET:\n            if (t.peek() === LEFT_PAREN)\n                n = LetBlock(t, x, true);\n            else\n                n = Variables(t, x);\n            break;\n\n          case DEBUGGER:\n            n = new Node(t);\n            break;\n\n          case NEWLINE:\n          case SEMICOLON:\n            n = new Node(t, { type: SEMICOLON });\n            n.expression = null;\n            return n;\n\n          default:\n            if (tt === IDENTIFIER) {\n                tt = t.peek();\n                // Labeled statement.\n                if (tt === COLON) {\n                    label = t.token.value;\n                    if (x.allLabels.has(label))\n                        throw t.newSyntaxError(\"Duplicate label\");\n                    t.get();\n                    n = new Node(t, { type: LABEL, label: label });\n                    n.statement = Statement(t, x.pushLabel(label).nest(NESTING_SHALLOW));\n                    n.target = (n.statement.type === LABEL) ? n.statement.target : n.statement;\n                    return n;\n                }\n            }\n\n            // Expression statement.\n            // We unget the current token to parse the expression as a whole.\n            n = new Node(t, { type: SEMICOLON });\n            t.unget();\n            n.expression = Expression(t, x);\n            n.end = n.expression.end;\n            break;\n        }\n\n        MagicalSemicolon(t);\n        return n;\n    }\n\n    function MagicalSemicolon(t) {\n        var tt;\n        if (t.lineno === t.token.lineno) {\n            tt = t.peekOnSameLine();\n            if (tt !== END && tt !== NEWLINE && tt !== SEMICOLON && tt !== RIGHT_CURLY)\n                throw t.newSyntaxError(\"missing ; before statement\");\n        }\n        t.match(SEMICOLON);\n    }\n\n    function ReturnOrYield(t, x) {\n        var n, b, tt = t.token.type, tt2;\n\n        var parentScript = x.parentScript;\n\n        if (tt === RETURN) {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Return not in function\");\n        } else /* if (tt === YIELD) */ {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Yield not in function\");\n            parentScript.isGenerator = true;\n        }\n        n = new Node(t, { value: undefined });\n\n        tt2 = t.peek(true);\n        if (tt2 !== END && tt2 !== NEWLINE &&\n            tt2 !== SEMICOLON && tt2 !== RIGHT_CURLY\n            && (tt !== YIELD ||\n                (tt2 !== tt && tt2 !== RIGHT_BRACKET && tt2 !== RIGHT_PAREN &&\n                 tt2 !== COLON && tt2 !== COMMA))) {\n            if (tt === RETURN) {\n                n.value = Expression(t, x);\n                parentScript.hasReturnWithValue = true;\n            } else {\n                n.value = AssignExpression(t, x);\n            }\n        } else if (tt === RETURN) {\n            parentScript.hasEmptyReturn = true;\n        }\n\n        // Disallow return v; in generator.\n        if (parentScript.hasReturnWithValue && parentScript.isGenerator)\n            throw t.newSyntaxError(\"Generator returns a value\");\n\n        return n;\n    }\n\n    /*\n     * FunctionDefinition :: (tokenizer, compiler context, boolean,\n     *                        DECLARED_FORM or EXPRESSED_FORM or STATEMENT_FORM)\n     *                    -> node\n     */\n    function FunctionDefinition(t, x, requireName, functionForm) {\n        var tt;\n        var f = new Node(t, { params: [] });\n        if (f.type !== FUNCTION)\n            f.type = (f.value === \"get\") ? GETTER : SETTER;\n        if (t.match(IDENTIFIER))\n            f.name = t.token.value;\n        else if (requireName)\n            throw t.newSyntaxError(\"missing function identifier\");\n\n        var x2 = new StaticContext(null, null, true, false, NESTING_TOP);\n\n        t.mustMatch(LEFT_PAREN);\n        if (!t.match(RIGHT_PAREN)) {\n            do {\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured formal parameters.\n                    t.unget();\n                    f.params.push(DestructuringExpression(t, x2));\n                    break;\n                  case IDENTIFIER:\n                    f.params.push(t.token.value);\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing formal parameter\");\n                    break;\n                }\n            } while (t.match(COMMA));\n            t.mustMatch(RIGHT_PAREN);\n        }\n\n        // Do we have an expression closure or a normal body?\n        tt = t.get();\n        if (tt !== LEFT_CURLY)\n            t.unget();\n\n        if (tt !== LEFT_CURLY) {\n            f.body = AssignExpression(t, x2);\n            if (f.body.isGenerator)\n                throw t.newSyntaxError(\"Generator returns a value\");\n        } else {\n            f.body = Script(t, true);\n        }\n\n        if (tt === LEFT_CURLY)\n            t.mustMatch(RIGHT_CURLY);\n\n        f.end = t.token.end;\n        f.functionForm = functionForm;\n        if (functionForm === DECLARED_FORM)\n            x.parentScript.funDecls.push(f);\n        return f;\n    }\n\n    /*\n     * Variables :: (tokenizer, compiler context) -> node\n     *\n     * Parses a comma-separated list of var declarations (and maybe\n     * initializations).\n     */\n    function Variables(t, x, letBlock) {\n        var n, n2, ss, i, s, tt;\n\n        tt = t.token.type;\n        switch (tt) {\n          case VAR:\n          case CONST:\n            s = x.parentScript;\n            break;\n          case LET:\n            s = x.parentBlock;\n            break;\n          case LEFT_PAREN:\n            tt = LET;\n            s = letBlock;\n            break;\n        }\n\n        n = new Node(t, { type: tt, destructurings: [] });\n\n        do {\n            tt = t.get();\n            if (tt === LEFT_BRACKET || tt === LEFT_CURLY) {\n                // Need to unget to parse the full destructured expression.\n                t.unget();\n\n                var dexp = DestructuringExpression(t, x, true);\n\n                n2 = new Node(t, { type: IDENTIFIER,\n                                   name: dexp,\n                                   readOnly: n.type === CONST });\n                n.push(n2);\n                pushDestructuringVarDecls(n2.name.destructuredNames, s);\n                n.destructurings.push({ exp: dexp, decl: n2 });\n\n                if (x.inForLoopInit && t.peek() === IN) {\n                    continue;\n                }\n\n                t.mustMatch(ASSIGN);\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n\n                continue;\n            }\n\n            if (tt !== IDENTIFIER)\n                throw t.newSyntaxError(\"missing variable name\");\n\n            n2 = new Node(t, { type: IDENTIFIER,\n                               name: t.token.value,\n                               readOnly: n.type === CONST });\n            n.push(n2);\n            s.varDecls.push(n2);\n\n            if (t.match(ASSIGN)) {\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n            }\n        } while (t.match(COMMA));\n\n        return n;\n    }\n\n    /*\n     * LetBlock :: (tokenizer, compiler context, boolean) -> node\n     *\n     * Does not handle let inside of for loop init.\n     */\n    function LetBlock(t, x, isStatement) {\n        var n, n2;\n\n        // t.token.type must be LET\n        n = new Node(t, { type: LET_BLOCK, varDecls: [] });\n        t.mustMatch(LEFT_PAREN);\n        n.variables = Variables(t, x, n);\n        t.mustMatch(RIGHT_PAREN);\n\n        if (isStatement && t.peek() !== LEFT_CURLY) {\n            /*\n             * If this is really an expression in let statement guise, then we\n             * need to wrap the LET_BLOCK node in a SEMICOLON node so that we pop\n             * the return value of the expression.\n             */\n            n2 = new Node(t, { type: SEMICOLON,\n                               expression: n });\n            isStatement = false;\n        }\n\n        if (isStatement)\n            n.block = Block(t, x);\n        else\n            n.expression = AssignExpression(t, x);\n\n        return n;\n    }\n\n    function checkDestructuring(t, x, n, simpleNamesOnly) {\n        if (n.type === ARRAY_COMP)\n            throw t.newSyntaxError(\"Invalid array comprehension left-hand side\");\n        if (n.type !== ARRAY_INIT && n.type !== OBJECT_INIT)\n            return;\n\n        var lhss = {};\n        var nn, n2, idx, sub, cc, c = n.children;\n        for (var i = 0, j = c.length; i < j; i++) {\n            if (!(nn = c[i]))\n                continue;\n            if (nn.type === PROPERTY_INIT) {\n                cc = nn.children;\n                sub = cc[1];\n                idx = cc[0].value;\n            } else if (n.type === OBJECT_INIT) {\n                // Do we have destructuring shorthand {foo, bar}?\n                sub = nn;\n                idx = nn.value;\n            } else {\n                sub = nn;\n                idx = i;\n            }\n\n            if (sub.type === ARRAY_INIT || sub.type === OBJECT_INIT) {\n                lhss[idx] = checkDestructuring(t, x, sub, simpleNamesOnly);\n            } else {\n                if (simpleNamesOnly && sub.type !== IDENTIFIER) {\n                    // In declarations, lhs must be simple names\n                    throw t.newSyntaxError(\"missing name in pattern\");\n                }\n\n                lhss[idx] = sub;\n            }\n        }\n\n        return lhss;\n    }\n\n    function DestructuringExpression(t, x, simpleNamesOnly) {\n        var n = PrimaryExpression(t, x);\n        // Keep the list of lefthand sides for varDecls\n        n.destructuredNames = checkDestructuring(t, x, n, simpleNamesOnly);\n        return n;\n    }\n\n    function GeneratorExpression(t, x, e) {\n        return new Node(t, { type: GENERATOR,\n                             expression: e,\n                             tail: ComprehensionTail(t, x) });\n    }\n\n    function ComprehensionTail(t, x) {\n        var body, n, n2, n3, p;\n\n        // t.token.type must be FOR\n        body = new Node(t, { type: COMP_TAIL });\n\n        do {\n            // Comprehension tails are always for..in loops.\n            n = new Node(t, { type: FOR_IN, isLoop: true });\n            if (t.match(IDENTIFIER)) {\n                // But sometimes they're for each..in.\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            p = MaybeLeftParen(t, x);\n            switch(t.get()) {\n              case LEFT_BRACKET:\n              case LEFT_CURLY:\n                t.unget();\n                // Destructured left side of for in comprehension tails.\n                n.iterator = DestructuringExpression(t, x);\n                break;\n\n              case IDENTIFIER:\n                n.iterator = n3 = new Node(t, { type: IDENTIFIER });\n                n3.name = n3.value;\n                n.varDecl = n2 = new Node(t, { type: VAR });\n                n2.push(n3);\n                x.parentScript.varDecls.push(n3);\n                // Don't add to varDecls since the semantics of comprehensions is\n                // such that the variables are in their own function when\n                // desugared.\n                break;\n\n              default:\n                throw t.newSyntaxError(\"missing identifier\");\n            }\n            t.mustMatch(IN);\n            n.object = Expression(t, x);\n            MaybeRightParen(t, p);\n            body.push(n);\n        } while (t.match(FOR));\n\n        // Optional guard.\n        if (t.match(IF))\n            body.guard = HeadExpression(t, x);\n\n        return body;\n    }\n\n    function HeadExpression(t, x) {\n        var p = MaybeLeftParen(t, x);\n        var n = ParenExpression(t, x);\n        MaybeRightParen(t, p);\n        if (p === END && !n.parenthesized) {\n            var tt = t.peek();\n            if (tt !== LEFT_CURLY && !definitions.isStatementStartCode[tt])\n                throw t.newSyntaxError(\"Unparenthesized head followed by unbraced body\");\n        }\n        return n;\n    }\n\n    function ParenExpression(t, x) {\n        // Always accept the 'in' operator in a parenthesized expression,\n        // where it's unambiguous, even if we might be parsing the init of a\n        // for statement.\n        var n = Expression(t, x.update({ inForLoopInit: x.inForLoopInit &&\n                                                        (t.token.type === LEFT_PAREN) }));\n\n        if (t.match(FOR)) {\n            if (n.type === YIELD && !n.parenthesized)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (n.type === COMMA && !n.parenthesized)\n                throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            n = GeneratorExpression(t, x, n);\n        }\n\n        return n;\n    }\n\n    /*\n     * Expression :: (tokenizer, compiler context) -> node\n     *\n     * Top-down expression parser matched against SpiderMonkey.\n     */\n    function Expression(t, x) {\n        var n, n2;\n\n        n = AssignExpression(t, x);\n        if (t.match(COMMA)) {\n            n2 = new Node(t, { type: COMMA });\n            n2.push(n);\n            n = n2;\n            do {\n                n2 = n.children[n.children.length-1];\n                if (n2.type === YIELD && !n2.parenthesized)\n                    throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n                n.push(AssignExpression(t, x));\n            } while (t.match(COMMA));\n        }\n\n        return n;\n    }\n\n    function AssignExpression(t, x) {\n        var n, lhs;\n\n        // Have to treat yield like an operand because it could be the leftmost\n        // operand of the expression.\n        if (t.match(YIELD, true))\n            return ReturnOrYield(t, x);\n\n        n = new Node(t, { type: ASSIGN });\n        lhs = ConditionalExpression(t, x);\n\n        if (!t.match(ASSIGN)) {\n            return lhs;\n        }\n\n        switch (lhs.type) {\n          case OBJECT_INIT:\n          case ARRAY_INIT:\n            lhs.destructuredNames = checkDestructuring(t, x, lhs);\n            // FALL THROUGH\n          case IDENTIFIER: case DOT: case INDEX: case CALL:\n            break;\n          default:\n            throw t.newSyntaxError(\"Bad left-hand side of assignment\");\n            break;\n        }\n\n        n.assignOp = t.token.assignOp;\n        n.push(lhs);\n        n.push(AssignExpression(t, x));\n\n        return n;\n    }\n\n    function ConditionalExpression(t, x) {\n        var n, n2;\n\n        n = OrExpression(t, x);\n        if (t.match(HOOK)) {\n            n2 = n;\n            n = new Node(t, { type: HOOK });\n            n.push(n2);\n            /*\n             * Always accept the 'in' operator in the middle clause of a ternary,\n             * where it's unambiguous, even if we might be parsing the init of a\n             * for statement.\n             */\n            n.push(AssignExpression(t, x.update({ inForLoopInit: false })));\n            if (!t.match(COLON))\n                throw t.newSyntaxError(\"missing : after ?\");\n            n.push(AssignExpression(t, x));\n        }\n\n        return n;\n    }\n\n    function OrExpression(t, x) {\n        var n, n2;\n\n        n = AndExpression(t, x);\n        while (t.match(OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AndExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseOrExpression(t, x);\n        while (t.match(AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseOrExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseOrExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseXorExpression(t, x);\n        while (t.match(BITWISE_OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseXorExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseXorExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseAndExpression(t, x);\n        while (t.match(BITWISE_XOR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseAndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseAndExpression(t, x) {\n        var n, n2;\n\n        n = EqualityExpression(t, x);\n        while (t.match(BITWISE_AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(EqualityExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function EqualityExpression(t, x) {\n        var n, n2;\n\n        n = RelationalExpression(t, x);\n        while (t.match(EQ) || t.match(NE) ||\n               t.match(STRICT_EQ) || t.match(STRICT_NE)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(RelationalExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function RelationalExpression(t, x) {\n        var n, n2;\n\n        /*\n         * Uses of the in operator in shiftExprs are always unambiguous,\n         * so unset the flag that prohibits recognizing it.\n         */\n        var x2 = x.update({ inForLoopInit: false });\n        n = ShiftExpression(t, x2);\n        while ((t.match(LT) || t.match(LE) || t.match(GE) || t.match(GT) ||\n               (!x.inForLoopInit && t.match(IN)) ||\n               t.match(INSTANCEOF))) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(ShiftExpression(t, x2));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ShiftExpression(t, x) {\n        var n, n2;\n\n        n = AddExpression(t, x);\n        while (t.match(LSH) || t.match(RSH) || t.match(URSH)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AddExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AddExpression(t, x) {\n        var n, n2;\n\n        n = MultiplyExpression(t, x);\n        while (t.match(PLUS) || t.match(MINUS)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(MultiplyExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function MultiplyExpression(t, x) {\n        var n, n2;\n\n        n = UnaryExpression(t, x);\n        while (t.match(MUL) || t.match(DIV) || t.match(MOD)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(UnaryExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function UnaryExpression(t, x) {\n        var n, n2, tt;\n\n        switch (tt = t.get(true)) {\n          case DELETE: case VOID: case TYPEOF:\n          case NOT: case BITWISE_NOT: case PLUS: case MINUS:\n            if (tt === PLUS)\n                n = new Node(t, { type: UNARY_PLUS });\n            else if (tt === MINUS)\n                n = new Node(t, { type: UNARY_MINUS });\n            else\n                n = new Node(t);\n            n.push(UnaryExpression(t, x));\n            break;\n\n          case INCREMENT:\n          case DECREMENT:\n            // Prefix increment/decrement.\n            n = new Node(t);\n            n.push(MemberExpression(t, x, true));\n            break;\n\n          default:\n            t.unget();\n            n = MemberExpression(t, x, true);\n\n            // Don't look across a newline boundary for a postfix {in,de}crement.\n            if (t.tokens[(t.tokenIndex + t.lookahead - 1) & 3].lineno ===\n                t.lineno) {\n                if (t.match(INCREMENT) || t.match(DECREMENT)) {\n                    n2 = new Node(t, { postfix: true });\n                    n2.push(n);\n                    n = n2;\n                }\n            }\n            break;\n        }\n\n        return n;\n    }\n\n    function MemberExpression(t, x, allowCallSyntax) {\n        var n, n2, name, tt;\n\n        if (t.match(NEW)) {\n            n = new Node(t);\n            n.push(MemberExpression(t, x, false));\n            if (t.match(LEFT_PAREN)) {\n                n.type = NEW_WITH_ARGS;\n                n.push(ArgumentList(t, x));\n            }\n        } else {\n            n = PrimaryExpression(t, x);\n        }\n\n        while ((tt = t.get()) !== END) {\n            switch (tt) {\n              case DOT:\n                n2 = new Node(t);\n                n2.push(n);\n                t.mustMatch(IDENTIFIER);\n                n2.push(new Node(t));\n                break;\n\n              case LEFT_BRACKET:\n                n2 = new Node(t, { type: INDEX });\n                n2.push(n);\n                n2.push(Expression(t, x));\n                t.mustMatch(RIGHT_BRACKET);\n                break;\n\n              case LEFT_PAREN:\n                if (allowCallSyntax) {\n                    n2 = new Node(t, { type: CALL });\n                    n2.push(n);\n                    n2.push(ArgumentList(t, x));\n                    break;\n                }\n\n                // FALL THROUGH\n              default:\n                t.unget();\n                return n;\n            }\n\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ArgumentList(t, x) {\n        var n, n2;\n\n        n = new Node(t, { type: LIST });\n        if (t.match(RIGHT_PAREN, true))\n            return n;\n        do {\n            n2 = AssignExpression(t, x);\n            if (n2.type === YIELD && !n2.parenthesized && t.peek() === COMMA)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (t.match(FOR)) {\n                n2 = GeneratorExpression(t, x, n2);\n                if (n.children.length > 1 || t.peek(true) === COMMA)\n                    throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            }\n            n.push(n2);\n        } while (t.match(COMMA));\n        t.mustMatch(RIGHT_PAREN);\n\n        return n;\n    }\n\n    function PrimaryExpression(t, x) {\n        var n, n2, tt = t.get(true);\n\n        switch (tt) {\n          case FUNCTION:\n            n = FunctionDefinition(t, x, false, EXPRESSED_FORM);\n            break;\n\n          case LEFT_BRACKET:\n            n = new Node(t, { type: ARRAY_INIT });\n            while ((tt = t.peek(true)) !== RIGHT_BRACKET) {\n                if (tt === COMMA) {\n                    t.get();\n                    n.push(null);\n                    continue;\n                }\n                n.push(AssignExpression(t, x));\n                if (tt !== COMMA && !t.match(COMMA))\n                    break;\n            }\n\n            // If we matched exactly one element and got a FOR, we have an\n            // array comprehension.\n            if (n.children.length === 1 && t.match(FOR)) {\n                n2 = new Node(t, { type: ARRAY_COMP,\n                                   expression: n.children[0],\n                                   tail: ComprehensionTail(t, x) });\n                n = n2;\n            }\n            t.mustMatch(RIGHT_BRACKET);\n            break;\n\n          case LEFT_CURLY:\n            var id, fd;\n            n = new Node(t, { type: OBJECT_INIT });\n\n          object_init:\n            if (!t.match(RIGHT_CURLY)) {\n                do {\n                    tt = t.get();\n                    if ((t.token.value === \"get\" || t.token.value === \"set\") &&\n                        t.peek() === IDENTIFIER) {\n                        if (x.ecma3OnlyMode)\n                            throw t.newSyntaxError(\"Illegal property accessor\");\n                        n.push(FunctionDefinition(t, x, true, EXPRESSED_FORM));\n                    } else {\n                        switch (tt) {\n                          case IDENTIFIER: case NUMBER: case STRING:\n                            id = new Node(t, { type: IDENTIFIER });\n                            break;\n                          case RIGHT_CURLY:\n                            if (x.ecma3OnlyMode)\n                                throw t.newSyntaxError(\"Illegal trailing ,\");\n                            break object_init;\n                          default:\n                            if (t.token.value in definitions.keywords) {\n                                id = new Node(t, { type: IDENTIFIER });\n                                break;\n                            }\n                            throw t.newSyntaxError(\"Invalid property name\");\n                        }\n                        if (t.match(COLON)) {\n                            n2 = new Node(t, { type: PROPERTY_INIT });\n                            n2.push(id);\n                            n2.push(AssignExpression(t, x));\n                            n.push(n2);\n                        } else {\n                            // Support, e.g., |var {x, y} = o| as destructuring shorthand\n                            // for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.\n                            if (t.peek() !== COMMA && t.peek() !== RIGHT_CURLY)\n                                throw t.newSyntaxError(\"missing : after property\");\n                            n.push(id);\n                        }\n                    }\n                } while (t.match(COMMA));\n                t.mustMatch(RIGHT_CURLY);\n            }\n            break;\n\n          case LEFT_PAREN:\n            n = ParenExpression(t, x);\n            t.mustMatch(RIGHT_PAREN);\n            n.parenthesized = true;\n            break;\n\n          case LET:\n            n = LetBlock(t, x, false);\n            break;\n\n          case NULL: case THIS: case TRUE: case FALSE:\n          case IDENTIFIER: case NUMBER: case STRING: case REGEXP:\n            n = new Node(t);\n            break;\n\n          default:\n            throw t.newSyntaxError(\"missing operand\");\n            break;\n        }\n\n        return n;\n    }\n\n    /*\n     * parse :: (source, filename, line number) -> node\n     */\n    function parse(s, f, l) {\n        var t = new lexer.Tokenizer(s, f, l);\n        var n = Script(t, false);\n        if (!t.done)\n            throw t.newSyntaxError(\"Syntax error\");\n\n        return n;\n    }\n\n    /*\n     * parseStdin :: (source, {line number}) -> node\n     */\n    function parseStdin(s, ln) {\n        for (;;) {\n            try {\n                var t = new lexer.Tokenizer(s, \"stdin\", ln.value);\n                var n = Script(t, false);\n                ln.value = t.lineno;\n                return n;\n            } catch (e) {\n                if (!t.unexpectedEOF)\n                    throw e;\n                var more = readline();\n                if (!more)\n                    throw e;\n                s += \"\\n\" + more;\n            }\n        }\n    }\n\n    return {\n        parse: parse,\n        parseStdin: parseStdin,\n        Node: Node,\n        DECLARED_FORM: DECLARED_FORM,\n        EXPRESSED_FORM: EXPRESSED_FORM,\n        STATEMENT_FORM: STATEMENT_FORM,\n        Tokenizer: lexer.Tokenizer,\n        FunctionDefinition: FunctionDefinition\n    };\n\n}());\n\nvar exports = {\n  definitions: Narcissus.definitions,\n  lexer: Narcissus.lexer,\n  parser: Narcissus.parser\n};\n\nif (typeof module != 'undefined') {\n  module.exports = exports;\n};\n\n",
      "content": "/* vim: set sw=4 ts=4 et tw=78: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (typeof module == 'undefined') {\n  this.Narcissus = new Object;\n}\n\nvar Narcissus = {\n    options: {\n        version: 185,\n    },\n    hostGlobal: this\n};\n\nNarcissus.definitions = (function() {\n\n    var tokens = [\n        // End of source.\n        \"END\",\n\n        // Operators and punctuators.  Some pair-wise order matters, e.g. (+, -)\n        // and (UNARY_PLUS, UNARY_MINUS).\n        \"\\n\", \";\",\n        \",\",\n        \"=\",\n        \"?\", \":\", \"CONDITIONAL\",\n        \"||\",\n        \"&&\",\n        \"|\",\n        \"^\",\n        \"&\",\n        \"==\", \"!=\", \"===\", \"!==\",\n        \"<\", \"<=\", \">=\", \">\",\n        \"<<\", \">>\", \">>>\",\n        \"+\", \"-\",\n        \"*\", \"/\", \"%\",\n        \"!\", \"~\", \"UNARY_PLUS\", \"UNARY_MINUS\",\n        \"++\", \"--\",\n        \".\",\n        \"[\", \"]\",\n        \"{\", \"}\",\n        \"(\", \")\",\n\n        // Nonterminal tree node type codes.\n        \"SCRIPT\", \"BLOCK\", \"LABEL\", \"FOR_IN\", \"CALL\", \"NEW_WITH_ARGS\", \"INDEX\",\n        \"ARRAY_INIT\", \"OBJECT_INIT\", \"PROPERTY_INIT\", \"GETTER\", \"SETTER\",\n        \"GROUP\", \"LIST\", \"LET_BLOCK\", \"ARRAY_COMP\", \"GENERATOR\", \"COMP_TAIL\",\n\n        // Terminals.\n        \"IDENTIFIER\", \"NUMBER\", \"STRING\", \"REGEXP\",\n\n        // Keywords.\n        \"break\",\n        \"case\", \"catch\", \"const\", \"continue\",\n        \"debugger\", \"default\", \"delete\", \"do\",\n        \"else\",\n        \"false\", \"finally\", \"for\", \"function\",\n        \"if\", \"in\", \"instanceof\",\n        \"let\",\n        \"new\", \"null\",\n        \"return\",\n        \"switch\",\n        \"this\", \"throw\", \"true\", \"try\", \"typeof\",\n        \"var\", \"void\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    var statementStartTokens = [\n        \"break\",\n        \"const\", \"continue\",\n        \"debugger\", \"do\",\n        \"for\",\n        \"if\",\n        \"return\",\n        \"switch\",\n        \"throw\", \"try\",\n        \"var\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    // Operator and punctuator mapping from token to tree node type name.\n    // NB: because the lexer doesn't backtrack, all token prefixes must themselves\n    // be valid tokens (e.g. !== is acceptable because its prefixes are the valid\n    // tokens != and !).\n    var opTypeNames = {\n        '\\n':   \"NEWLINE\",\n        ';':    \"SEMICOLON\",\n        ',':    \"COMMA\",\n        '?':    \"HOOK\",\n        ':':    \"COLON\",\n        '||':   \"OR\",\n        '&&':   \"AND\",\n        '|':    \"BITWISE_OR\",\n        '^':    \"BITWISE_XOR\",\n        '&':    \"BITWISE_AND\",\n        '===':  \"STRICT_EQ\",\n        '==':   \"EQ\",\n        '=':    \"ASSIGN\",\n        '!==':  \"STRICT_NE\",\n        '!=':   \"NE\",\n        '<<':   \"LSH\",\n        '<=':   \"LE\",\n        '<':    \"LT\",\n        '>>>':  \"URSH\",\n        '>>':   \"RSH\",\n        '>=':   \"GE\",\n        '>':    \"GT\",\n        '++':   \"INCREMENT\",\n        '--':   \"DECREMENT\",\n        '+':    \"PLUS\",\n        '-':    \"MINUS\",\n        '*':    \"MUL\",\n        '/':    \"DIV\",\n        '%':    \"MOD\",\n        '!':    \"NOT\",\n        '~':    \"BITWISE_NOT\",\n        '.':    \"DOT\",\n        '[':    \"LEFT_BRACKET\",\n        ']':    \"RIGHT_BRACKET\",\n        '{':    \"LEFT_CURLY\",\n        '}':    \"RIGHT_CURLY\",\n        '(':    \"LEFT_PAREN\",\n        ')':    \"RIGHT_PAREN\"\n    };\n\n    // Hash of keyword identifier to tokens index.  NB: we must null __proto__ to\n    // avoid toString, etc. namespace pollution.\n    var keywords = {__proto__: null};\n\n    // Define const END, etc., based on the token names.  Also map name to index.\n    var tokenIds = {};\n\n    // Building up a string to be eval'd in different contexts.\n    var consts = \"const \";\n    for (var i = 0, j = tokens.length; i < j; i++) {\n        if (i > 0)\n            consts += \", \";\n        var t = tokens[i];\n        var name;\n        if (/^[a-z]/.test(t)) {\n            name = t.toUpperCase();\n            keywords[t] = i;\n        } else {\n            name = (/^\\W/.test(t) ? opTypeNames[t] : t);\n        }\n        consts += name + \" = \" + i;\n        tokenIds[name] = i;\n        tokens[t] = i;\n    }\n    consts += \";\";\n\n    var isStatementStartCode = {__proto__: null};\n    for (i = 0, j = statementStartTokens.length; i < j; i++)\n        isStatementStartCode[keywords[statementStartTokens[i]]] = true;\n\n    // Map assignment operators to their indexes in the tokens array.\n    var assignOps = ['|', '^', '&', '<<', '>>', '>>>', '+', '-', '*', '/', '%'];\n\n    for (i = 0, j = assignOps.length; i < j; i++) {\n        t = assignOps[i];\n        assignOps[t] = tokens[t];\n    }\n\n    function defineGetter(obj, prop, fn, dontDelete, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { get: fn, configurable: !dontDelete, enumerable: !dontEnum });\n    }\n\n    function defineProperty(obj, prop, val, dontDelete, readOnly, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { value: val, writable: !readOnly, configurable: !dontDelete,\n                                enumerable: !dontEnum });\n    }\n\n    // Returns true if fn is a native function.  (Note: SpiderMonkey specific.)\n    function isNativeCode(fn) {\n        // Relies on the toString method to identify native code.\n        return ((typeof fn) === \"function\") && fn.toString().match(/\\[native code\\]/);\n    }\n\n    function getPropertyDescriptor(obj, name) {\n        while (obj) {\n            if (({}).hasOwnProperty.call(obj, name))\n                return Object.getOwnPropertyDescriptor(obj, name);\n            obj = Object.getPrototypeOf(obj);\n        }\n    }\n\n    function getOwnProperties(obj) {\n        var map = {};\n        for (var name in Object.getOwnPropertyNames(obj))\n            map[name] = Object.getOwnPropertyDescriptor(obj, name);\n        return map;\n    }\n\n    function makePassthruHandler(obj) {\n        // Handler copied from\n        // http://wiki.ecmascript.org/doku.php?id=harmony:proxies&s=proxy%20object#examplea_no-op_forwarding_proxy\n        return {\n            getOwnPropertyDescriptor: function(name) {\n                var desc = Object.getOwnPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getPropertyDescriptor: function(name) {\n                var desc = getPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getOwnPropertyNames: function() {\n                return Object.getOwnPropertyNames(obj);\n            },\n            defineProperty: function(name, desc) {\n                Object.defineProperty(obj, name, desc);\n            },\n            \"delete\": function(name) { return delete obj[name]; },\n            fix: function() {\n                if (Object.isFrozen(obj)) {\n                    return getOwnProperties(obj);\n                }\n\n                // As long as obj is not frozen, the proxy won't allow itself to be fixed.\n                return undefined; // will cause a TypeError to be thrown\n            },\n\n            has: function(name) { return name in obj; },\n            hasOwn: function(name) { return ({}).hasOwnProperty.call(obj, name); },\n            get: function(receiver, name) { return obj[name]; },\n\n            // bad behavior when set fails in non-strict mode\n            set: function(receiver, name, val) { obj[name] = val; return true; },\n            enumerate: function() {\n                var result = [];\n                for (name in obj) { result.push(name); };\n                return result;\n            },\n            keys: function() { return Object.keys(obj); }\n        };\n    }\n\n    // default function used when looking for a property in the global object\n    function noPropFound() { return undefined; }\n\n    var hasOwnProperty = ({}).hasOwnProperty;\n\n    function StringMap() {\n        this.table = Object.create(null, {});\n        this.size = 0;\n    }\n\n    StringMap.prototype = {\n        has: function(x) { return hasOwnProperty.call(this.table, x); },\n        set: function(x, v) {\n            if (!hasOwnProperty.call(this.table, x))\n                this.size++;\n            this.table[x] = v;\n        },\n        get: function(x) { return this.table[x]; },\n        getDef: function(x, thunk) {\n            if (!hasOwnProperty.call(this.table, x)) {\n                this.size++;\n                this.table[x] = thunk();\n            }\n            return this.table[x];\n        },\n        forEach: function(f) {\n            var table = this.table;\n            for (var key in table)\n                f.call(this, key, table[key]);\n        },\n        toString: function() { return \"[object StringMap]\" }\n    };\n\n    // non-destructive stack\n    function Stack(elts) {\n        this.elts = elts || null;\n    }\n\n    Stack.prototype = {\n        push: function(x) {\n            return new Stack({ top: x, rest: this.elts });\n        },\n        top: function() {\n            if (!this.elts)\n                throw new Error(\"empty stack\");\n            return this.elts.top;\n        },\n        isEmpty: function() {\n            return this.top === null;\n        },\n        find: function(test) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                if (test(elts.top))\n                    return elts.top;\n            }\n            return null;\n        },\n        has: function(x) {\n            return Boolean(this.find(function(elt) { return elt === x }));\n        },\n        forEach: function(f) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                f(elts.top);\n            }\n        }\n    };\n\n    return {\n        tokens: tokens,\n        opTypeNames: opTypeNames,\n        keywords: keywords,\n        isStatementStartCode: isStatementStartCode,\n        tokenIds: tokenIds,\n        consts: consts,\n        assignOps: assignOps,\n        defineGetter: defineGetter,\n        defineProperty: defineProperty,\n        isNativeCode: isNativeCode,\n        makePassthruHandler: makePassthruHandler,\n        noPropFound: noPropFound,\n        StringMap: StringMap,\n        Stack: Stack\n    };\n}());\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Lexical scanner.\n */\n\nNarcissus.lexer = (function() {\n\n    var definitions = Narcissus.definitions;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    // Build up a trie of operator tokens.\n    var opTokens = {};\n    for (var op in definitions.opTypeNames) {\n        if (op === '\\n' || op === '.')\n            continue;\n\n        var node = opTokens;\n        for (var i = 0; i < op.length; i++) {\n            var ch = op[i];\n            if (!(ch in node))\n                node[ch] = {};\n            node = node[ch];\n            node.op = op;\n        }\n    }\n\n    /*\n     * Tokenizer :: (source, filename, line number) -> Tokenizer\n     */\n    function Tokenizer(s, f, l) {\n        this.cursor = 0;\n        this.source = String(s);\n        this.tokens = [];\n        this.tokenIndex = 0;\n        this.lookahead = 0;\n        this.scanNewlines = false;\n        this.unexpectedEOF = false;\n        this.filename = f || \"\";\n        this.lineno = l || 1;\n        this.comments = [];\n    }\n\n    Tokenizer.prototype = {\n        get done() {\n            // We need to set scanOperand to true here because the first thing\n            // might be a regexp.\n            return this.peek(true) === END;\n        },\n\n        get token() {\n            return this.tokens[this.tokenIndex];\n        },\n\n        match: function (tt, scanOperand) {\n            return this.get(scanOperand) === tt || this.unget();\n        },\n\n        mustMatch: function (tt) {\n            if (!this.match(tt)) {\n                throw this.newSyntaxError(\"Missing \" +\n                                          definitions.tokens[tt].toLowerCase());\n            }\n            return this.token;\n        },\n\n        peek: function (scanOperand) {\n            var tt, next;\n            if (this.lookahead) {\n                next = this.tokens[(this.tokenIndex + this.lookahead) & 3];\n                tt = (this.scanNewlines && next.lineno !== this.lineno)\n                     ? NEWLINE\n                     : next.type;\n            } else {\n                tt = this.get(scanOperand);\n                this.unget();\n            }\n            return tt;\n        },\n\n        peekOnSameLine: function (scanOperand) {\n            this.scanNewlines = true;\n            var tt = this.peek(scanOperand);\n            this.scanNewlines = false;\n            return tt;\n        },\n\n        // Eat comments and whitespace.\n        // toka: returns list of skipped comments\n        skip: function () {\n            var input = this.source;\n            var cstart;\n            var clineno;\n            var comments = [];\n            var comment;\n            var nlcount = 0;\n\n            for (;;) {\n                var ch = input[this.cursor++];\n                var next = input[this.cursor];\n                if (ch === '\\n' && !this.scanNewlines) {\n                    this.lineno++;\n                    nlcount++;\n                } else if (ch === '/' && next === '*') {\n                    cstart = this.cursor;\n                    clineno = this.lineno;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated comment\");\n\n                        if (ch === '*') {\n                            next = input[this.cursor];\n                            if (next === '/') {\n                                this.cursor++;\n                                comment = {\n                                    type: \"BLOCK_COMMENT\",\n                                    nlcount: nlcount,\n                                    start:cstart-1, end:this.cursor, lineno:clineno, endlineno: this.lineno,\n                                    value: input.substring(cstart+1,this.cursor-2)\n                                }\n                                // comments.push(comment);\n                                this.comments.push(comment);\n                                nlcount = 0;\n                                break;\n                            }\n                        } else if (ch === '\\n') {\n                            this.lineno++;\n                        }\n                    }\n                } else if (ch === '/' && next === '/') {\n                    cstart = this.cursor;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined) {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            // comments.push(comment);\n                            this.comments.push(comment);\n                            return;\n                            // return comments;\n                        }\n                        if (ch === '\\n') {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            //comments.push(  );\n                            this.comments.push(comment);\n                            nlcount = 0;\n                            this.lineno++;\n                            break;\n                        }\n                    }\n                } else if (ch !== ' ' && ch !== '\\t') {\n                    this.cursor--;\n                    // return comments;\n                    return;\n                }\n            }\n        },\n\n        // Lex the exponential part of a number, if present. Return true iff an\n        // exponential part was found.\n        lexExponent: function() {\n            var input = this.source;\n            var next = input[this.cursor];\n            if (next === 'e' || next === 'E') {\n                this.cursor++;\n                ch = input[this.cursor++];\n                if (ch === '+' || ch === '-')\n                    ch = input[this.cursor++];\n\n                if (ch < '0' || ch > '9')\n                    throw this.newSyntaxError(\"Missing exponent\");\n\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                return true;\n            }\n\n            return false;\n        },\n\n        lexZeroNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            ch = input[this.cursor++];\n            if (ch === '.') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n                token.value = parseFloat(token.start, this.cursor);\n            } else if (ch === 'x' || ch === 'X') {\n                do {\n                    ch = input[this.cursor++];\n                } while ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||\n                         (ch >= 'A' && ch <= 'F'));\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else if (ch >= '0' && ch <= '7') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '7');\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else {\n                this.cursor--;\n                this.lexExponent();     // 0E1, &c.\n                token.value = 0;\n            }\n        },\n\n        lexNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            var floating = false;\n            do {\n                ch = input[this.cursor++];\n                if (ch === '.' && !floating) {\n                    floating = true;\n                    ch = input[this.cursor++];\n                }\n            } while (ch >= '0' && ch <= '9');\n\n            this.cursor--;\n\n            var exponent = this.lexExponent();\n            floating = floating || exponent;\n\n            var str = input.substring(token.start, this.cursor);\n            token.value = floating ? parseFloat(str) : parseInt(str);\n        },\n\n        lexDot: function (ch) {\n            var token = this.token, input = this.source;\n            var next = input[this.cursor];\n            if (next >= '0' && next <= '9') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n\n                token.type = NUMBER;\n                token.value = parseFloat(token.start, this.cursor);\n            } else {\n                token.type = DOT;\n                token.assignOp = null;\n                token.value = '.';\n            }\n        },\n\n        lexString: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = STRING;\n\n            var hasEscapes = false;\n            var delim = ch;\n            while ((ch = input[this.cursor++]) !== delim) {\n                // [JS2COFFEE] Fixed to make it work on a browser\n                if (this.cursor >= input.length)\n                    throw this.newSyntaxError(\"Unterminated string literal\");\n                if (ch === '\\\\') {\n                    hasEscapes = true;\n                    if (++this.cursor == input.length)\n                        throw this.newSyntaxError(\"Unterminated string literal\");\n                }\n            }\n\n            token.value = hasEscapes\n                          ? eval(input.substring(token.start, this.cursor))\n                          : input.substring(token.start + 1, this.cursor - 1);\n        },\n\n        lexRegExp: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = REGEXP;\n\n            do {\n                ch = input[this.cursor++];\n                if (ch === '\\\\') {\n                    this.cursor++;\n                } else if (ch === '[') {\n                    do {\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated character class\");\n\n                        if (ch === '\\\\')\n                            this.cursor++;\n\n                        ch = input[this.cursor++];\n                    } while (ch !== ']');\n                } else if (ch === undefined) {\n                    throw this.newSyntaxError(\"Unterminated regex\");\n                }\n            } while (ch !== '/');\n\n            do {\n                ch = input[this.cursor++];\n            } while (ch >= 'a' && ch <= 'z');\n\n            this.cursor--;\n\n            token.value = eval(input.substring(token.start, this.cursor));\n        },\n\n        lexOp: function (ch) {\n            var token = this.token, input = this.source;\n\n            // A bit ugly, but it seems wasteful to write a trie lookup routine\n            // for only 3 characters...\n            var node = opTokens[ch];\n            var next = input[this.cursor];\n            if (next in node) {\n                node = node[next];\n                this.cursor++;\n                next = input[this.cursor];\n                if (next in node) {\n                    node = node[next];\n                    this.cursor++;\n                    next = input[this.cursor];\n                }\n            }\n\n            var op = node.op;\n            if (definitions.assignOps[op] && input[this.cursor] === '=') {\n                this.cursor++;\n                token.type = ASSIGN;\n                token.assignOp = definitions.tokenIds[definitions.opTypeNames[op]];\n                op += '=';\n            } else {\n                token.type = definitions.tokenIds[definitions.opTypeNames[op]];\n                token.assignOp = null;\n            }\n\n            token.value = op;\n        },\n\n        // FIXME: Unicode escape sequences\n        // FIXME: Unicode identifiers\n        lexIdent: function (ch) {\n            var token = this.token, input = this.source;\n\n            do {\n                ch = input[this.cursor++];\n            } while ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n                     (ch >= '0' && ch <= '9') || ch === '$' || ch === '_');\n\n            this.cursor--;  // Put the non-word character back.\n\n            var id = input.substring(token.start, this.cursor);\n            token.type = definitions.keywords[id] || IDENTIFIER;\n            token.value = id;\n        },\n\n        /*\n         * Tokenizer.get :: void -> token type\n         *\n         * Consume input *only* if there is no lookahead.\n         * Dispatch to the appropriate lexing function depending on the input.\n         */\n        get: function (scanOperand) {\n            var token;\n            while (this.lookahead) {\n                --this.lookahead;\n                this.tokenIndex = (this.tokenIndex + 1) & 3;\n                token = this.tokens[this.tokenIndex];\n                if (token.type !== NEWLINE || this.scanNewlines)\n                    return token.type;\n            }\n\n            // var comments =\n            this.skip();\n\n            this.tokenIndex = (this.tokenIndex + 1) & 3;\n            token = this.tokens[this.tokenIndex];\n            if (!token)\n                this.tokens[this.tokenIndex] = token = {};\n\n            var input = this.source;\n            if (this.cursor === input.length)\n                return token.type = END;\n\n            token.start = this.cursor;\n            token.lineno = this.lineno;\n\n            var ch = input[this.cursor++];\n            if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '$' || ch === '_') {\n                this.lexIdent(ch);\n            } else if (scanOperand && ch === '/') {\n                this.lexRegExp(ch);\n            } else if (ch in opTokens) {\n                this.lexOp(ch);\n            } else if (ch === '.') {\n                this.lexDot(ch);\n            } else if (ch >= '1' && ch <= '9') {\n                this.lexNumber(ch);\n            } else if (ch === '0') {\n                this.lexZeroNumber(ch);\n            } else if (ch === '\"' || ch === \"'\") {\n                this.lexString(ch);\n            } else if (this.scanNewlines && ch === '\\n') {\n                token.type = NEWLINE;\n                token.value = '\\n';\n                this.lineno++;\n            } else {\n                throw this.newSyntaxError(\"Illegal token\");\n            }\n\n            token.end = this.cursor;\n            // token.comments = [comments,this.skip()];\n            return token.type;\n        },\n\n        /*\n         * Tokenizer.unget :: void -> undefined\n         *\n         * Match depends on unget returning undefined.\n         */\n        unget: function () {\n            if (++this.lookahead === 4) throw \"PANIC: too much lookahead!\";\n            this.tokenIndex = (this.tokenIndex - 1) & 3;\n        },\n\n        newSyntaxError: function (m) {\n            var e = new SyntaxError(m, this.filename, this.lineno);\n            e.source = this.source;\n            e.cursor = this.lookahead\n                       ? this.tokens[(this.tokenIndex + this.lookahead) & 3].start\n                       : this.cursor;\n            return e;\n        },\n    };\n\n    return { Tokenizer: Tokenizer };\n\n}());\n\n/* -*- Mode: JS; tab-width: 4; indent-tabs-mode: nil; -*-\n * vim: set sw=4 ts=4 et tw=78:\n * ***** BEGIN LICENSE BLOCK *****\n *\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Parser.\n */\n\nNarcissus.parser = (function() {\n\n    var lexer = Narcissus.lexer;\n    var definitions = Narcissus.definitions;\n\n    const StringMap = definitions.StringMap;\n    const Stack = definitions.Stack;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    /*\n     * pushDestructuringVarDecls :: (node, hoisting node) -> void\n     *\n     * Recursively add all destructured declarations to varDecls.\n     */\n    function pushDestructuringVarDecls(n, s) {\n        for (var i in n) {\n            var sub = n[i];\n            if (sub.type === IDENTIFIER) {\n                s.varDecls.push(sub);\n            } else {\n                pushDestructuringVarDecls(sub, s);\n            }\n        }\n    }\n\n    // NESTING_TOP: top-level\n    // NESTING_SHALLOW: nested within static forms such as { ... } or labeled statement\n    // NESTING_DEEP: nested within dynamic forms such as if, loops, etc.\n    const NESTING_TOP = 0, NESTING_SHALLOW = 1, NESTING_DEEP = 2;\n\n    function StaticContext(parentScript, parentBlock, inFunction, inForLoopInit, nesting) {\n        this.parentScript = parentScript;\n        this.parentBlock = parentBlock;\n        this.inFunction = inFunction;\n        this.inForLoopInit = inForLoopInit;\n        this.nesting = nesting;\n        this.allLabels = new Stack();\n        this.currentLabels = new Stack();\n        this.labeledTargets = new Stack();\n        this.defaultTarget = null;\n        Narcissus.options.ecma3OnlyMode && (this.ecma3OnlyMode = true);\n        Narcissus.options.parenFreeMode && (this.parenFreeMode = true);\n    }\n\n    StaticContext.prototype = {\n        ecma3OnlyMode: false,\n        parenFreeMode: false,\n        // non-destructive update via prototype extension\n        update: function(ext) {\n            var desc = {};\n            for (var key in ext) {\n                desc[key] = {\n                    value: ext[key],\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                }\n            }\n            return Object.create(this, desc);\n        },\n        pushLabel: function(label) {\n            return this.update({ currentLabels: this.currentLabels.push(label),\n                                 allLabels: this.allLabels.push(label) });\n        },\n        pushTarget: function(target) {\n            var isDefaultTarget = target.isLoop || target.type === SWITCH;\n\n            if (this.currentLabels.isEmpty()) {\n                return isDefaultTarget\n                     ? this.update({ defaultTarget: target })\n                     : this;\n            }\n\n            target.labels = new StringMap();\n            this.currentLabels.forEach(function(label) {\n                target.labels.set(label, true);\n            });\n            return this.update({ currentLabels: new Stack(),\n                                 labeledTargets: this.labeledTargets.push(target),\n                                 defaultTarget: isDefaultTarget\n                                                ? target\n                                                : this.defaultTarget });\n        },\n        nest: function(atLeast) {\n            var nesting = Math.max(this.nesting, atLeast);\n            return (nesting !== this.nesting)\n                 ? this.update({ nesting: nesting })\n                 : this;\n        }\n    };\n\n    /*\n     * Script :: (tokenizer, boolean) -> node\n     *\n     * Parses the toplevel and function bodies.\n     */\n    function Script(t, inFunction) {\n        var n = new Node(t, scriptInit());\n        var x = new StaticContext(n, n, inFunction, false, NESTING_TOP);\n        Statements(t, x, n);\n        return n;\n    }\n\n    // We extend Array slightly with a top-of-stack method.\n    definitions.defineProperty(Array.prototype, \"top\",\n                               function() {\n                                   return this.length && this[this.length-1];\n                               }, false, false, true);\n\n    /*\n     * Node :: (tokenizer, optional init object) -> node\n     */\n    function Node(t, init) {\n        var token = t.token;\n        if (token) {\n            // If init.type exists it will override token.type.\n            this.type = token.type;\n            this.value = token.value;\n            this.lineno = token.lineno;\n\n            // Start and end are file positions for error handling.\n            this.start = token.start;\n            this.end = token.end;\n\n        } else {\n            this.lineno = t.lineno;\n        }\n\n        // Node uses a tokenizer for debugging (getSource, filename getter).\n        this.tokenizer = t;\n        this.children = [];\n\n        for (var prop in init)\n            this[prop] = init[prop];\n    }\n\n    var Np = Node.prototype = {};\n    Np.constructor = Node;\n    Np.toSource = Object.prototype.toSource;\n\n    // Always use push to add operands to an expression, to update start and end.\n    Np.push = function (kid) {\n        // kid can be null e.g. [1, , 2].\n        if (kid !== null) {\n            if (kid.start < this.start)\n                this.start = kid.start;\n            if (this.end < kid.end)\n                this.end = kid.end;\n        }\n        return this.children.push(kid);\n    }\n\n    Node.indentLevel = 0;\n\n    function tokenString(tt) {\n        var t = definitions.tokens[tt];\n        return /^\\W/.test(t) ? definitions.opTypeNames[t] : t.toUpperCase();\n    }\n\n    Np.toString = function () {\n        var a = [];\n        for (var i in this) {\n            if (this.hasOwnProperty(i) && i !== 'type' && i !== 'target')\n                a.push({id: i, value: this[i]});\n        }\n        a.sort(function (a,b) { return (a.id < b.id) ? -1 : 1; });\n        const INDENTATION = \"    \";\n        var n = ++Node.indentLevel;\n        var s = \"{\\n\" + INDENTATION.repeat(n) + \"type: \" + tokenString(this.type);\n        for (i = 0; i < a.length; i++)\n            s += \",\\n\" + INDENTATION.repeat(n) + a[i].id + \": \" + a[i].value;\n        n = --Node.indentLevel;\n        s += \"\\n\" + INDENTATION.repeat(n) + \"}\";\n        return s;\n    }\n\n    Np.getSource = function () {\n        return this.tokenizer.source.slice(this.start, this.end);\n    };\n\n    /*\n     * Helper init objects for common nodes.\n     */\n\n    const LOOP_INIT = { isLoop: true };\n\n    function blockInit() {\n        return { type: BLOCK, varDecls: [] };\n    }\n\n    function scriptInit() {\n        return { type: SCRIPT,\n                 funDecls: [],\n                 varDecls: [],\n                 modDecls: [],\n                 impDecls: [],\n                 expDecls: [],\n                 loadDeps: [],\n                 hasEmptyReturn: false,\n                 hasReturnWithValue: false,\n                 isGenerator: false };\n    }\n\n    definitions.defineGetter(Np, \"filename\",\n                             function() {\n                                 return this.tokenizer.filename;\n                             });\n\n    definitions.defineGetter(Np, \"length\",\n                             function() {\n                                 throw new Error(\"Node.prototype.length is gone; \" +\n                                                 \"use n.children.length instead\");\n                             });\n\n    definitions.defineProperty(String.prototype, \"repeat\",\n                               function(n) {\n                                   var s = \"\", t = this + s;\n                                   while (--n >= 0)\n                                       s += t;\n                                   return s;\n                               }, false, false, true);\n\n    function MaybeLeftParen(t, x) {\n        if (x.parenFreeMode)\n            return t.match(LEFT_PAREN) ? LEFT_PAREN : END;\n        return t.mustMatch(LEFT_PAREN).type;\n    }\n\n    function MaybeRightParen(t, p) {\n        if (p === LEFT_PAREN)\n            t.mustMatch(RIGHT_PAREN);\n    }\n\n    /*\n     * Statements :: (tokenizer, compiler context, node) -> void\n     *\n     * Parses a sequence of Statements.\n     */\n    function Statements(t, x, n) {\n        try {\n            while (!t.done && t.peek(true) !== RIGHT_CURLY)\n            { n.push(Statement(t, x)); }\n        } catch (e) {\n            if (t.done)\n            { t.unexpectedEOF = true; }\n            throw(e);\n        }\n    }\n\n    function Block(t, x) {\n        t.mustMatch(LEFT_CURLY);\n        var n = new Node(t, blockInit());\n        Statements(t, x.update({ parentBlock: n }).pushTarget(n), n);\n        t.mustMatch(RIGHT_CURLY);\n        return n;\n    }\n\n    const DECLARED_FORM = 0, EXPRESSED_FORM = 1, STATEMENT_FORM = 2;\n\n    /*\n     * Statement :: (tokenizer, compiler context) -> node\n     *\n     * Parses a Statement.\n     */\n    function Statement(t, x) {\n        var i, label, n, n2, p, c, ss, tt = t.get(true), tt2, x2, x3;\n\n        // Cases for statements ending in a right curly return early, avoiding the\n        // common semicolon insertion magic after this switch.\n        switch (tt) {\n          case FUNCTION:\n            // DECLARED_FORM extends funDecls of x, STATEMENT_FORM doesn't.\n            return FunctionDefinition(t, x, true,\n                                      (x.nesting !== NESTING_TOP)\n                                      ? STATEMENT_FORM\n                                      : DECLARED_FORM);\n\n          case LEFT_CURLY:\n            n = new Node(t, blockInit());\n            Statements(t, x.update({ parentBlock: n }).pushTarget(n).nest(NESTING_SHALLOW), n);\n            t.mustMatch(RIGHT_CURLY);\n            return n;\n\n          case IF:\n            n = new Node(t);\n            n.condition = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            n.thenPart = Statement(t, x2);\n            n.elsePart = t.match(ELSE) ? Statement(t, x2) : null;\n            return n;\n\n          case SWITCH:\n            // This allows CASEs after a DEFAULT, which is in the standard.\n            n = new Node(t, { cases: [], defaultIndex: -1 });\n            n.discriminant = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            t.mustMatch(LEFT_CURLY);\n            while ((tt = t.get()) !== RIGHT_CURLY) {\n                switch (tt) {\n                  case DEFAULT:\n                    if (n.defaultIndex >= 0)\n                        throw t.newSyntaxError(\"More than one switch default\");\n                    // FALL THROUGH\n                  case CASE:\n                    n2 = new Node(t);\n                    if (tt === DEFAULT)\n                        n.defaultIndex = n.cases.length;\n                    else\n                        n2.caseLabel = Expression(t, x2, COLON);\n                    break;\n\n                  default:\n                    throw t.newSyntaxError(\"Invalid switch case\");\n                }\n                t.mustMatch(COLON);\n                n2.statements = new Node(t, blockInit());\n                while ((tt=t.peek(true)) !== CASE && tt !== DEFAULT &&\n                        tt !== RIGHT_CURLY)\n                    n2.statements.push(Statement(t, x2));\n                n.cases.push(n2);\n            }\n            return n;\n\n          case FOR:\n            n = new Node(t, LOOP_INIT);\n            if (t.match(IDENTIFIER)) {\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(LEFT_PAREN);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            x3 = x.update({ inForLoopInit: true });\n            if ((tt = t.peek()) !== SEMICOLON) {\n                if (tt === VAR || tt === CONST) {\n                    t.get();\n                    n2 = Variables(t, x3);\n                } else if (tt === LET) {\n                    t.get();\n                    if (t.peek() === LEFT_PAREN) {\n                        n2 = LetBlock(t, x3, false);\n                    } else {\n                        // Let in for head, we need to add an implicit block\n                        // around the rest of the for.\n                        x3.parentBlock = n;\n                        n.varDecls = [];\n                        n2 = Variables(t, x3);\n                    }\n                } else {\n                    n2 = Expression(t, x3);\n                }\n            }\n            if (n2 && t.match(IN)) {\n                n.type = FOR_IN;\n                n.object = Expression(t, x3);\n                if (n2.type === VAR || n2.type === LET) {\n                    c = n2.children;\n\n                    // Destructuring turns one decl into multiples, so either\n                    // there must be only one destructuring or only one\n                    // decl.\n                    if (c.length !== 1 && n2.destructurings.length !== 1) {\n                        throw new SyntaxError(\"Invalid for..in left-hand side\",\n                                              t.filename, n2.lineno);\n                    }\n                    if (n2.destructurings.length > 0) {\n                        n.iterator = n2.destructurings[0];\n                    } else {\n                        n.iterator = c[0];\n                    }\n                    n.varDecl = n2;\n                } else {\n                    if (n2.type === ARRAY_INIT || n2.type === OBJECT_INIT) {\n                        n2.destructuredNames = checkDestructuring(t, x3, n2);\n                    }\n                    n.iterator = n2;\n                }\n            } else {\n                n.setup = n2;\n                t.mustMatch(SEMICOLON);\n                if (n.isEach)\n                    throw t.newSyntaxError(\"Invalid for each..in loop\");\n                n.condition = (t.peek() === SEMICOLON)\n                              ? null\n                              : Expression(t, x3);\n                t.mustMatch(SEMICOLON);\n                tt2 = t.peek();\n                n.update = (x.parenFreeMode\n                            ? tt2 === LEFT_CURLY || definitions.isStatementStartCode[tt2]\n                            : tt2 === RIGHT_PAREN)\n                           ? null\n                           : Expression(t, x3);\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(RIGHT_PAREN);\n            n.body = Statement(t, x2);\n            return n;\n\n          case WHILE:\n            n = new Node(t, { isLoop: true });\n            n.condition = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case DO:\n            n = new Node(t, { isLoop: true });\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            t.mustMatch(WHILE);\n            n.condition = HeadExpression(t, x);\n            if (!x.ecmaStrictMode) {\n                // <script language=\"JavaScript\"> (without version hints) may need\n                // automatic semicolon insertion without a newline after do-while.\n                // See http://bugzilla.mozilla.org/show_bug.cgi?id=238945.\n                t.match(SEMICOLON);\n                return n;\n            }\n            break;\n\n          case BREAK:\n          case CONTINUE:\n            n = new Node(t);\n\n            // handle the |foo: break foo;| corner case\n            x2 = x.pushTarget(n);\n\n            if (t.peekOnSameLine() === IDENTIFIER) {\n                t.get();\n                n.label = t.token.value;\n            }\n\n            n.target = n.label\n                     ? x2.labeledTargets.find(function(target) { return target.labels.has(n.label) })\n                     : x2.defaultTarget;\n\n            if (!n.target)\n                throw t.newSyntaxError(\"Invalid \" + ((tt === BREAK) ? \"break\" : \"continue\"));\n            if (!n.target.isLoop && tt === CONTINUE)\n                throw t.newSyntaxError(\"Invalid continue\");\n\n            break;\n\n          case TRY:\n            n = new Node(t, { catchClauses: [] });\n            n.tryBlock = Block(t, x);\n            while (t.match(CATCH)) {\n                n2 = new Node(t);\n                p = MaybeLeftParen(t, x);\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured catch identifiers.\n                    t.unget();\n                    n2.varName = DestructuringExpression(t, x, true);\n                    break;\n                  case IDENTIFIER:\n                    n2.varName = t.token.value;\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing identifier in catch\");\n                    break;\n                }\n                if (t.match(IF)) {\n                    if (x.ecma3OnlyMode)\n                        throw t.newSyntaxError(\"Illegal catch guard\");\n                    if (n.catchClauses.length && !n.catchClauses.top().guard)\n                        throw t.newSyntaxError(\"Guarded catch after unguarded\");\n                    n2.guard = Expression(t, x);\n                }\n                MaybeRightParen(t, p);\n                n2.block = Block(t, x);\n                n.catchClauses.push(n2);\n            }\n            if (t.match(FINALLY))\n                n.finallyBlock = Block(t, x);\n            if (!n.catchClauses.length && !n.finallyBlock)\n                throw t.newSyntaxError(\"Invalid try statement\");\n            return n;\n\n          case CATCH:\n          case FINALLY:\n            throw t.newSyntaxError(definitions.tokens[tt] + \" without preceding try\");\n\n          case THROW:\n            n = new Node(t);\n            n.exception = Expression(t, x);\n            break;\n\n          case RETURN:\n            n = ReturnOrYield(t, x);\n            break;\n\n          case WITH:\n            n = new Node(t);\n            n.object = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case VAR:\n          case CONST:\n            n = Variables(t, x);\n            break;\n\n          case LET:\n            if (t.peek() === LEFT_PAREN)\n                n = LetBlock(t, x, true);\n            else\n                n = Variables(t, x);\n            break;\n\n          case DEBUGGER:\n            n = new Node(t);\n            break;\n\n          case NEWLINE:\n          case SEMICOLON:\n            n = new Node(t, { type: SEMICOLON });\n            n.expression = null;\n            return n;\n\n          default:\n            if (tt === IDENTIFIER) {\n                tt = t.peek();\n                // Labeled statement.\n                if (tt === COLON) {\n                    label = t.token.value;\n                    if (x.allLabels.has(label))\n                        throw t.newSyntaxError(\"Duplicate label\");\n                    t.get();\n                    n = new Node(t, { type: LABEL, label: label });\n                    n.statement = Statement(t, x.pushLabel(label).nest(NESTING_SHALLOW));\n                    n.target = (n.statement.type === LABEL) ? n.statement.target : n.statement;\n                    return n;\n                }\n            }\n\n            // Expression statement.\n            // We unget the current token to parse the expression as a whole.\n            n = new Node(t, { type: SEMICOLON });\n            t.unget();\n            n.expression = Expression(t, x);\n            n.end = n.expression.end;\n            break;\n        }\n\n        MagicalSemicolon(t);\n        return n;\n    }\n\n    function MagicalSemicolon(t) {\n        var tt;\n        if (t.lineno === t.token.lineno) {\n            tt = t.peekOnSameLine();\n            if (tt !== END && tt !== NEWLINE && tt !== SEMICOLON && tt !== RIGHT_CURLY)\n                throw t.newSyntaxError(\"missing ; before statement\");\n        }\n        t.match(SEMICOLON);\n    }\n\n    function ReturnOrYield(t, x) {\n        var n, b, tt = t.token.type, tt2;\n\n        var parentScript = x.parentScript;\n\n        if (tt === RETURN) {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Return not in function\");\n        } else /* if (tt === YIELD) */ {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Yield not in function\");\n            parentScript.isGenerator = true;\n        }\n        n = new Node(t, { value: undefined });\n\n        tt2 = t.peek(true);\n        if (tt2 !== END && tt2 !== NEWLINE &&\n            tt2 !== SEMICOLON && tt2 !== RIGHT_CURLY\n            && (tt !== YIELD ||\n                (tt2 !== tt && tt2 !== RIGHT_BRACKET && tt2 !== RIGHT_PAREN &&\n                 tt2 !== COLON && tt2 !== COMMA))) {\n            if (tt === RETURN) {\n                n.value = Expression(t, x);\n                parentScript.hasReturnWithValue = true;\n            } else {\n                n.value = AssignExpression(t, x);\n            }\n        } else if (tt === RETURN) {\n            parentScript.hasEmptyReturn = true;\n        }\n\n        // Disallow return v; in generator.\n        if (parentScript.hasReturnWithValue && parentScript.isGenerator)\n            throw t.newSyntaxError(\"Generator returns a value\");\n\n        return n;\n    }\n\n    /*\n     * FunctionDefinition :: (tokenizer, compiler context, boolean,\n     *                        DECLARED_FORM or EXPRESSED_FORM or STATEMENT_FORM)\n     *                    -> node\n     */\n    function FunctionDefinition(t, x, requireName, functionForm) {\n        var tt;\n        var f = new Node(t, { params: [] });\n        if (f.type !== FUNCTION)\n            f.type = (f.value === \"get\") ? GETTER : SETTER;\n        if (t.match(IDENTIFIER))\n            f.name = t.token.value;\n        else if (requireName)\n            throw t.newSyntaxError(\"missing function identifier\");\n\n        var x2 = new StaticContext(null, null, true, false, NESTING_TOP);\n\n        t.mustMatch(LEFT_PAREN);\n        if (!t.match(RIGHT_PAREN)) {\n            do {\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured formal parameters.\n                    t.unget();\n                    f.params.push(DestructuringExpression(t, x2));\n                    break;\n                  case IDENTIFIER:\n                    f.params.push(t.token.value);\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing formal parameter\");\n                    break;\n                }\n            } while (t.match(COMMA));\n            t.mustMatch(RIGHT_PAREN);\n        }\n\n        // Do we have an expression closure or a normal body?\n        tt = t.get();\n        if (tt !== LEFT_CURLY)\n            t.unget();\n\n        if (tt !== LEFT_CURLY) {\n            f.body = AssignExpression(t, x2);\n            if (f.body.isGenerator)\n                throw t.newSyntaxError(\"Generator returns a value\");\n        } else {\n            f.body = Script(t, true);\n        }\n\n        if (tt === LEFT_CURLY)\n            t.mustMatch(RIGHT_CURLY);\n\n        f.end = t.token.end;\n        f.functionForm = functionForm;\n        if (functionForm === DECLARED_FORM)\n            x.parentScript.funDecls.push(f);\n        return f;\n    }\n\n    /*\n     * Variables :: (tokenizer, compiler context) -> node\n     *\n     * Parses a comma-separated list of var declarations (and maybe\n     * initializations).\n     */\n    function Variables(t, x, letBlock) {\n        var n, n2, ss, i, s, tt;\n\n        tt = t.token.type;\n        switch (tt) {\n          case VAR:\n          case CONST:\n            s = x.parentScript;\n            break;\n          case LET:\n            s = x.parentBlock;\n            break;\n          case LEFT_PAREN:\n            tt = LET;\n            s = letBlock;\n            break;\n        }\n\n        n = new Node(t, { type: tt, destructurings: [] });\n\n        do {\n            tt = t.get();\n            if (tt === LEFT_BRACKET || tt === LEFT_CURLY) {\n                // Need to unget to parse the full destructured expression.\n                t.unget();\n\n                var dexp = DestructuringExpression(t, x, true);\n\n                n2 = new Node(t, { type: IDENTIFIER,\n                                   name: dexp,\n                                   readOnly: n.type === CONST });\n                n.push(n2);\n                pushDestructuringVarDecls(n2.name.destructuredNames, s);\n                n.destructurings.push({ exp: dexp, decl: n2 });\n\n                if (x.inForLoopInit && t.peek() === IN) {\n                    continue;\n                }\n\n                t.mustMatch(ASSIGN);\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n\n                continue;\n            }\n\n            if (tt !== IDENTIFIER)\n                throw t.newSyntaxError(\"missing variable name\");\n\n            n2 = new Node(t, { type: IDENTIFIER,\n                               name: t.token.value,\n                               readOnly: n.type === CONST });\n            n.push(n2);\n            s.varDecls.push(n2);\n\n            if (t.match(ASSIGN)) {\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n            }\n        } while (t.match(COMMA));\n\n        return n;\n    }\n\n    /*\n     * LetBlock :: (tokenizer, compiler context, boolean) -> node\n     *\n     * Does not handle let inside of for loop init.\n     */\n    function LetBlock(t, x, isStatement) {\n        var n, n2;\n\n        // t.token.type must be LET\n        n = new Node(t, { type: LET_BLOCK, varDecls: [] });\n        t.mustMatch(LEFT_PAREN);\n        n.variables = Variables(t, x, n);\n        t.mustMatch(RIGHT_PAREN);\n\n        if (isStatement && t.peek() !== LEFT_CURLY) {\n            /*\n             * If this is really an expression in let statement guise, then we\n             * need to wrap the LET_BLOCK node in a SEMICOLON node so that we pop\n             * the return value of the expression.\n             */\n            n2 = new Node(t, { type: SEMICOLON,\n                               expression: n });\n            isStatement = false;\n        }\n\n        if (isStatement)\n            n.block = Block(t, x);\n        else\n            n.expression = AssignExpression(t, x);\n\n        return n;\n    }\n\n    function checkDestructuring(t, x, n, simpleNamesOnly) {\n        if (n.type === ARRAY_COMP)\n            throw t.newSyntaxError(\"Invalid array comprehension left-hand side\");\n        if (n.type !== ARRAY_INIT && n.type !== OBJECT_INIT)\n            return;\n\n        var lhss = {};\n        var nn, n2, idx, sub, cc, c = n.children;\n        for (var i = 0, j = c.length; i < j; i++) {\n            if (!(nn = c[i]))\n                continue;\n            if (nn.type === PROPERTY_INIT) {\n                cc = nn.children;\n                sub = cc[1];\n                idx = cc[0].value;\n            } else if (n.type === OBJECT_INIT) {\n                // Do we have destructuring shorthand {foo, bar}?\n                sub = nn;\n                idx = nn.value;\n            } else {\n                sub = nn;\n                idx = i;\n            }\n\n            if (sub.type === ARRAY_INIT || sub.type === OBJECT_INIT) {\n                lhss[idx] = checkDestructuring(t, x, sub, simpleNamesOnly);\n            } else {\n                if (simpleNamesOnly && sub.type !== IDENTIFIER) {\n                    // In declarations, lhs must be simple names\n                    throw t.newSyntaxError(\"missing name in pattern\");\n                }\n\n                lhss[idx] = sub;\n            }\n        }\n\n        return lhss;\n    }\n\n    function DestructuringExpression(t, x, simpleNamesOnly) {\n        var n = PrimaryExpression(t, x);\n        // Keep the list of lefthand sides for varDecls\n        n.destructuredNames = checkDestructuring(t, x, n, simpleNamesOnly);\n        return n;\n    }\n\n    function GeneratorExpression(t, x, e) {\n        return new Node(t, { type: GENERATOR,\n                             expression: e,\n                             tail: ComprehensionTail(t, x) });\n    }\n\n    function ComprehensionTail(t, x) {\n        var body, n, n2, n3, p;\n\n        // t.token.type must be FOR\n        body = new Node(t, { type: COMP_TAIL });\n\n        do {\n            // Comprehension tails are always for..in loops.\n            n = new Node(t, { type: FOR_IN, isLoop: true });\n            if (t.match(IDENTIFIER)) {\n                // But sometimes they're for each..in.\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            p = MaybeLeftParen(t, x);\n            switch(t.get()) {\n              case LEFT_BRACKET:\n              case LEFT_CURLY:\n                t.unget();\n                // Destructured left side of for in comprehension tails.\n                n.iterator = DestructuringExpression(t, x);\n                break;\n\n              case IDENTIFIER:\n                n.iterator = n3 = new Node(t, { type: IDENTIFIER });\n                n3.name = n3.value;\n                n.varDecl = n2 = new Node(t, { type: VAR });\n                n2.push(n3);\n                x.parentScript.varDecls.push(n3);\n                // Don't add to varDecls since the semantics of comprehensions is\n                // such that the variables are in their own function when\n                // desugared.\n                break;\n\n              default:\n                throw t.newSyntaxError(\"missing identifier\");\n            }\n            t.mustMatch(IN);\n            n.object = Expression(t, x);\n            MaybeRightParen(t, p);\n            body.push(n);\n        } while (t.match(FOR));\n\n        // Optional guard.\n        if (t.match(IF))\n            body.guard = HeadExpression(t, x);\n\n        return body;\n    }\n\n    function HeadExpression(t, x) {\n        var p = MaybeLeftParen(t, x);\n        var n = ParenExpression(t, x);\n        MaybeRightParen(t, p);\n        if (p === END && !n.parenthesized) {\n            var tt = t.peek();\n            if (tt !== LEFT_CURLY && !definitions.isStatementStartCode[tt])\n                throw t.newSyntaxError(\"Unparenthesized head followed by unbraced body\");\n        }\n        return n;\n    }\n\n    function ParenExpression(t, x) {\n        // Always accept the 'in' operator in a parenthesized expression,\n        // where it's unambiguous, even if we might be parsing the init of a\n        // for statement.\n        var n = Expression(t, x.update({ inForLoopInit: x.inForLoopInit &&\n                                                        (t.token.type === LEFT_PAREN) }));\n\n        if (t.match(FOR)) {\n            if (n.type === YIELD && !n.parenthesized)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (n.type === COMMA && !n.parenthesized)\n                throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            n = GeneratorExpression(t, x, n);\n        }\n\n        return n;\n    }\n\n    /*\n     * Expression :: (tokenizer, compiler context) -> node\n     *\n     * Top-down expression parser matched against SpiderMonkey.\n     */\n    function Expression(t, x) {\n        var n, n2;\n\n        n = AssignExpression(t, x);\n        if (t.match(COMMA)) {\n            n2 = new Node(t, { type: COMMA });\n            n2.push(n);\n            n = n2;\n            do {\n                n2 = n.children[n.children.length-1];\n                if (n2.type === YIELD && !n2.parenthesized)\n                    throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n                n.push(AssignExpression(t, x));\n            } while (t.match(COMMA));\n        }\n\n        return n;\n    }\n\n    function AssignExpression(t, x) {\n        var n, lhs;\n\n        // Have to treat yield like an operand because it could be the leftmost\n        // operand of the expression.\n        if (t.match(YIELD, true))\n            return ReturnOrYield(t, x);\n\n        n = new Node(t, { type: ASSIGN });\n        lhs = ConditionalExpression(t, x);\n\n        if (!t.match(ASSIGN)) {\n            return lhs;\n        }\n\n        switch (lhs.type) {\n          case OBJECT_INIT:\n          case ARRAY_INIT:\n            lhs.destructuredNames = checkDestructuring(t, x, lhs);\n            // FALL THROUGH\n          case IDENTIFIER: case DOT: case INDEX: case CALL:\n            break;\n          default:\n            throw t.newSyntaxError(\"Bad left-hand side of assignment\");\n            break;\n        }\n\n        n.assignOp = t.token.assignOp;\n        n.push(lhs);\n        n.push(AssignExpression(t, x));\n\n        return n;\n    }\n\n    function ConditionalExpression(t, x) {\n        var n, n2;\n\n        n = OrExpression(t, x);\n        if (t.match(HOOK)) {\n            n2 = n;\n            n = new Node(t, { type: HOOK });\n            n.push(n2);\n            /*\n             * Always accept the 'in' operator in the middle clause of a ternary,\n             * where it's unambiguous, even if we might be parsing the init of a\n             * for statement.\n             */\n            n.push(AssignExpression(t, x.update({ inForLoopInit: false })));\n            if (!t.match(COLON))\n                throw t.newSyntaxError(\"missing : after ?\");\n            n.push(AssignExpression(t, x));\n        }\n\n        return n;\n    }\n\n    function OrExpression(t, x) {\n        var n, n2;\n\n        n = AndExpression(t, x);\n        while (t.match(OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AndExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseOrExpression(t, x);\n        while (t.match(AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseOrExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseOrExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseXorExpression(t, x);\n        while (t.match(BITWISE_OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseXorExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseXorExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseAndExpression(t, x);\n        while (t.match(BITWISE_XOR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseAndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseAndExpression(t, x) {\n        var n, n2;\n\n        n = EqualityExpression(t, x);\n        while (t.match(BITWISE_AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(EqualityExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function EqualityExpression(t, x) {\n        var n, n2;\n\n        n = RelationalExpression(t, x);\n        while (t.match(EQ) || t.match(NE) ||\n               t.match(STRICT_EQ) || t.match(STRICT_NE)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(RelationalExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function RelationalExpression(t, x) {\n        var n, n2;\n\n        /*\n         * Uses of the in operator in shiftExprs are always unambiguous,\n         * so unset the flag that prohibits recognizing it.\n         */\n        var x2 = x.update({ inForLoopInit: false });\n        n = ShiftExpression(t, x2);\n        while ((t.match(LT) || t.match(LE) || t.match(GE) || t.match(GT) ||\n               (!x.inForLoopInit && t.match(IN)) ||\n               t.match(INSTANCEOF))) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(ShiftExpression(t, x2));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ShiftExpression(t, x) {\n        var n, n2;\n\n        n = AddExpression(t, x);\n        while (t.match(LSH) || t.match(RSH) || t.match(URSH)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AddExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AddExpression(t, x) {\n        var n, n2;\n\n        n = MultiplyExpression(t, x);\n        while (t.match(PLUS) || t.match(MINUS)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(MultiplyExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function MultiplyExpression(t, x) {\n        var n, n2;\n\n        n = UnaryExpression(t, x);\n        while (t.match(MUL) || t.match(DIV) || t.match(MOD)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(UnaryExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function UnaryExpression(t, x) {\n        var n, n2, tt;\n\n        switch (tt = t.get(true)) {\n          case DELETE: case VOID: case TYPEOF:\n          case NOT: case BITWISE_NOT: case PLUS: case MINUS:\n            if (tt === PLUS)\n                n = new Node(t, { type: UNARY_PLUS });\n            else if (tt === MINUS)\n                n = new Node(t, { type: UNARY_MINUS });\n            else\n                n = new Node(t);\n            n.push(UnaryExpression(t, x));\n            break;\n\n          case INCREMENT:\n          case DECREMENT:\n            // Prefix increment/decrement.\n            n = new Node(t);\n            n.push(MemberExpression(t, x, true));\n            break;\n\n          default:\n            t.unget();\n            n = MemberExpression(t, x, true);\n\n            // Don't look across a newline boundary for a postfix {in,de}crement.\n            if (t.tokens[(t.tokenIndex + t.lookahead - 1) & 3].lineno ===\n                t.lineno) {\n                if (t.match(INCREMENT) || t.match(DECREMENT)) {\n                    n2 = new Node(t, { postfix: true });\n                    n2.push(n);\n                    n = n2;\n                }\n            }\n            break;\n        }\n\n        return n;\n    }\n\n    function MemberExpression(t, x, allowCallSyntax) {\n        var n, n2, name, tt;\n\n        if (t.match(NEW)) {\n            n = new Node(t);\n            n.push(MemberExpression(t, x, false));\n            if (t.match(LEFT_PAREN)) {\n                n.type = NEW_WITH_ARGS;\n                n.push(ArgumentList(t, x));\n            }\n        } else {\n            n = PrimaryExpression(t, x);\n        }\n\n        while ((tt = t.get()) !== END) {\n            switch (tt) {\n              case DOT:\n                n2 = new Node(t);\n                n2.push(n);\n                t.mustMatch(IDENTIFIER);\n                n2.push(new Node(t));\n                break;\n\n              case LEFT_BRACKET:\n                n2 = new Node(t, { type: INDEX });\n                n2.push(n);\n                n2.push(Expression(t, x));\n                t.mustMatch(RIGHT_BRACKET);\n                break;\n\n              case LEFT_PAREN:\n                if (allowCallSyntax) {\n                    n2 = new Node(t, { type: CALL });\n                    n2.push(n);\n                    n2.push(ArgumentList(t, x));\n                    break;\n                }\n\n                // FALL THROUGH\n              default:\n                t.unget();\n                return n;\n            }\n\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ArgumentList(t, x) {\n        var n, n2;\n\n        n = new Node(t, { type: LIST });\n        if (t.match(RIGHT_PAREN, true))\n            return n;\n        do {\n            n2 = AssignExpression(t, x);\n            if (n2.type === YIELD && !n2.parenthesized && t.peek() === COMMA)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (t.match(FOR)) {\n                n2 = GeneratorExpression(t, x, n2);\n                if (n.children.length > 1 || t.peek(true) === COMMA)\n                    throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            }\n            n.push(n2);\n        } while (t.match(COMMA));\n        t.mustMatch(RIGHT_PAREN);\n\n        return n;\n    }\n\n    function PrimaryExpression(t, x) {\n        var n, n2, tt = t.get(true);\n\n        switch (tt) {\n          case FUNCTION:\n            n = FunctionDefinition(t, x, false, EXPRESSED_FORM);\n            break;\n\n          case LEFT_BRACKET:\n            n = new Node(t, { type: ARRAY_INIT });\n            while ((tt = t.peek(true)) !== RIGHT_BRACKET) {\n                if (tt === COMMA) {\n                    t.get();\n                    n.push(null);\n                    continue;\n                }\n                n.push(AssignExpression(t, x));\n                if (tt !== COMMA && !t.match(COMMA))\n                    break;\n            }\n\n            // If we matched exactly one element and got a FOR, we have an\n            // array comprehension.\n            if (n.children.length === 1 && t.match(FOR)) {\n                n2 = new Node(t, { type: ARRAY_COMP,\n                                   expression: n.children[0],\n                                   tail: ComprehensionTail(t, x) });\n                n = n2;\n            }\n            t.mustMatch(RIGHT_BRACKET);\n            break;\n\n          case LEFT_CURLY:\n            var id, fd;\n            n = new Node(t, { type: OBJECT_INIT });\n\n          object_init:\n            if (!t.match(RIGHT_CURLY)) {\n                do {\n                    tt = t.get();\n                    if ((t.token.value === \"get\" || t.token.value === \"set\") &&\n                        t.peek() === IDENTIFIER) {\n                        if (x.ecma3OnlyMode)\n                            throw t.newSyntaxError(\"Illegal property accessor\");\n                        n.push(FunctionDefinition(t, x, true, EXPRESSED_FORM));\n                    } else {\n                        switch (tt) {\n                          case IDENTIFIER: case NUMBER: case STRING:\n                            id = new Node(t, { type: IDENTIFIER });\n                            break;\n                          case RIGHT_CURLY:\n                            if (x.ecma3OnlyMode)\n                                throw t.newSyntaxError(\"Illegal trailing ,\");\n                            break object_init;\n                          default:\n                            if (t.token.value in definitions.keywords) {\n                                id = new Node(t, { type: IDENTIFIER });\n                                break;\n                            }\n                            throw t.newSyntaxError(\"Invalid property name\");\n                        }\n                        if (t.match(COLON)) {\n                            n2 = new Node(t, { type: PROPERTY_INIT });\n                            n2.push(id);\n                            n2.push(AssignExpression(t, x));\n                            n.push(n2);\n                        } else {\n                            // Support, e.g., |var {x, y} = o| as destructuring shorthand\n                            // for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.\n                            if (t.peek() !== COMMA && t.peek() !== RIGHT_CURLY)\n                                throw t.newSyntaxError(\"missing : after property\");\n                            n.push(id);\n                        }\n                    }\n                } while (t.match(COMMA));\n                t.mustMatch(RIGHT_CURLY);\n            }\n            break;\n\n          case LEFT_PAREN:\n            n = ParenExpression(t, x);\n            t.mustMatch(RIGHT_PAREN);\n            n.parenthesized = true;\n            break;\n\n          case LET:\n            n = LetBlock(t, x, false);\n            break;\n\n          case NULL: case THIS: case TRUE: case FALSE:\n          case IDENTIFIER: case NUMBER: case STRING: case REGEXP:\n            n = new Node(t);\n            break;\n\n          default:\n            throw t.newSyntaxError(\"missing operand\");\n            break;\n        }\n\n        return n;\n    }\n\n    /*\n     * parse :: (source, filename, line number) -> node\n     */\n    function parse(s, f, l) {\n        var t = new lexer.Tokenizer(s, f, l);\n        var n = Script(t, false);\n        if (!t.done)\n            throw t.newSyntaxError(\"Syntax error\");\n\n        return n;\n    }\n\n    /*\n     * parseStdin :: (source, {line number}) -> node\n     */\n    function parseStdin(s, ln) {\n        for (;;) {\n            try {\n                var t = new lexer.Tokenizer(s, \"stdin\", ln.value);\n                var n = Script(t, false);\n                ln.value = t.lineno;\n                return n;\n            } catch (e) {\n                if (!t.unexpectedEOF)\n                    throw e;\n                var more = readline();\n                if (!more)\n                    throw e;\n                s += \"\\n\" + more;\n            }\n        }\n    }\n\n    return {\n        parse: parse,\n        parseStdin: parseStdin,\n        Node: Node,\n        DECLARED_FORM: DECLARED_FORM,\n        EXPRESSED_FORM: EXPRESSED_FORM,\n        STATEMENT_FORM: STATEMENT_FORM,\n        Tokenizer: lexer.Tokenizer,\n        FunctionDefinition: FunctionDefinition\n    };\n\n}());\n\nvar exports = {\n  definitions: Narcissus.definitions,\n  lexer: Narcissus.lexer,\n  parser: Narcissus.parser\n};\n\nif (typeof module != 'undefined') {\n  module.exports = exports;\n};\n\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "narcissus_packed.js",
      "date": "2014-01-20T02:05:18.271Z",
      "slug": "lib-narcissus-packed",
      "url": "/lib/narcissus_packed.js",
      "urls": [
        "/lib/narcissus_packed.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "/* vim: set sw=4 ts=4 et tw=78: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (typeof module == 'undefined') {\n  this.Narcissus = new Object;\n}\n\nvar Narcissus = {\n    options: {\n        version: 185,\n    },\n    hostGlobal: this\n};\n\nNarcissus.definitions = (function() {\n\n    var tokens = [\n        // End of source.\n        \"END\",\n\n        // Operators and punctuators.  Some pair-wise order matters, e.g. (+, -)\n        // and (UNARY_PLUS, UNARY_MINUS).\n        \"\\n\", \";\",\n        \",\",\n        \"=\",\n        \"?\", \":\", \"CONDITIONAL\",\n        \"||\",\n        \"&&\",\n        \"|\",\n        \"^\",\n        \"&\",\n        \"==\", \"!=\", \"===\", \"!==\",\n        \"<\", \"<=\", \">=\", \">\",\n        \"<<\", \">>\", \">>>\",\n        \"+\", \"-\",\n        \"*\", \"/\", \"%\",\n        \"!\", \"~\", \"UNARY_PLUS\", \"UNARY_MINUS\",\n        \"++\", \"--\",\n        \".\",\n        \"[\", \"]\",\n        \"{\", \"}\",\n        \"(\", \")\",\n\n        // Nonterminal tree node type codes.\n        \"SCRIPT\", \"BLOCK\", \"LABEL\", \"FOR_IN\", \"CALL\", \"NEW_WITH_ARGS\", \"INDEX\",\n        \"ARRAY_INIT\", \"OBJECT_INIT\", \"PROPERTY_INIT\", \"GETTER\", \"SETTER\",\n        \"GROUP\", \"LIST\", \"LET_BLOCK\", \"ARRAY_COMP\", \"GENERATOR\", \"COMP_TAIL\",\n\n        // Terminals.\n        \"IDENTIFIER\", \"NUMBER\", \"STRING\", \"REGEXP\",\n\n        // Keywords.\n        \"break\",\n        \"case\", \"catch\", \"const\", \"continue\",\n        \"debugger\", \"default\", \"delete\", \"do\",\n        \"else\",\n        \"false\", \"finally\", \"for\", \"function\",\n        \"if\", \"in\", \"instanceof\",\n        \"let\",\n        \"new\", \"null\",\n        \"return\",\n        \"switch\",\n        \"this\", \"throw\", \"true\", \"try\", \"typeof\",\n        \"var\", \"void\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    var statementStartTokens = [\n        \"break\",\n        \"const\", \"continue\",\n        \"debugger\", \"do\",\n        \"for\",\n        \"if\",\n        \"return\",\n        \"switch\",\n        \"throw\", \"try\",\n        \"var\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    // Operator and punctuator mapping from token to tree node type name.\n    // NB: because the lexer doesn't backtrack, all token prefixes must themselves\n    // be valid tokens (e.g. !== is acceptable because its prefixes are the valid\n    // tokens != and !).\n    var opTypeNames = {\n        '\\n':   \"NEWLINE\",\n        ';':    \"SEMICOLON\",\n        ',':    \"COMMA\",\n        '?':    \"HOOK\",\n        ':':    \"COLON\",\n        '||':   \"OR\",\n        '&&':   \"AND\",\n        '|':    \"BITWISE_OR\",\n        '^':    \"BITWISE_XOR\",\n        '&':    \"BITWISE_AND\",\n        '===':  \"STRICT_EQ\",\n        '==':   \"EQ\",\n        '=':    \"ASSIGN\",\n        '!==':  \"STRICT_NE\",\n        '!=':   \"NE\",\n        '<<':   \"LSH\",\n        '<=':   \"LE\",\n        '<':    \"LT\",\n        '>>>':  \"URSH\",\n        '>>':   \"RSH\",\n        '>=':   \"GE\",\n        '>':    \"GT\",\n        '++':   \"INCREMENT\",\n        '--':   \"DECREMENT\",\n        '+':    \"PLUS\",\n        '-':    \"MINUS\",\n        '*':    \"MUL\",\n        '/':    \"DIV\",\n        '%':    \"MOD\",\n        '!':    \"NOT\",\n        '~':    \"BITWISE_NOT\",\n        '.':    \"DOT\",\n        '[':    \"LEFT_BRACKET\",\n        ']':    \"RIGHT_BRACKET\",\n        '{':    \"LEFT_CURLY\",\n        '}':    \"RIGHT_CURLY\",\n        '(':    \"LEFT_PAREN\",\n        ')':    \"RIGHT_PAREN\"\n    };\n\n    // Hash of keyword identifier to tokens index.  NB: we must null __proto__ to\n    // avoid toString, etc. namespace pollution.\n    var keywords = {__proto__: null};\n\n    // Define const END, etc., based on the token names.  Also map name to index.\n    var tokenIds = {};\n\n    // Building up a string to be eval'd in different contexts.\n    var consts = \"const \";\n    for (var i = 0, j = tokens.length; i < j; i++) {\n        if (i > 0)\n            consts += \", \";\n        var t = tokens[i];\n        var name;\n        if (/^[a-z]/.test(t)) {\n            name = t.toUpperCase();\n            keywords[t] = i;\n        } else {\n            name = (/^\\W/.test(t) ? opTypeNames[t] : t);\n        }\n        consts += name + \" = \" + i;\n        tokenIds[name] = i;\n        tokens[t] = i;\n    }\n    consts += \";\";\n\n    var isStatementStartCode = {__proto__: null};\n    for (i = 0, j = statementStartTokens.length; i < j; i++)\n        isStatementStartCode[keywords[statementStartTokens[i]]] = true;\n\n    // Map assignment operators to their indexes in the tokens array.\n    var assignOps = ['|', '^', '&', '<<', '>>', '>>>', '+', '-', '*', '/', '%'];\n\n    for (i = 0, j = assignOps.length; i < j; i++) {\n        t = assignOps[i];\n        assignOps[t] = tokens[t];\n    }\n\n    function defineGetter(obj, prop, fn, dontDelete, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { get: fn, configurable: !dontDelete, enumerable: !dontEnum });\n    }\n\n    function defineProperty(obj, prop, val, dontDelete, readOnly, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { value: val, writable: !readOnly, configurable: !dontDelete,\n                                enumerable: !dontEnum });\n    }\n\n    // Returns true if fn is a native function.  (Note: SpiderMonkey specific.)\n    function isNativeCode(fn) {\n        // Relies on the toString method to identify native code.\n        return ((typeof fn) === \"function\") && fn.toString().match(/\\[native code\\]/);\n    }\n\n    function getPropertyDescriptor(obj, name) {\n        while (obj) {\n            if (({}).hasOwnProperty.call(obj, name))\n                return Object.getOwnPropertyDescriptor(obj, name);\n            obj = Object.getPrototypeOf(obj);\n        }\n    }\n\n    function getOwnProperties(obj) {\n        var map = {};\n        for (var name in Object.getOwnPropertyNames(obj))\n            map[name] = Object.getOwnPropertyDescriptor(obj, name);\n        return map;\n    }\n\n    function makePassthruHandler(obj) {\n        // Handler copied from\n        // http://wiki.ecmascript.org/doku.php?id=harmony:proxies&s=proxy%20object#examplea_no-op_forwarding_proxy\n        return {\n            getOwnPropertyDescriptor: function(name) {\n                var desc = Object.getOwnPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getPropertyDescriptor: function(name) {\n                var desc = getPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getOwnPropertyNames: function() {\n                return Object.getOwnPropertyNames(obj);\n            },\n            defineProperty: function(name, desc) {\n                Object.defineProperty(obj, name, desc);\n            },\n            \"delete\": function(name) { return delete obj[name]; },\n            fix: function() {\n                if (Object.isFrozen(obj)) {\n                    return getOwnProperties(obj);\n                }\n\n                // As long as obj is not frozen, the proxy won't allow itself to be fixed.\n                return undefined; // will cause a TypeError to be thrown\n            },\n\n            has: function(name) { return name in obj; },\n            hasOwn: function(name) { return ({}).hasOwnProperty.call(obj, name); },\n            get: function(receiver, name) { return obj[name]; },\n\n            // bad behavior when set fails in non-strict mode\n            set: function(receiver, name, val) { obj[name] = val; return true; },\n            enumerate: function() {\n                var result = [];\n                for (name in obj) { result.push(name); };\n                return result;\n            },\n            keys: function() { return Object.keys(obj); }\n        };\n    }\n\n    // default function used when looking for a property in the global object\n    function noPropFound() { return undefined; }\n\n    var hasOwnProperty = ({}).hasOwnProperty;\n\n    function StringMap() {\n        this.table = Object.create(null, {});\n        this.size = 0;\n    }\n\n    StringMap.prototype = {\n        has: function(x) { return hasOwnProperty.call(this.table, x); },\n        set: function(x, v) {\n            if (!hasOwnProperty.call(this.table, x))\n                this.size++;\n            this.table[x] = v;\n        },\n        get: function(x) { return this.table[x]; },\n        getDef: function(x, thunk) {\n            if (!hasOwnProperty.call(this.table, x)) {\n                this.size++;\n                this.table[x] = thunk();\n            }\n            return this.table[x];\n        },\n        forEach: function(f) {\n            var table = this.table;\n            for (var key in table)\n                f.call(this, key, table[key]);\n        },\n        toString: function() { return \"[object StringMap]\" }\n    };\n\n    // non-destructive stack\n    function Stack(elts) {\n        this.elts = elts || null;\n    }\n\n    Stack.prototype = {\n        push: function(x) {\n            return new Stack({ top: x, rest: this.elts });\n        },\n        top: function() {\n            if (!this.elts)\n                throw new Error(\"empty stack\");\n            return this.elts.top;\n        },\n        isEmpty: function() {\n            return this.top === null;\n        },\n        find: function(test) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                if (test(elts.top))\n                    return elts.top;\n            }\n            return null;\n        },\n        has: function(x) {\n            return Boolean(this.find(function(elt) { return elt === x }));\n        },\n        forEach: function(f) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                f(elts.top);\n            }\n        }\n    };\n\n    return {\n        tokens: tokens,\n        opTypeNames: opTypeNames,\n        keywords: keywords,\n        isStatementStartCode: isStatementStartCode,\n        tokenIds: tokenIds,\n        consts: consts,\n        assignOps: assignOps,\n        defineGetter: defineGetter,\n        defineProperty: defineProperty,\n        isNativeCode: isNativeCode,\n        makePassthruHandler: makePassthruHandler,\n        noPropFound: noPropFound,\n        StringMap: StringMap,\n        Stack: Stack\n    };\n}());\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Lexical scanner.\n */\n\nNarcissus.lexer = (function() {\n\n    var definitions = Narcissus.definitions;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    // Build up a trie of operator tokens.\n    var opTokens = {};\n    for (var op in definitions.opTypeNames) {\n        if (op === '\\n' || op === '.')\n            continue;\n\n        var node = opTokens;\n        for (var i = 0; i < op.length; i++) {\n            var ch = op[i];\n            if (!(ch in node))\n                node[ch] = {};\n            node = node[ch];\n            node.op = op;\n        }\n    }\n\n    /*\n     * Tokenizer :: (source, filename, line number) -> Tokenizer\n     */\n    function Tokenizer(s, f, l) {\n        this.cursor = 0;\n        this.source = String(s);\n        this.tokens = [];\n        this.tokenIndex = 0;\n        this.lookahead = 0;\n        this.scanNewlines = false;\n        this.unexpectedEOF = false;\n        this.filename = f || \"\";\n        this.lineno = l || 1;\n        this.comments = [];\n    }\n\n    Tokenizer.prototype = {\n        get done() {\n            // We need to set scanOperand to true here because the first thing\n            // might be a regexp.\n            return this.peek(true) === END;\n        },\n\n        get token() {\n            return this.tokens[this.tokenIndex];\n        },\n\n        match: function (tt, scanOperand) {\n            return this.get(scanOperand) === tt || this.unget();\n        },\n\n        mustMatch: function (tt) {\n            if (!this.match(tt)) {\n                throw this.newSyntaxError(\"Missing \" +\n                                          definitions.tokens[tt].toLowerCase());\n            }\n            return this.token;\n        },\n\n        peek: function (scanOperand) {\n            var tt, next;\n            if (this.lookahead) {\n                next = this.tokens[(this.tokenIndex + this.lookahead) & 3];\n                tt = (this.scanNewlines && next.lineno !== this.lineno)\n                     ? NEWLINE\n                     : next.type;\n            } else {\n                tt = this.get(scanOperand);\n                this.unget();\n            }\n            return tt;\n        },\n\n        peekOnSameLine: function (scanOperand) {\n            this.scanNewlines = true;\n            var tt = this.peek(scanOperand);\n            this.scanNewlines = false;\n            return tt;\n        },\n\n        // Eat comments and whitespace.\n        // toka: returns list of skipped comments\n        skip: function () {\n            var input = this.source;\n            var cstart;\n            var clineno;\n            var comments = [];\n            var comment;\n            var nlcount = 0;\n\n            for (;;) {\n                var ch = input[this.cursor++];\n                var next = input[this.cursor];\n                if (ch === '\\n' && !this.scanNewlines) {\n                    this.lineno++;\n                    nlcount++;\n                } else if (ch === '/' && next === '*') {\n                    cstart = this.cursor;\n                    clineno = this.lineno;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated comment\");\n\n                        if (ch === '*') {\n                            next = input[this.cursor];\n                            if (next === '/') {\n                                this.cursor++;\n                                comment = {\n                                    type: \"BLOCK_COMMENT\",\n                                    nlcount: nlcount,\n                                    start:cstart-1, end:this.cursor, lineno:clineno, endlineno: this.lineno,\n                                    value: input.substring(cstart+1,this.cursor-2)\n                                }\n                                // comments.push(comment);\n                                this.comments.push(comment);\n                                nlcount = 0;\n                                break;\n                            }\n                        } else if (ch === '\\n') {\n                            this.lineno++;\n                        }\n                    }\n                } else if (ch === '/' && next === '/') {\n                    cstart = this.cursor;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined) {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            // comments.push(comment);\n                            this.comments.push(comment);\n                            return;\n                            // return comments;\n                        }\n                        if (ch === '\\n') {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            //comments.push(  );\n                            this.comments.push(comment);\n                            nlcount = 0;\n                            this.lineno++;\n                            break;\n                        }\n                    }\n                } else if (ch !== ' ' && ch !== '\\t') {\n                    this.cursor--;\n                    // return comments;\n                    return;\n                }\n            }\n        },\n\n        // Lex the exponential part of a number, if present. Return true iff an\n        // exponential part was found.\n        lexExponent: function() {\n            var input = this.source;\n            var next = input[this.cursor];\n            if (next === 'e' || next === 'E') {\n                this.cursor++;\n                ch = input[this.cursor++];\n                if (ch === '+' || ch === '-')\n                    ch = input[this.cursor++];\n\n                if (ch < '0' || ch > '9')\n                    throw this.newSyntaxError(\"Missing exponent\");\n\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                return true;\n            }\n\n            return false;\n        },\n\n        lexZeroNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            ch = input[this.cursor++];\n            if (ch === '.') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n                token.value = parseFloat(token.start, this.cursor);\n            } else if (ch === 'x' || ch === 'X') {\n                do {\n                    ch = input[this.cursor++];\n                } while ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||\n                         (ch >= 'A' && ch <= 'F'));\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else if (ch >= '0' && ch <= '7') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '7');\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else {\n                this.cursor--;\n                this.lexExponent();     // 0E1, &c.\n                token.value = 0;\n            }\n        },\n\n        lexNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            var floating = false;\n            do {\n                ch = input[this.cursor++];\n                if (ch === '.' && !floating) {\n                    floating = true;\n                    ch = input[this.cursor++];\n                }\n            } while (ch >= '0' && ch <= '9');\n\n            this.cursor--;\n\n            var exponent = this.lexExponent();\n            floating = floating || exponent;\n\n            var str = input.substring(token.start, this.cursor);\n            token.value = floating ? parseFloat(str) : parseInt(str);\n        },\n\n        lexDot: function (ch) {\n            var token = this.token, input = this.source;\n            var next = input[this.cursor];\n            if (next >= '0' && next <= '9') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n\n                token.type = NUMBER;\n                token.value = parseFloat(token.start, this.cursor);\n            } else {\n                token.type = DOT;\n                token.assignOp = null;\n                token.value = '.';\n            }\n        },\n\n        lexString: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = STRING;\n\n            var hasEscapes = false;\n            var delim = ch;\n            while ((ch = input[this.cursor++]) !== delim) {\n                // [JS2COFFEE] Fixed to make it work on a browser\n                if (this.cursor >= input.length)\n                    throw this.newSyntaxError(\"Unterminated string literal\");\n                if (ch === '\\\\') {\n                    hasEscapes = true;\n                    if (++this.cursor == input.length)\n                        throw this.newSyntaxError(\"Unterminated string literal\");\n                }\n            }\n\n            token.value = hasEscapes\n                          ? eval(input.substring(token.start, this.cursor))\n                          : input.substring(token.start + 1, this.cursor - 1);\n        },\n\n        lexRegExp: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = REGEXP;\n\n            do {\n                ch = input[this.cursor++];\n                if (ch === '\\\\') {\n                    this.cursor++;\n                } else if (ch === '[') {\n                    do {\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated character class\");\n\n                        if (ch === '\\\\')\n                            this.cursor++;\n\n                        ch = input[this.cursor++];\n                    } while (ch !== ']');\n                } else if (ch === undefined) {\n                    throw this.newSyntaxError(\"Unterminated regex\");\n                }\n            } while (ch !== '/');\n\n            do {\n                ch = input[this.cursor++];\n            } while (ch >= 'a' && ch <= 'z');\n\n            this.cursor--;\n\n            token.value = eval(input.substring(token.start, this.cursor));\n        },\n\n        lexOp: function (ch) {\n            var token = this.token, input = this.source;\n\n            // A bit ugly, but it seems wasteful to write a trie lookup routine\n            // for only 3 characters...\n            var node = opTokens[ch];\n            var next = input[this.cursor];\n            if (next in node) {\n                node = node[next];\n                this.cursor++;\n                next = input[this.cursor];\n                if (next in node) {\n                    node = node[next];\n                    this.cursor++;\n                    next = input[this.cursor];\n                }\n            }\n\n            var op = node.op;\n            if (definitions.assignOps[op] && input[this.cursor] === '=') {\n                this.cursor++;\n                token.type = ASSIGN;\n                token.assignOp = definitions.tokenIds[definitions.opTypeNames[op]];\n                op += '=';\n            } else {\n                token.type = definitions.tokenIds[definitions.opTypeNames[op]];\n                token.assignOp = null;\n            }\n\n            token.value = op;\n        },\n\n        // FIXME: Unicode escape sequences\n        // FIXME: Unicode identifiers\n        lexIdent: function (ch) {\n            var token = this.token, input = this.source;\n\n            do {\n                ch = input[this.cursor++];\n            } while ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n                     (ch >= '0' && ch <= '9') || ch === '$' || ch === '_');\n\n            this.cursor--;  // Put the non-word character back.\n\n            var id = input.substring(token.start, this.cursor);\n            token.type = definitions.keywords[id] || IDENTIFIER;\n            token.value = id;\n        },\n\n        /*\n         * Tokenizer.get :: void -> token type\n         *\n         * Consume input *only* if there is no lookahead.\n         * Dispatch to the appropriate lexing function depending on the input.\n         */\n        get: function (scanOperand) {\n            var token;\n            while (this.lookahead) {\n                --this.lookahead;\n                this.tokenIndex = (this.tokenIndex + 1) & 3;\n                token = this.tokens[this.tokenIndex];\n                if (token.type !== NEWLINE || this.scanNewlines)\n                    return token.type;\n            }\n\n            // var comments =\n            this.skip();\n\n            this.tokenIndex = (this.tokenIndex + 1) & 3;\n            token = this.tokens[this.tokenIndex];\n            if (!token)\n                this.tokens[this.tokenIndex] = token = {};\n\n            var input = this.source;\n            if (this.cursor === input.length)\n                return token.type = END;\n\n            token.start = this.cursor;\n            token.lineno = this.lineno;\n\n            var ch = input[this.cursor++];\n            if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '$' || ch === '_') {\n                this.lexIdent(ch);\n            } else if (scanOperand && ch === '/') {\n                this.lexRegExp(ch);\n            } else if (ch in opTokens) {\n                this.lexOp(ch);\n            } else if (ch === '.') {\n                this.lexDot(ch);\n            } else if (ch >= '1' && ch <= '9') {\n                this.lexNumber(ch);\n            } else if (ch === '0') {\n                this.lexZeroNumber(ch);\n            } else if (ch === '\"' || ch === \"'\") {\n                this.lexString(ch);\n            } else if (this.scanNewlines && ch === '\\n') {\n                token.type = NEWLINE;\n                token.value = '\\n';\n                this.lineno++;\n            } else {\n                throw this.newSyntaxError(\"Illegal token\");\n            }\n\n            token.end = this.cursor;\n            // token.comments = [comments,this.skip()];\n            return token.type;\n        },\n\n        /*\n         * Tokenizer.unget :: void -> undefined\n         *\n         * Match depends on unget returning undefined.\n         */\n        unget: function () {\n            if (++this.lookahead === 4) throw \"PANIC: too much lookahead!\";\n            this.tokenIndex = (this.tokenIndex - 1) & 3;\n        },\n\n        newSyntaxError: function (m) {\n            var e = new SyntaxError(m, this.filename, this.lineno);\n            e.source = this.source;\n            e.cursor = this.lookahead\n                       ? this.tokens[(this.tokenIndex + this.lookahead) & 3].start\n                       : this.cursor;\n            return e;\n        },\n    };\n\n    return { Tokenizer: Tokenizer };\n\n}());\n\n/* -*- Mode: JS; tab-width: 4; indent-tabs-mode: nil; -*-\n * vim: set sw=4 ts=4 et tw=78:\n * ***** BEGIN LICENSE BLOCK *****\n *\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Parser.\n */\n\nNarcissus.parser = (function() {\n\n    var lexer = Narcissus.lexer;\n    var definitions = Narcissus.definitions;\n\n    const StringMap = definitions.StringMap;\n    const Stack = definitions.Stack;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    /*\n     * pushDestructuringVarDecls :: (node, hoisting node) -> void\n     *\n     * Recursively add all destructured declarations to varDecls.\n     */\n    function pushDestructuringVarDecls(n, s) {\n        for (var i in n) {\n            var sub = n[i];\n            if (sub.type === IDENTIFIER) {\n                s.varDecls.push(sub);\n            } else {\n                pushDestructuringVarDecls(sub, s);\n            }\n        }\n    }\n\n    // NESTING_TOP: top-level\n    // NESTING_SHALLOW: nested within static forms such as { ... } or labeled statement\n    // NESTING_DEEP: nested within dynamic forms such as if, loops, etc.\n    const NESTING_TOP = 0, NESTING_SHALLOW = 1, NESTING_DEEP = 2;\n\n    function StaticContext(parentScript, parentBlock, inFunction, inForLoopInit, nesting) {\n        this.parentScript = parentScript;\n        this.parentBlock = parentBlock;\n        this.inFunction = inFunction;\n        this.inForLoopInit = inForLoopInit;\n        this.nesting = nesting;\n        this.allLabels = new Stack();\n        this.currentLabels = new Stack();\n        this.labeledTargets = new Stack();\n        this.defaultTarget = null;\n        Narcissus.options.ecma3OnlyMode && (this.ecma3OnlyMode = true);\n        Narcissus.options.parenFreeMode && (this.parenFreeMode = true);\n    }\n\n    StaticContext.prototype = {\n        ecma3OnlyMode: false,\n        parenFreeMode: false,\n        // non-destructive update via prototype extension\n        update: function(ext) {\n            var desc = {};\n            for (var key in ext) {\n                desc[key] = {\n                    value: ext[key],\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                }\n            }\n            return Object.create(this, desc);\n        },\n        pushLabel: function(label) {\n            return this.update({ currentLabels: this.currentLabels.push(label),\n                                 allLabels: this.allLabels.push(label) });\n        },\n        pushTarget: function(target) {\n            var isDefaultTarget = target.isLoop || target.type === SWITCH;\n\n            if (this.currentLabels.isEmpty()) {\n                return isDefaultTarget\n                     ? this.update({ defaultTarget: target })\n                     : this;\n            }\n\n            target.labels = new StringMap();\n            this.currentLabels.forEach(function(label) {\n                target.labels.set(label, true);\n            });\n            return this.update({ currentLabels: new Stack(),\n                                 labeledTargets: this.labeledTargets.push(target),\n                                 defaultTarget: isDefaultTarget\n                                                ? target\n                                                : this.defaultTarget });\n        },\n        nest: function(atLeast) {\n            var nesting = Math.max(this.nesting, atLeast);\n            return (nesting !== this.nesting)\n                 ? this.update({ nesting: nesting })\n                 : this;\n        }\n    };\n\n    /*\n     * Script :: (tokenizer, boolean) -> node\n     *\n     * Parses the toplevel and function bodies.\n     */\n    function Script(t, inFunction) {\n        var n = new Node(t, scriptInit());\n        var x = new StaticContext(n, n, inFunction, false, NESTING_TOP);\n        Statements(t, x, n);\n        return n;\n    }\n\n    // We extend Array slightly with a top-of-stack method.\n    definitions.defineProperty(Array.prototype, \"top\",\n                               function() {\n                                   return this.length && this[this.length-1];\n                               }, false, false, true);\n\n    /*\n     * Node :: (tokenizer, optional init object) -> node\n     */\n    function Node(t, init) {\n        var token = t.token;\n        if (token) {\n            // If init.type exists it will override token.type.\n            this.type = token.type;\n            this.value = token.value;\n            this.lineno = token.lineno;\n\n            // Start and end are file positions for error handling.\n            this.start = token.start;\n            this.end = token.end;\n\n        } else {\n            this.lineno = t.lineno;\n        }\n\n        // Node uses a tokenizer for debugging (getSource, filename getter).\n        this.tokenizer = t;\n        this.children = [];\n\n        for (var prop in init)\n            this[prop] = init[prop];\n    }\n\n    var Np = Node.prototype = {};\n    Np.constructor = Node;\n    Np.toSource = Object.prototype.toSource;\n\n    // Always use push to add operands to an expression, to update start and end.\n    Np.push = function (kid) {\n        // kid can be null e.g. [1, , 2].\n        if (kid !== null) {\n            if (kid.start < this.start)\n                this.start = kid.start;\n            if (this.end < kid.end)\n                this.end = kid.end;\n        }\n        return this.children.push(kid);\n    }\n\n    Node.indentLevel = 0;\n\n    function tokenString(tt) {\n        var t = definitions.tokens[tt];\n        return /^\\W/.test(t) ? definitions.opTypeNames[t] : t.toUpperCase();\n    }\n\n    Np.toString = function () {\n        var a = [];\n        for (var i in this) {\n            if (this.hasOwnProperty(i) && i !== 'type' && i !== 'target')\n                a.push({id: i, value: this[i]});\n        }\n        a.sort(function (a,b) { return (a.id < b.id) ? -1 : 1; });\n        const INDENTATION = \"    \";\n        var n = ++Node.indentLevel;\n        var s = \"{\\n\" + INDENTATION.repeat(n) + \"type: \" + tokenString(this.type);\n        for (i = 0; i < a.length; i++)\n            s += \",\\n\" + INDENTATION.repeat(n) + a[i].id + \": \" + a[i].value;\n        n = --Node.indentLevel;\n        s += \"\\n\" + INDENTATION.repeat(n) + \"}\";\n        return s;\n    }\n\n    Np.getSource = function () {\n        return this.tokenizer.source.slice(this.start, this.end);\n    };\n\n    /*\n     * Helper init objects for common nodes.\n     */\n\n    const LOOP_INIT = { isLoop: true };\n\n    function blockInit() {\n        return { type: BLOCK, varDecls: [] };\n    }\n\n    function scriptInit() {\n        return { type: SCRIPT,\n                 funDecls: [],\n                 varDecls: [],\n                 modDecls: [],\n                 impDecls: [],\n                 expDecls: [],\n                 loadDeps: [],\n                 hasEmptyReturn: false,\n                 hasReturnWithValue: false,\n                 isGenerator: false };\n    }\n\n    definitions.defineGetter(Np, \"filename\",\n                             function() {\n                                 return this.tokenizer.filename;\n                             });\n\n    definitions.defineGetter(Np, \"length\",\n                             function() {\n                                 throw new Error(\"Node.prototype.length is gone; \" +\n                                                 \"use n.children.length instead\");\n                             });\n\n    definitions.defineProperty(String.prototype, \"repeat\",\n                               function(n) {\n                                   var s = \"\", t = this + s;\n                                   while (--n >= 0)\n                                       s += t;\n                                   return s;\n                               }, false, false, true);\n\n    function MaybeLeftParen(t, x) {\n        if (x.parenFreeMode)\n            return t.match(LEFT_PAREN) ? LEFT_PAREN : END;\n        return t.mustMatch(LEFT_PAREN).type;\n    }\n\n    function MaybeRightParen(t, p) {\n        if (p === LEFT_PAREN)\n            t.mustMatch(RIGHT_PAREN);\n    }\n\n    /*\n     * Statements :: (tokenizer, compiler context, node) -> void\n     *\n     * Parses a sequence of Statements.\n     */\n    function Statements(t, x, n) {\n        try {\n            while (!t.done && t.peek(true) !== RIGHT_CURLY)\n            { n.push(Statement(t, x)); }\n        } catch (e) {\n            if (t.done)\n            { t.unexpectedEOF = true; }\n            throw(e);\n        }\n    }\n\n    function Block(t, x) {\n        t.mustMatch(LEFT_CURLY);\n        var n = new Node(t, blockInit());\n        Statements(t, x.update({ parentBlock: n }).pushTarget(n), n);\n        t.mustMatch(RIGHT_CURLY);\n        return n;\n    }\n\n    const DECLARED_FORM = 0, EXPRESSED_FORM = 1, STATEMENT_FORM = 2;\n\n    /*\n     * Statement :: (tokenizer, compiler context) -> node\n     *\n     * Parses a Statement.\n     */\n    function Statement(t, x) {\n        var i, label, n, n2, p, c, ss, tt = t.get(true), tt2, x2, x3;\n\n        // Cases for statements ending in a right curly return early, avoiding the\n        // common semicolon insertion magic after this switch.\n        switch (tt) {\n          case FUNCTION:\n            // DECLARED_FORM extends funDecls of x, STATEMENT_FORM doesn't.\n            return FunctionDefinition(t, x, true,\n                                      (x.nesting !== NESTING_TOP)\n                                      ? STATEMENT_FORM\n                                      : DECLARED_FORM);\n\n          case LEFT_CURLY:\n            n = new Node(t, blockInit());\n            Statements(t, x.update({ parentBlock: n }).pushTarget(n).nest(NESTING_SHALLOW), n);\n            t.mustMatch(RIGHT_CURLY);\n            return n;\n\n          case IF:\n            n = new Node(t);\n            n.condition = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            n.thenPart = Statement(t, x2);\n            n.elsePart = t.match(ELSE) ? Statement(t, x2) : null;\n            return n;\n\n          case SWITCH:\n            // This allows CASEs after a DEFAULT, which is in the standard.\n            n = new Node(t, { cases: [], defaultIndex: -1 });\n            n.discriminant = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            t.mustMatch(LEFT_CURLY);\n            while ((tt = t.get()) !== RIGHT_CURLY) {\n                switch (tt) {\n                  case DEFAULT:\n                    if (n.defaultIndex >= 0)\n                        throw t.newSyntaxError(\"More than one switch default\");\n                    // FALL THROUGH\n                  case CASE:\n                    n2 = new Node(t);\n                    if (tt === DEFAULT)\n                        n.defaultIndex = n.cases.length;\n                    else\n                        n2.caseLabel = Expression(t, x2, COLON);\n                    break;\n\n                  default:\n                    throw t.newSyntaxError(\"Invalid switch case\");\n                }\n                t.mustMatch(COLON);\n                n2.statements = new Node(t, blockInit());\n                while ((tt=t.peek(true)) !== CASE && tt !== DEFAULT &&\n                        tt !== RIGHT_CURLY)\n                    n2.statements.push(Statement(t, x2));\n                n.cases.push(n2);\n            }\n            return n;\n\n          case FOR:\n            n = new Node(t, LOOP_INIT);\n            if (t.match(IDENTIFIER)) {\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(LEFT_PAREN);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            x3 = x.update({ inForLoopInit: true });\n            if ((tt = t.peek()) !== SEMICOLON) {\n                if (tt === VAR || tt === CONST) {\n                    t.get();\n                    n2 = Variables(t, x3);\n                } else if (tt === LET) {\n                    t.get();\n                    if (t.peek() === LEFT_PAREN) {\n                        n2 = LetBlock(t, x3, false);\n                    } else {\n                        // Let in for head, we need to add an implicit block\n                        // around the rest of the for.\n                        x3.parentBlock = n;\n                        n.varDecls = [];\n                        n2 = Variables(t, x3);\n                    }\n                } else {\n                    n2 = Expression(t, x3);\n                }\n            }\n            if (n2 && t.match(IN)) {\n                n.type = FOR_IN;\n                n.object = Expression(t, x3);\n                if (n2.type === VAR || n2.type === LET) {\n                    c = n2.children;\n\n                    // Destructuring turns one decl into multiples, so either\n                    // there must be only one destructuring or only one\n                    // decl.\n                    if (c.length !== 1 && n2.destructurings.length !== 1) {\n                        throw new SyntaxError(\"Invalid for..in left-hand side\",\n                                              t.filename, n2.lineno);\n                    }\n                    if (n2.destructurings.length > 0) {\n                        n.iterator = n2.destructurings[0];\n                    } else {\n                        n.iterator = c[0];\n                    }\n                    n.varDecl = n2;\n                } else {\n                    if (n2.type === ARRAY_INIT || n2.type === OBJECT_INIT) {\n                        n2.destructuredNames = checkDestructuring(t, x3, n2);\n                    }\n                    n.iterator = n2;\n                }\n            } else {\n                n.setup = n2;\n                t.mustMatch(SEMICOLON);\n                if (n.isEach)\n                    throw t.newSyntaxError(\"Invalid for each..in loop\");\n                n.condition = (t.peek() === SEMICOLON)\n                              ? null\n                              : Expression(t, x3);\n                t.mustMatch(SEMICOLON);\n                tt2 = t.peek();\n                n.update = (x.parenFreeMode\n                            ? tt2 === LEFT_CURLY || definitions.isStatementStartCode[tt2]\n                            : tt2 === RIGHT_PAREN)\n                           ? null\n                           : Expression(t, x3);\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(RIGHT_PAREN);\n            n.body = Statement(t, x2);\n            return n;\n\n          case WHILE:\n            n = new Node(t, { isLoop: true });\n            n.condition = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case DO:\n            n = new Node(t, { isLoop: true });\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            t.mustMatch(WHILE);\n            n.condition = HeadExpression(t, x);\n            if (!x.ecmaStrictMode) {\n                // <script language=\"JavaScript\"> (without version hints) may need\n                // automatic semicolon insertion without a newline after do-while.\n                // See http://bugzilla.mozilla.org/show_bug.cgi?id=238945.\n                t.match(SEMICOLON);\n                return n;\n            }\n            break;\n\n          case BREAK:\n          case CONTINUE:\n            n = new Node(t);\n\n            // handle the |foo: break foo;| corner case\n            x2 = x.pushTarget(n);\n\n            if (t.peekOnSameLine() === IDENTIFIER) {\n                t.get();\n                n.label = t.token.value;\n            }\n\n            n.target = n.label\n                     ? x2.labeledTargets.find(function(target) { return target.labels.has(n.label) })\n                     : x2.defaultTarget;\n\n            if (!n.target)\n                throw t.newSyntaxError(\"Invalid \" + ((tt === BREAK) ? \"break\" : \"continue\"));\n            if (!n.target.isLoop && tt === CONTINUE)\n                throw t.newSyntaxError(\"Invalid continue\");\n\n            break;\n\n          case TRY:\n            n = new Node(t, { catchClauses: [] });\n            n.tryBlock = Block(t, x);\n            while (t.match(CATCH)) {\n                n2 = new Node(t);\n                p = MaybeLeftParen(t, x);\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured catch identifiers.\n                    t.unget();\n                    n2.varName = DestructuringExpression(t, x, true);\n                    break;\n                  case IDENTIFIER:\n                    n2.varName = t.token.value;\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing identifier in catch\");\n                    break;\n                }\n                if (t.match(IF)) {\n                    if (x.ecma3OnlyMode)\n                        throw t.newSyntaxError(\"Illegal catch guard\");\n                    if (n.catchClauses.length && !n.catchClauses.top().guard)\n                        throw t.newSyntaxError(\"Guarded catch after unguarded\");\n                    n2.guard = Expression(t, x);\n                }\n                MaybeRightParen(t, p);\n                n2.block = Block(t, x);\n                n.catchClauses.push(n2);\n            }\n            if (t.match(FINALLY))\n                n.finallyBlock = Block(t, x);\n            if (!n.catchClauses.length && !n.finallyBlock)\n                throw t.newSyntaxError(\"Invalid try statement\");\n            return n;\n\n          case CATCH:\n          case FINALLY:\n            throw t.newSyntaxError(definitions.tokens[tt] + \" without preceding try\");\n\n          case THROW:\n            n = new Node(t);\n            n.exception = Expression(t, x);\n            break;\n\n          case RETURN:\n            n = ReturnOrYield(t, x);\n            break;\n\n          case WITH:\n            n = new Node(t);\n            n.object = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case VAR:\n          case CONST:\n            n = Variables(t, x);\n            break;\n\n          case LET:\n            if (t.peek() === LEFT_PAREN)\n                n = LetBlock(t, x, true);\n            else\n                n = Variables(t, x);\n            break;\n\n          case DEBUGGER:\n            n = new Node(t);\n            break;\n\n          case NEWLINE:\n          case SEMICOLON:\n            n = new Node(t, { type: SEMICOLON });\n            n.expression = null;\n            return n;\n\n          default:\n            if (tt === IDENTIFIER) {\n                tt = t.peek();\n                // Labeled statement.\n                if (tt === COLON) {\n                    label = t.token.value;\n                    if (x.allLabels.has(label))\n                        throw t.newSyntaxError(\"Duplicate label\");\n                    t.get();\n                    n = new Node(t, { type: LABEL, label: label });\n                    n.statement = Statement(t, x.pushLabel(label).nest(NESTING_SHALLOW));\n                    n.target = (n.statement.type === LABEL) ? n.statement.target : n.statement;\n                    return n;\n                }\n            }\n\n            // Expression statement.\n            // We unget the current token to parse the expression as a whole.\n            n = new Node(t, { type: SEMICOLON });\n            t.unget();\n            n.expression = Expression(t, x);\n            n.end = n.expression.end;\n            break;\n        }\n\n        MagicalSemicolon(t);\n        return n;\n    }\n\n    function MagicalSemicolon(t) {\n        var tt;\n        if (t.lineno === t.token.lineno) {\n            tt = t.peekOnSameLine();\n            if (tt !== END && tt !== NEWLINE && tt !== SEMICOLON && tt !== RIGHT_CURLY)\n                throw t.newSyntaxError(\"missing ; before statement\");\n        }\n        t.match(SEMICOLON);\n    }\n\n    function ReturnOrYield(t, x) {\n        var n, b, tt = t.token.type, tt2;\n\n        var parentScript = x.parentScript;\n\n        if (tt === RETURN) {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Return not in function\");\n        } else /* if (tt === YIELD) */ {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Yield not in function\");\n            parentScript.isGenerator = true;\n        }\n        n = new Node(t, { value: undefined });\n\n        tt2 = t.peek(true);\n        if (tt2 !== END && tt2 !== NEWLINE &&\n            tt2 !== SEMICOLON && tt2 !== RIGHT_CURLY\n            && (tt !== YIELD ||\n                (tt2 !== tt && tt2 !== RIGHT_BRACKET && tt2 !== RIGHT_PAREN &&\n                 tt2 !== COLON && tt2 !== COMMA))) {\n            if (tt === RETURN) {\n                n.value = Expression(t, x);\n                parentScript.hasReturnWithValue = true;\n            } else {\n                n.value = AssignExpression(t, x);\n            }\n        } else if (tt === RETURN) {\n            parentScript.hasEmptyReturn = true;\n        }\n\n        // Disallow return v; in generator.\n        if (parentScript.hasReturnWithValue && parentScript.isGenerator)\n            throw t.newSyntaxError(\"Generator returns a value\");\n\n        return n;\n    }\n\n    /*\n     * FunctionDefinition :: (tokenizer, compiler context, boolean,\n     *                        DECLARED_FORM or EXPRESSED_FORM or STATEMENT_FORM)\n     *                    -> node\n     */\n    function FunctionDefinition(t, x, requireName, functionForm) {\n        var tt;\n        var f = new Node(t, { params: [] });\n        if (f.type !== FUNCTION)\n            f.type = (f.value === \"get\") ? GETTER : SETTER;\n        if (t.match(IDENTIFIER))\n            f.name = t.token.value;\n        else if (requireName)\n            throw t.newSyntaxError(\"missing function identifier\");\n\n        var x2 = new StaticContext(null, null, true, false, NESTING_TOP);\n\n        t.mustMatch(LEFT_PAREN);\n        if (!t.match(RIGHT_PAREN)) {\n            do {\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured formal parameters.\n                    t.unget();\n                    f.params.push(DestructuringExpression(t, x2));\n                    break;\n                  case IDENTIFIER:\n                    f.params.push(t.token.value);\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing formal parameter\");\n                    break;\n                }\n            } while (t.match(COMMA));\n            t.mustMatch(RIGHT_PAREN);\n        }\n\n        // Do we have an expression closure or a normal body?\n        tt = t.get();\n        if (tt !== LEFT_CURLY)\n            t.unget();\n\n        if (tt !== LEFT_CURLY) {\n            f.body = AssignExpression(t, x2);\n            if (f.body.isGenerator)\n                throw t.newSyntaxError(\"Generator returns a value\");\n        } else {\n            f.body = Script(t, true);\n        }\n\n        if (tt === LEFT_CURLY)\n            t.mustMatch(RIGHT_CURLY);\n\n        f.end = t.token.end;\n        f.functionForm = functionForm;\n        if (functionForm === DECLARED_FORM)\n            x.parentScript.funDecls.push(f);\n        return f;\n    }\n\n    /*\n     * Variables :: (tokenizer, compiler context) -> node\n     *\n     * Parses a comma-separated list of var declarations (and maybe\n     * initializations).\n     */\n    function Variables(t, x, letBlock) {\n        var n, n2, ss, i, s, tt;\n\n        tt = t.token.type;\n        switch (tt) {\n          case VAR:\n          case CONST:\n            s = x.parentScript;\n            break;\n          case LET:\n            s = x.parentBlock;\n            break;\n          case LEFT_PAREN:\n            tt = LET;\n            s = letBlock;\n            break;\n        }\n\n        n = new Node(t, { type: tt, destructurings: [] });\n\n        do {\n            tt = t.get();\n            if (tt === LEFT_BRACKET || tt === LEFT_CURLY) {\n                // Need to unget to parse the full destructured expression.\n                t.unget();\n\n                var dexp = DestructuringExpression(t, x, true);\n\n                n2 = new Node(t, { type: IDENTIFIER,\n                                   name: dexp,\n                                   readOnly: n.type === CONST });\n                n.push(n2);\n                pushDestructuringVarDecls(n2.name.destructuredNames, s);\n                n.destructurings.push({ exp: dexp, decl: n2 });\n\n                if (x.inForLoopInit && t.peek() === IN) {\n                    continue;\n                }\n\n                t.mustMatch(ASSIGN);\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n\n                continue;\n            }\n\n            if (tt !== IDENTIFIER)\n                throw t.newSyntaxError(\"missing variable name\");\n\n            n2 = new Node(t, { type: IDENTIFIER,\n                               name: t.token.value,\n                               readOnly: n.type === CONST });\n            n.push(n2);\n            s.varDecls.push(n2);\n\n            if (t.match(ASSIGN)) {\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n            }\n        } while (t.match(COMMA));\n\n        return n;\n    }\n\n    /*\n     * LetBlock :: (tokenizer, compiler context, boolean) -> node\n     *\n     * Does not handle let inside of for loop init.\n     */\n    function LetBlock(t, x, isStatement) {\n        var n, n2;\n\n        // t.token.type must be LET\n        n = new Node(t, { type: LET_BLOCK, varDecls: [] });\n        t.mustMatch(LEFT_PAREN);\n        n.variables = Variables(t, x, n);\n        t.mustMatch(RIGHT_PAREN);\n\n        if (isStatement && t.peek() !== LEFT_CURLY) {\n            /*\n             * If this is really an expression in let statement guise, then we\n             * need to wrap the LET_BLOCK node in a SEMICOLON node so that we pop\n             * the return value of the expression.\n             */\n            n2 = new Node(t, { type: SEMICOLON,\n                               expression: n });\n            isStatement = false;\n        }\n\n        if (isStatement)\n            n.block = Block(t, x);\n        else\n            n.expression = AssignExpression(t, x);\n\n        return n;\n    }\n\n    function checkDestructuring(t, x, n, simpleNamesOnly) {\n        if (n.type === ARRAY_COMP)\n            throw t.newSyntaxError(\"Invalid array comprehension left-hand side\");\n        if (n.type !== ARRAY_INIT && n.type !== OBJECT_INIT)\n            return;\n\n        var lhss = {};\n        var nn, n2, idx, sub, cc, c = n.children;\n        for (var i = 0, j = c.length; i < j; i++) {\n            if (!(nn = c[i]))\n                continue;\n            if (nn.type === PROPERTY_INIT) {\n                cc = nn.children;\n                sub = cc[1];\n                idx = cc[0].value;\n            } else if (n.type === OBJECT_INIT) {\n                // Do we have destructuring shorthand {foo, bar}?\n                sub = nn;\n                idx = nn.value;\n            } else {\n                sub = nn;\n                idx = i;\n            }\n\n            if (sub.type === ARRAY_INIT || sub.type === OBJECT_INIT) {\n                lhss[idx] = checkDestructuring(t, x, sub, simpleNamesOnly);\n            } else {\n                if (simpleNamesOnly && sub.type !== IDENTIFIER) {\n                    // In declarations, lhs must be simple names\n                    throw t.newSyntaxError(\"missing name in pattern\");\n                }\n\n                lhss[idx] = sub;\n            }\n        }\n\n        return lhss;\n    }\n\n    function DestructuringExpression(t, x, simpleNamesOnly) {\n        var n = PrimaryExpression(t, x);\n        // Keep the list of lefthand sides for varDecls\n        n.destructuredNames = checkDestructuring(t, x, n, simpleNamesOnly);\n        return n;\n    }\n\n    function GeneratorExpression(t, x, e) {\n        return new Node(t, { type: GENERATOR,\n                             expression: e,\n                             tail: ComprehensionTail(t, x) });\n    }\n\n    function ComprehensionTail(t, x) {\n        var body, n, n2, n3, p;\n\n        // t.token.type must be FOR\n        body = new Node(t, { type: COMP_TAIL });\n\n        do {\n            // Comprehension tails are always for..in loops.\n            n = new Node(t, { type: FOR_IN, isLoop: true });\n            if (t.match(IDENTIFIER)) {\n                // But sometimes they're for each..in.\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            p = MaybeLeftParen(t, x);\n            switch(t.get()) {\n              case LEFT_BRACKET:\n              case LEFT_CURLY:\n                t.unget();\n                // Destructured left side of for in comprehension tails.\n                n.iterator = DestructuringExpression(t, x);\n                break;\n\n              case IDENTIFIER:\n                n.iterator = n3 = new Node(t, { type: IDENTIFIER });\n                n3.name = n3.value;\n                n.varDecl = n2 = new Node(t, { type: VAR });\n                n2.push(n3);\n                x.parentScript.varDecls.push(n3);\n                // Don't add to varDecls since the semantics of comprehensions is\n                // such that the variables are in their own function when\n                // desugared.\n                break;\n\n              default:\n                throw t.newSyntaxError(\"missing identifier\");\n            }\n            t.mustMatch(IN);\n            n.object = Expression(t, x);\n            MaybeRightParen(t, p);\n            body.push(n);\n        } while (t.match(FOR));\n\n        // Optional guard.\n        if (t.match(IF))\n            body.guard = HeadExpression(t, x);\n\n        return body;\n    }\n\n    function HeadExpression(t, x) {\n        var p = MaybeLeftParen(t, x);\n        var n = ParenExpression(t, x);\n        MaybeRightParen(t, p);\n        if (p === END && !n.parenthesized) {\n            var tt = t.peek();\n            if (tt !== LEFT_CURLY && !definitions.isStatementStartCode[tt])\n                throw t.newSyntaxError(\"Unparenthesized head followed by unbraced body\");\n        }\n        return n;\n    }\n\n    function ParenExpression(t, x) {\n        // Always accept the 'in' operator in a parenthesized expression,\n        // where it's unambiguous, even if we might be parsing the init of a\n        // for statement.\n        var n = Expression(t, x.update({ inForLoopInit: x.inForLoopInit &&\n                                                        (t.token.type === LEFT_PAREN) }));\n\n        if (t.match(FOR)) {\n            if (n.type === YIELD && !n.parenthesized)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (n.type === COMMA && !n.parenthesized)\n                throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            n = GeneratorExpression(t, x, n);\n        }\n\n        return n;\n    }\n\n    /*\n     * Expression :: (tokenizer, compiler context) -> node\n     *\n     * Top-down expression parser matched against SpiderMonkey.\n     */\n    function Expression(t, x) {\n        var n, n2;\n\n        n = AssignExpression(t, x);\n        if (t.match(COMMA)) {\n            n2 = new Node(t, { type: COMMA });\n            n2.push(n);\n            n = n2;\n            do {\n                n2 = n.children[n.children.length-1];\n                if (n2.type === YIELD && !n2.parenthesized)\n                    throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n                n.push(AssignExpression(t, x));\n            } while (t.match(COMMA));\n        }\n\n        return n;\n    }\n\n    function AssignExpression(t, x) {\n        var n, lhs;\n\n        // Have to treat yield like an operand because it could be the leftmost\n        // operand of the expression.\n        if (t.match(YIELD, true))\n            return ReturnOrYield(t, x);\n\n        n = new Node(t, { type: ASSIGN });\n        lhs = ConditionalExpression(t, x);\n\n        if (!t.match(ASSIGN)) {\n            return lhs;\n        }\n\n        switch (lhs.type) {\n          case OBJECT_INIT:\n          case ARRAY_INIT:\n            lhs.destructuredNames = checkDestructuring(t, x, lhs);\n            // FALL THROUGH\n          case IDENTIFIER: case DOT: case INDEX: case CALL:\n            break;\n          default:\n            throw t.newSyntaxError(\"Bad left-hand side of assignment\");\n            break;\n        }\n\n        n.assignOp = t.token.assignOp;\n        n.push(lhs);\n        n.push(AssignExpression(t, x));\n\n        return n;\n    }\n\n    function ConditionalExpression(t, x) {\n        var n, n2;\n\n        n = OrExpression(t, x);\n        if (t.match(HOOK)) {\n            n2 = n;\n            n = new Node(t, { type: HOOK });\n            n.push(n2);\n            /*\n             * Always accept the 'in' operator in the middle clause of a ternary,\n             * where it's unambiguous, even if we might be parsing the init of a\n             * for statement.\n             */\n            n.push(AssignExpression(t, x.update({ inForLoopInit: false })));\n            if (!t.match(COLON))\n                throw t.newSyntaxError(\"missing : after ?\");\n            n.push(AssignExpression(t, x));\n        }\n\n        return n;\n    }\n\n    function OrExpression(t, x) {\n        var n, n2;\n\n        n = AndExpression(t, x);\n        while (t.match(OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AndExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseOrExpression(t, x);\n        while (t.match(AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseOrExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseOrExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseXorExpression(t, x);\n        while (t.match(BITWISE_OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseXorExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseXorExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseAndExpression(t, x);\n        while (t.match(BITWISE_XOR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseAndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseAndExpression(t, x) {\n        var n, n2;\n\n        n = EqualityExpression(t, x);\n        while (t.match(BITWISE_AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(EqualityExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function EqualityExpression(t, x) {\n        var n, n2;\n\n        n = RelationalExpression(t, x);\n        while (t.match(EQ) || t.match(NE) ||\n               t.match(STRICT_EQ) || t.match(STRICT_NE)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(RelationalExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function RelationalExpression(t, x) {\n        var n, n2;\n\n        /*\n         * Uses of the in operator in shiftExprs are always unambiguous,\n         * so unset the flag that prohibits recognizing it.\n         */\n        var x2 = x.update({ inForLoopInit: false });\n        n = ShiftExpression(t, x2);\n        while ((t.match(LT) || t.match(LE) || t.match(GE) || t.match(GT) ||\n               (!x.inForLoopInit && t.match(IN)) ||\n               t.match(INSTANCEOF))) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(ShiftExpression(t, x2));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ShiftExpression(t, x) {\n        var n, n2;\n\n        n = AddExpression(t, x);\n        while (t.match(LSH) || t.match(RSH) || t.match(URSH)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AddExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AddExpression(t, x) {\n        var n, n2;\n\n        n = MultiplyExpression(t, x);\n        while (t.match(PLUS) || t.match(MINUS)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(MultiplyExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function MultiplyExpression(t, x) {\n        var n, n2;\n\n        n = UnaryExpression(t, x);\n        while (t.match(MUL) || t.match(DIV) || t.match(MOD)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(UnaryExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function UnaryExpression(t, x) {\n        var n, n2, tt;\n\n        switch (tt = t.get(true)) {\n          case DELETE: case VOID: case TYPEOF:\n          case NOT: case BITWISE_NOT: case PLUS: case MINUS:\n            if (tt === PLUS)\n                n = new Node(t, { type: UNARY_PLUS });\n            else if (tt === MINUS)\n                n = new Node(t, { type: UNARY_MINUS });\n            else\n                n = new Node(t);\n            n.push(UnaryExpression(t, x));\n            break;\n\n          case INCREMENT:\n          case DECREMENT:\n            // Prefix increment/decrement.\n            n = new Node(t);\n            n.push(MemberExpression(t, x, true));\n            break;\n\n          default:\n            t.unget();\n            n = MemberExpression(t, x, true);\n\n            // Don't look across a newline boundary for a postfix {in,de}crement.\n            if (t.tokens[(t.tokenIndex + t.lookahead - 1) & 3].lineno ===\n                t.lineno) {\n                if (t.match(INCREMENT) || t.match(DECREMENT)) {\n                    n2 = new Node(t, { postfix: true });\n                    n2.push(n);\n                    n = n2;\n                }\n            }\n            break;\n        }\n\n        return n;\n    }\n\n    function MemberExpression(t, x, allowCallSyntax) {\n        var n, n2, name, tt;\n\n        if (t.match(NEW)) {\n            n = new Node(t);\n            n.push(MemberExpression(t, x, false));\n            if (t.match(LEFT_PAREN)) {\n                n.type = NEW_WITH_ARGS;\n                n.push(ArgumentList(t, x));\n            }\n        } else {\n            n = PrimaryExpression(t, x);\n        }\n\n        while ((tt = t.get()) !== END) {\n            switch (tt) {\n              case DOT:\n                n2 = new Node(t);\n                n2.push(n);\n                t.mustMatch(IDENTIFIER);\n                n2.push(new Node(t));\n                break;\n\n              case LEFT_BRACKET:\n                n2 = new Node(t, { type: INDEX });\n                n2.push(n);\n                n2.push(Expression(t, x));\n                t.mustMatch(RIGHT_BRACKET);\n                break;\n\n              case LEFT_PAREN:\n                if (allowCallSyntax) {\n                    n2 = new Node(t, { type: CALL });\n                    n2.push(n);\n                    n2.push(ArgumentList(t, x));\n                    break;\n                }\n\n                // FALL THROUGH\n              default:\n                t.unget();\n                return n;\n            }\n\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ArgumentList(t, x) {\n        var n, n2;\n\n        n = new Node(t, { type: LIST });\n        if (t.match(RIGHT_PAREN, true))\n            return n;\n        do {\n            n2 = AssignExpression(t, x);\n            if (n2.type === YIELD && !n2.parenthesized && t.peek() === COMMA)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (t.match(FOR)) {\n                n2 = GeneratorExpression(t, x, n2);\n                if (n.children.length > 1 || t.peek(true) === COMMA)\n                    throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            }\n            n.push(n2);\n        } while (t.match(COMMA));\n        t.mustMatch(RIGHT_PAREN);\n\n        return n;\n    }\n\n    function PrimaryExpression(t, x) {\n        var n, n2, tt = t.get(true);\n\n        switch (tt) {\n          case FUNCTION:\n            n = FunctionDefinition(t, x, false, EXPRESSED_FORM);\n            break;\n\n          case LEFT_BRACKET:\n            n = new Node(t, { type: ARRAY_INIT });\n            while ((tt = t.peek(true)) !== RIGHT_BRACKET) {\n                if (tt === COMMA) {\n                    t.get();\n                    n.push(null);\n                    continue;\n                }\n                n.push(AssignExpression(t, x));\n                if (tt !== COMMA && !t.match(COMMA))\n                    break;\n            }\n\n            // If we matched exactly one element and got a FOR, we have an\n            // array comprehension.\n            if (n.children.length === 1 && t.match(FOR)) {\n                n2 = new Node(t, { type: ARRAY_COMP,\n                                   expression: n.children[0],\n                                   tail: ComprehensionTail(t, x) });\n                n = n2;\n            }\n            t.mustMatch(RIGHT_BRACKET);\n            break;\n\n          case LEFT_CURLY:\n            var id, fd;\n            n = new Node(t, { type: OBJECT_INIT });\n\n          object_init:\n            if (!t.match(RIGHT_CURLY)) {\n                do {\n                    tt = t.get();\n                    if ((t.token.value === \"get\" || t.token.value === \"set\") &&\n                        t.peek() === IDENTIFIER) {\n                        if (x.ecma3OnlyMode)\n                            throw t.newSyntaxError(\"Illegal property accessor\");\n                        n.push(FunctionDefinition(t, x, true, EXPRESSED_FORM));\n                    } else {\n                        switch (tt) {\n                          case IDENTIFIER: case NUMBER: case STRING:\n                            id = new Node(t, { type: IDENTIFIER });\n                            break;\n                          case RIGHT_CURLY:\n                            if (x.ecma3OnlyMode)\n                                throw t.newSyntaxError(\"Illegal trailing ,\");\n                            break object_init;\n                          default:\n                            if (t.token.value in definitions.keywords) {\n                                id = new Node(t, { type: IDENTIFIER });\n                                break;\n                            }\n                            throw t.newSyntaxError(\"Invalid property name\");\n                        }\n                        if (t.match(COLON)) {\n                            n2 = new Node(t, { type: PROPERTY_INIT });\n                            n2.push(id);\n                            n2.push(AssignExpression(t, x));\n                            n.push(n2);\n                        } else {\n                            // Support, e.g., |var {x, y} = o| as destructuring shorthand\n                            // for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.\n                            if (t.peek() !== COMMA && t.peek() !== RIGHT_CURLY)\n                                throw t.newSyntaxError(\"missing : after property\");\n                            n.push(id);\n                        }\n                    }\n                } while (t.match(COMMA));\n                t.mustMatch(RIGHT_CURLY);\n            }\n            break;\n\n          case LEFT_PAREN:\n            n = ParenExpression(t, x);\n            t.mustMatch(RIGHT_PAREN);\n            n.parenthesized = true;\n            break;\n\n          case LET:\n            n = LetBlock(t, x, false);\n            break;\n\n          case NULL: case THIS: case TRUE: case FALSE:\n          case IDENTIFIER: case NUMBER: case STRING: case REGEXP:\n            n = new Node(t);\n            break;\n\n          default:\n            throw t.newSyntaxError(\"missing operand\");\n            break;\n        }\n\n        return n;\n    }\n\n    /*\n     * parse :: (source, filename, line number) -> node\n     */\n    function parse(s, f, l) {\n        var t = new lexer.Tokenizer(s, f, l);\n        var n = Script(t, false);\n        if (!t.done)\n            throw t.newSyntaxError(\"Syntax error\");\n\n        return n;\n    }\n\n    /*\n     * parseStdin :: (source, {line number}) -> node\n     */\n    function parseStdin(s, ln) {\n        for (;;) {\n            try {\n                var t = new lexer.Tokenizer(s, \"stdin\", ln.value);\n                var n = Script(t, false);\n                ln.value = t.lineno;\n                return n;\n            } catch (e) {\n                if (!t.unexpectedEOF)\n                    throw e;\n                var more = readline();\n                if (!more)\n                    throw e;\n                s += \"\\n\" + more;\n            }\n        }\n    }\n\n    return {\n        parse: parse,\n        parseStdin: parseStdin,\n        Node: Node,\n        DECLARED_FORM: DECLARED_FORM,\n        EXPRESSED_FORM: EXPRESSED_FORM,\n        STATEMENT_FORM: STATEMENT_FORM,\n        Tokenizer: lexer.Tokenizer,\n        FunctionDefinition: FunctionDefinition\n    };\n\n}());\n\nvar exports = {\n  definitions: Narcissus.definitions,\n  lexer: Narcissus.lexer,\n  parser: Narcissus.parser\n};\n\nif (typeof module != 'undefined') {\n  module.exports = exports;\n};\n\n",
      "rendered": true,
      "contentRendered": "/* vim: set sw=4 ts=4 et tw=78: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (typeof module == 'undefined') {\n  this.Narcissus = new Object;\n}\n\nvar Narcissus = {\n    options: {\n        version: 185,\n    },\n    hostGlobal: this\n};\n\nNarcissus.definitions = (function() {\n\n    var tokens = [\n        // End of source.\n        \"END\",\n\n        // Operators and punctuators.  Some pair-wise order matters, e.g. (+, -)\n        // and (UNARY_PLUS, UNARY_MINUS).\n        \"\\n\", \";\",\n        \",\",\n        \"=\",\n        \"?\", \":\", \"CONDITIONAL\",\n        \"||\",\n        \"&&\",\n        \"|\",\n        \"^\",\n        \"&\",\n        \"==\", \"!=\", \"===\", \"!==\",\n        \"<\", \"<=\", \">=\", \">\",\n        \"<<\", \">>\", \">>>\",\n        \"+\", \"-\",\n        \"*\", \"/\", \"%\",\n        \"!\", \"~\", \"UNARY_PLUS\", \"UNARY_MINUS\",\n        \"++\", \"--\",\n        \".\",\n        \"[\", \"]\",\n        \"{\", \"}\",\n        \"(\", \")\",\n\n        // Nonterminal tree node type codes.\n        \"SCRIPT\", \"BLOCK\", \"LABEL\", \"FOR_IN\", \"CALL\", \"NEW_WITH_ARGS\", \"INDEX\",\n        \"ARRAY_INIT\", \"OBJECT_INIT\", \"PROPERTY_INIT\", \"GETTER\", \"SETTER\",\n        \"GROUP\", \"LIST\", \"LET_BLOCK\", \"ARRAY_COMP\", \"GENERATOR\", \"COMP_TAIL\",\n\n        // Terminals.\n        \"IDENTIFIER\", \"NUMBER\", \"STRING\", \"REGEXP\",\n\n        // Keywords.\n        \"break\",\n        \"case\", \"catch\", \"const\", \"continue\",\n        \"debugger\", \"default\", \"delete\", \"do\",\n        \"else\",\n        \"false\", \"finally\", \"for\", \"function\",\n        \"if\", \"in\", \"instanceof\",\n        \"let\",\n        \"new\", \"null\",\n        \"return\",\n        \"switch\",\n        \"this\", \"throw\", \"true\", \"try\", \"typeof\",\n        \"var\", \"void\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    var statementStartTokens = [\n        \"break\",\n        \"const\", \"continue\",\n        \"debugger\", \"do\",\n        \"for\",\n        \"if\",\n        \"return\",\n        \"switch\",\n        \"throw\", \"try\",\n        \"var\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    // Operator and punctuator mapping from token to tree node type name.\n    // NB: because the lexer doesn't backtrack, all token prefixes must themselves\n    // be valid tokens (e.g. !== is acceptable because its prefixes are the valid\n    // tokens != and !).\n    var opTypeNames = {\n        '\\n':   \"NEWLINE\",\n        ';':    \"SEMICOLON\",\n        ',':    \"COMMA\",\n        '?':    \"HOOK\",\n        ':':    \"COLON\",\n        '||':   \"OR\",\n        '&&':   \"AND\",\n        '|':    \"BITWISE_OR\",\n        '^':    \"BITWISE_XOR\",\n        '&':    \"BITWISE_AND\",\n        '===':  \"STRICT_EQ\",\n        '==':   \"EQ\",\n        '=':    \"ASSIGN\",\n        '!==':  \"STRICT_NE\",\n        '!=':   \"NE\",\n        '<<':   \"LSH\",\n        '<=':   \"LE\",\n        '<':    \"LT\",\n        '>>>':  \"URSH\",\n        '>>':   \"RSH\",\n        '>=':   \"GE\",\n        '>':    \"GT\",\n        '++':   \"INCREMENT\",\n        '--':   \"DECREMENT\",\n        '+':    \"PLUS\",\n        '-':    \"MINUS\",\n        '*':    \"MUL\",\n        '/':    \"DIV\",\n        '%':    \"MOD\",\n        '!':    \"NOT\",\n        '~':    \"BITWISE_NOT\",\n        '.':    \"DOT\",\n        '[':    \"LEFT_BRACKET\",\n        ']':    \"RIGHT_BRACKET\",\n        '{':    \"LEFT_CURLY\",\n        '}':    \"RIGHT_CURLY\",\n        '(':    \"LEFT_PAREN\",\n        ')':    \"RIGHT_PAREN\"\n    };\n\n    // Hash of keyword identifier to tokens index.  NB: we must null __proto__ to\n    // avoid toString, etc. namespace pollution.\n    var keywords = {__proto__: null};\n\n    // Define const END, etc., based on the token names.  Also map name to index.\n    var tokenIds = {};\n\n    // Building up a string to be eval'd in different contexts.\n    var consts = \"const \";\n    for (var i = 0, j = tokens.length; i < j; i++) {\n        if (i > 0)\n            consts += \", \";\n        var t = tokens[i];\n        var name;\n        if (/^[a-z]/.test(t)) {\n            name = t.toUpperCase();\n            keywords[t] = i;\n        } else {\n            name = (/^\\W/.test(t) ? opTypeNames[t] : t);\n        }\n        consts += name + \" = \" + i;\n        tokenIds[name] = i;\n        tokens[t] = i;\n    }\n    consts += \";\";\n\n    var isStatementStartCode = {__proto__: null};\n    for (i = 0, j = statementStartTokens.length; i < j; i++)\n        isStatementStartCode[keywords[statementStartTokens[i]]] = true;\n\n    // Map assignment operators to their indexes in the tokens array.\n    var assignOps = ['|', '^', '&', '<<', '>>', '>>>', '+', '-', '*', '/', '%'];\n\n    for (i = 0, j = assignOps.length; i < j; i++) {\n        t = assignOps[i];\n        assignOps[t] = tokens[t];\n    }\n\n    function defineGetter(obj, prop, fn, dontDelete, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { get: fn, configurable: !dontDelete, enumerable: !dontEnum });\n    }\n\n    function defineProperty(obj, prop, val, dontDelete, readOnly, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { value: val, writable: !readOnly, configurable: !dontDelete,\n                                enumerable: !dontEnum });\n    }\n\n    // Returns true if fn is a native function.  (Note: SpiderMonkey specific.)\n    function isNativeCode(fn) {\n        // Relies on the toString method to identify native code.\n        return ((typeof fn) === \"function\") && fn.toString().match(/\\[native code\\]/);\n    }\n\n    function getPropertyDescriptor(obj, name) {\n        while (obj) {\n            if (({}).hasOwnProperty.call(obj, name))\n                return Object.getOwnPropertyDescriptor(obj, name);\n            obj = Object.getPrototypeOf(obj);\n        }\n    }\n\n    function getOwnProperties(obj) {\n        var map = {};\n        for (var name in Object.getOwnPropertyNames(obj))\n            map[name] = Object.getOwnPropertyDescriptor(obj, name);\n        return map;\n    }\n\n    function makePassthruHandler(obj) {\n        // Handler copied from\n        // http://wiki.ecmascript.org/doku.php?id=harmony:proxies&s=proxy%20object#examplea_no-op_forwarding_proxy\n        return {\n            getOwnPropertyDescriptor: function(name) {\n                var desc = Object.getOwnPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getPropertyDescriptor: function(name) {\n                var desc = getPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getOwnPropertyNames: function() {\n                return Object.getOwnPropertyNames(obj);\n            },\n            defineProperty: function(name, desc) {\n                Object.defineProperty(obj, name, desc);\n            },\n            \"delete\": function(name) { return delete obj[name]; },\n            fix: function() {\n                if (Object.isFrozen(obj)) {\n                    return getOwnProperties(obj);\n                }\n\n                // As long as obj is not frozen, the proxy won't allow itself to be fixed.\n                return undefined; // will cause a TypeError to be thrown\n            },\n\n            has: function(name) { return name in obj; },\n            hasOwn: function(name) { return ({}).hasOwnProperty.call(obj, name); },\n            get: function(receiver, name) { return obj[name]; },\n\n            // bad behavior when set fails in non-strict mode\n            set: function(receiver, name, val) { obj[name] = val; return true; },\n            enumerate: function() {\n                var result = [];\n                for (name in obj) { result.push(name); };\n                return result;\n            },\n            keys: function() { return Object.keys(obj); }\n        };\n    }\n\n    // default function used when looking for a property in the global object\n    function noPropFound() { return undefined; }\n\n    var hasOwnProperty = ({}).hasOwnProperty;\n\n    function StringMap() {\n        this.table = Object.create(null, {});\n        this.size = 0;\n    }\n\n    StringMap.prototype = {\n        has: function(x) { return hasOwnProperty.call(this.table, x); },\n        set: function(x, v) {\n            if (!hasOwnProperty.call(this.table, x))\n                this.size++;\n            this.table[x] = v;\n        },\n        get: function(x) { return this.table[x]; },\n        getDef: function(x, thunk) {\n            if (!hasOwnProperty.call(this.table, x)) {\n                this.size++;\n                this.table[x] = thunk();\n            }\n            return this.table[x];\n        },\n        forEach: function(f) {\n            var table = this.table;\n            for (var key in table)\n                f.call(this, key, table[key]);\n        },\n        toString: function() { return \"[object StringMap]\" }\n    };\n\n    // non-destructive stack\n    function Stack(elts) {\n        this.elts = elts || null;\n    }\n\n    Stack.prototype = {\n        push: function(x) {\n            return new Stack({ top: x, rest: this.elts });\n        },\n        top: function() {\n            if (!this.elts)\n                throw new Error(\"empty stack\");\n            return this.elts.top;\n        },\n        isEmpty: function() {\n            return this.top === null;\n        },\n        find: function(test) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                if (test(elts.top))\n                    return elts.top;\n            }\n            return null;\n        },\n        has: function(x) {\n            return Boolean(this.find(function(elt) { return elt === x }));\n        },\n        forEach: function(f) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                f(elts.top);\n            }\n        }\n    };\n\n    return {\n        tokens: tokens,\n        opTypeNames: opTypeNames,\n        keywords: keywords,\n        isStatementStartCode: isStatementStartCode,\n        tokenIds: tokenIds,\n        consts: consts,\n        assignOps: assignOps,\n        defineGetter: defineGetter,\n        defineProperty: defineProperty,\n        isNativeCode: isNativeCode,\n        makePassthruHandler: makePassthruHandler,\n        noPropFound: noPropFound,\n        StringMap: StringMap,\n        Stack: Stack\n    };\n}());\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Lexical scanner.\n */\n\nNarcissus.lexer = (function() {\n\n    var definitions = Narcissus.definitions;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    // Build up a trie of operator tokens.\n    var opTokens = {};\n    for (var op in definitions.opTypeNames) {\n        if (op === '\\n' || op === '.')\n            continue;\n\n        var node = opTokens;\n        for (var i = 0; i < op.length; i++) {\n            var ch = op[i];\n            if (!(ch in node))\n                node[ch] = {};\n            node = node[ch];\n            node.op = op;\n        }\n    }\n\n    /*\n     * Tokenizer :: (source, filename, line number) -> Tokenizer\n     */\n    function Tokenizer(s, f, l) {\n        this.cursor = 0;\n        this.source = String(s);\n        this.tokens = [];\n        this.tokenIndex = 0;\n        this.lookahead = 0;\n        this.scanNewlines = false;\n        this.unexpectedEOF = false;\n        this.filename = f || \"\";\n        this.lineno = l || 1;\n        this.comments = [];\n    }\n\n    Tokenizer.prototype = {\n        get done() {\n            // We need to set scanOperand to true here because the first thing\n            // might be a regexp.\n            return this.peek(true) === END;\n        },\n\n        get token() {\n            return this.tokens[this.tokenIndex];\n        },\n\n        match: function (tt, scanOperand) {\n            return this.get(scanOperand) === tt || this.unget();\n        },\n\n        mustMatch: function (tt) {\n            if (!this.match(tt)) {\n                throw this.newSyntaxError(\"Missing \" +\n                                          definitions.tokens[tt].toLowerCase());\n            }\n            return this.token;\n        },\n\n        peek: function (scanOperand) {\n            var tt, next;\n            if (this.lookahead) {\n                next = this.tokens[(this.tokenIndex + this.lookahead) & 3];\n                tt = (this.scanNewlines && next.lineno !== this.lineno)\n                     ? NEWLINE\n                     : next.type;\n            } else {\n                tt = this.get(scanOperand);\n                this.unget();\n            }\n            return tt;\n        },\n\n        peekOnSameLine: function (scanOperand) {\n            this.scanNewlines = true;\n            var tt = this.peek(scanOperand);\n            this.scanNewlines = false;\n            return tt;\n        },\n\n        // Eat comments and whitespace.\n        // toka: returns list of skipped comments\n        skip: function () {\n            var input = this.source;\n            var cstart;\n            var clineno;\n            var comments = [];\n            var comment;\n            var nlcount = 0;\n\n            for (;;) {\n                var ch = input[this.cursor++];\n                var next = input[this.cursor];\n                if (ch === '\\n' && !this.scanNewlines) {\n                    this.lineno++;\n                    nlcount++;\n                } else if (ch === '/' && next === '*') {\n                    cstart = this.cursor;\n                    clineno = this.lineno;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated comment\");\n\n                        if (ch === '*') {\n                            next = input[this.cursor];\n                            if (next === '/') {\n                                this.cursor++;\n                                comment = {\n                                    type: \"BLOCK_COMMENT\",\n                                    nlcount: nlcount,\n                                    start:cstart-1, end:this.cursor, lineno:clineno, endlineno: this.lineno,\n                                    value: input.substring(cstart+1,this.cursor-2)\n                                }\n                                // comments.push(comment);\n                                this.comments.push(comment);\n                                nlcount = 0;\n                                break;\n                            }\n                        } else if (ch === '\\n') {\n                            this.lineno++;\n                        }\n                    }\n                } else if (ch === '/' && next === '/') {\n                    cstart = this.cursor;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined) {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            // comments.push(comment);\n                            this.comments.push(comment);\n                            return;\n                            // return comments;\n                        }\n                        if (ch === '\\n') {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            //comments.push(  );\n                            this.comments.push(comment);\n                            nlcount = 0;\n                            this.lineno++;\n                            break;\n                        }\n                    }\n                } else if (ch !== ' ' && ch !== '\\t') {\n                    this.cursor--;\n                    // return comments;\n                    return;\n                }\n            }\n        },\n\n        // Lex the exponential part of a number, if present. Return true iff an\n        // exponential part was found.\n        lexExponent: function() {\n            var input = this.source;\n            var next = input[this.cursor];\n            if (next === 'e' || next === 'E') {\n                this.cursor++;\n                ch = input[this.cursor++];\n                if (ch === '+' || ch === '-')\n                    ch = input[this.cursor++];\n\n                if (ch < '0' || ch > '9')\n                    throw this.newSyntaxError(\"Missing exponent\");\n\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                return true;\n            }\n\n            return false;\n        },\n\n        lexZeroNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            ch = input[this.cursor++];\n            if (ch === '.') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n                token.value = parseFloat(token.start, this.cursor);\n            } else if (ch === 'x' || ch === 'X') {\n                do {\n                    ch = input[this.cursor++];\n                } while ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||\n                         (ch >= 'A' && ch <= 'F'));\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else if (ch >= '0' && ch <= '7') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '7');\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else {\n                this.cursor--;\n                this.lexExponent();     // 0E1, &c.\n                token.value = 0;\n            }\n        },\n\n        lexNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            var floating = false;\n            do {\n                ch = input[this.cursor++];\n                if (ch === '.' && !floating) {\n                    floating = true;\n                    ch = input[this.cursor++];\n                }\n            } while (ch >= '0' && ch <= '9');\n\n            this.cursor--;\n\n            var exponent = this.lexExponent();\n            floating = floating || exponent;\n\n            var str = input.substring(token.start, this.cursor);\n            token.value = floating ? parseFloat(str) : parseInt(str);\n        },\n\n        lexDot: function (ch) {\n            var token = this.token, input = this.source;\n            var next = input[this.cursor];\n            if (next >= '0' && next <= '9') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n\n                token.type = NUMBER;\n                token.value = parseFloat(token.start, this.cursor);\n            } else {\n                token.type = DOT;\n                token.assignOp = null;\n                token.value = '.';\n            }\n        },\n\n        lexString: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = STRING;\n\n            var hasEscapes = false;\n            var delim = ch;\n            while ((ch = input[this.cursor++]) !== delim) {\n                // [JS2COFFEE] Fixed to make it work on a browser\n                if (this.cursor >= input.length)\n                    throw this.newSyntaxError(\"Unterminated string literal\");\n                if (ch === '\\\\') {\n                    hasEscapes = true;\n                    if (++this.cursor == input.length)\n                        throw this.newSyntaxError(\"Unterminated string literal\");\n                }\n            }\n\n            token.value = hasEscapes\n                          ? eval(input.substring(token.start, this.cursor))\n                          : input.substring(token.start + 1, this.cursor - 1);\n        },\n\n        lexRegExp: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = REGEXP;\n\n            do {\n                ch = input[this.cursor++];\n                if (ch === '\\\\') {\n                    this.cursor++;\n                } else if (ch === '[') {\n                    do {\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated character class\");\n\n                        if (ch === '\\\\')\n                            this.cursor++;\n\n                        ch = input[this.cursor++];\n                    } while (ch !== ']');\n                } else if (ch === undefined) {\n                    throw this.newSyntaxError(\"Unterminated regex\");\n                }\n            } while (ch !== '/');\n\n            do {\n                ch = input[this.cursor++];\n            } while (ch >= 'a' && ch <= 'z');\n\n            this.cursor--;\n\n            token.value = eval(input.substring(token.start, this.cursor));\n        },\n\n        lexOp: function (ch) {\n            var token = this.token, input = this.source;\n\n            // A bit ugly, but it seems wasteful to write a trie lookup routine\n            // for only 3 characters...\n            var node = opTokens[ch];\n            var next = input[this.cursor];\n            if (next in node) {\n                node = node[next];\n                this.cursor++;\n                next = input[this.cursor];\n                if (next in node) {\n                    node = node[next];\n                    this.cursor++;\n                    next = input[this.cursor];\n                }\n            }\n\n            var op = node.op;\n            if (definitions.assignOps[op] && input[this.cursor] === '=') {\n                this.cursor++;\n                token.type = ASSIGN;\n                token.assignOp = definitions.tokenIds[definitions.opTypeNames[op]];\n                op += '=';\n            } else {\n                token.type = definitions.tokenIds[definitions.opTypeNames[op]];\n                token.assignOp = null;\n            }\n\n            token.value = op;\n        },\n\n        // FIXME: Unicode escape sequences\n        // FIXME: Unicode identifiers\n        lexIdent: function (ch) {\n            var token = this.token, input = this.source;\n\n            do {\n                ch = input[this.cursor++];\n            } while ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n                     (ch >= '0' && ch <= '9') || ch === '$' || ch === '_');\n\n            this.cursor--;  // Put the non-word character back.\n\n            var id = input.substring(token.start, this.cursor);\n            token.type = definitions.keywords[id] || IDENTIFIER;\n            token.value = id;\n        },\n\n        /*\n         * Tokenizer.get :: void -> token type\n         *\n         * Consume input *only* if there is no lookahead.\n         * Dispatch to the appropriate lexing function depending on the input.\n         */\n        get: function (scanOperand) {\n            var token;\n            while (this.lookahead) {\n                --this.lookahead;\n                this.tokenIndex = (this.tokenIndex + 1) & 3;\n                token = this.tokens[this.tokenIndex];\n                if (token.type !== NEWLINE || this.scanNewlines)\n                    return token.type;\n            }\n\n            // var comments =\n            this.skip();\n\n            this.tokenIndex = (this.tokenIndex + 1) & 3;\n            token = this.tokens[this.tokenIndex];\n            if (!token)\n                this.tokens[this.tokenIndex] = token = {};\n\n            var input = this.source;\n            if (this.cursor === input.length)\n                return token.type = END;\n\n            token.start = this.cursor;\n            token.lineno = this.lineno;\n\n            var ch = input[this.cursor++];\n            if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '$' || ch === '_') {\n                this.lexIdent(ch);\n            } else if (scanOperand && ch === '/') {\n                this.lexRegExp(ch);\n            } else if (ch in opTokens) {\n                this.lexOp(ch);\n            } else if (ch === '.') {\n                this.lexDot(ch);\n            } else if (ch >= '1' && ch <= '9') {\n                this.lexNumber(ch);\n            } else if (ch === '0') {\n                this.lexZeroNumber(ch);\n            } else if (ch === '\"' || ch === \"'\") {\n                this.lexString(ch);\n            } else if (this.scanNewlines && ch === '\\n') {\n                token.type = NEWLINE;\n                token.value = '\\n';\n                this.lineno++;\n            } else {\n                throw this.newSyntaxError(\"Illegal token\");\n            }\n\n            token.end = this.cursor;\n            // token.comments = [comments,this.skip()];\n            return token.type;\n        },\n\n        /*\n         * Tokenizer.unget :: void -> undefined\n         *\n         * Match depends on unget returning undefined.\n         */\n        unget: function () {\n            if (++this.lookahead === 4) throw \"PANIC: too much lookahead!\";\n            this.tokenIndex = (this.tokenIndex - 1) & 3;\n        },\n\n        newSyntaxError: function (m) {\n            var e = new SyntaxError(m, this.filename, this.lineno);\n            e.source = this.source;\n            e.cursor = this.lookahead\n                       ? this.tokens[(this.tokenIndex + this.lookahead) & 3].start\n                       : this.cursor;\n            return e;\n        },\n    };\n\n    return { Tokenizer: Tokenizer };\n\n}());\n\n/* -*- Mode: JS; tab-width: 4; indent-tabs-mode: nil; -*-\n * vim: set sw=4 ts=4 et tw=78:\n * ***** BEGIN LICENSE BLOCK *****\n *\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Parser.\n */\n\nNarcissus.parser = (function() {\n\n    var lexer = Narcissus.lexer;\n    var definitions = Narcissus.definitions;\n\n    const StringMap = definitions.StringMap;\n    const Stack = definitions.Stack;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    /*\n     * pushDestructuringVarDecls :: (node, hoisting node) -> void\n     *\n     * Recursively add all destructured declarations to varDecls.\n     */\n    function pushDestructuringVarDecls(n, s) {\n        for (var i in n) {\n            var sub = n[i];\n            if (sub.type === IDENTIFIER) {\n                s.varDecls.push(sub);\n            } else {\n                pushDestructuringVarDecls(sub, s);\n            }\n        }\n    }\n\n    // NESTING_TOP: top-level\n    // NESTING_SHALLOW: nested within static forms such as { ... } or labeled statement\n    // NESTING_DEEP: nested within dynamic forms such as if, loops, etc.\n    const NESTING_TOP = 0, NESTING_SHALLOW = 1, NESTING_DEEP = 2;\n\n    function StaticContext(parentScript, parentBlock, inFunction, inForLoopInit, nesting) {\n        this.parentScript = parentScript;\n        this.parentBlock = parentBlock;\n        this.inFunction = inFunction;\n        this.inForLoopInit = inForLoopInit;\n        this.nesting = nesting;\n        this.allLabels = new Stack();\n        this.currentLabels = new Stack();\n        this.labeledTargets = new Stack();\n        this.defaultTarget = null;\n        Narcissus.options.ecma3OnlyMode && (this.ecma3OnlyMode = true);\n        Narcissus.options.parenFreeMode && (this.parenFreeMode = true);\n    }\n\n    StaticContext.prototype = {\n        ecma3OnlyMode: false,\n        parenFreeMode: false,\n        // non-destructive update via prototype extension\n        update: function(ext) {\n            var desc = {};\n            for (var key in ext) {\n                desc[key] = {\n                    value: ext[key],\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                }\n            }\n            return Object.create(this, desc);\n        },\n        pushLabel: function(label) {\n            return this.update({ currentLabels: this.currentLabels.push(label),\n                                 allLabels: this.allLabels.push(label) });\n        },\n        pushTarget: function(target) {\n            var isDefaultTarget = target.isLoop || target.type === SWITCH;\n\n            if (this.currentLabels.isEmpty()) {\n                return isDefaultTarget\n                     ? this.update({ defaultTarget: target })\n                     : this;\n            }\n\n            target.labels = new StringMap();\n            this.currentLabels.forEach(function(label) {\n                target.labels.set(label, true);\n            });\n            return this.update({ currentLabels: new Stack(),\n                                 labeledTargets: this.labeledTargets.push(target),\n                                 defaultTarget: isDefaultTarget\n                                                ? target\n                                                : this.defaultTarget });\n        },\n        nest: function(atLeast) {\n            var nesting = Math.max(this.nesting, atLeast);\n            return (nesting !== this.nesting)\n                 ? this.update({ nesting: nesting })\n                 : this;\n        }\n    };\n\n    /*\n     * Script :: (tokenizer, boolean) -> node\n     *\n     * Parses the toplevel and function bodies.\n     */\n    function Script(t, inFunction) {\n        var n = new Node(t, scriptInit());\n        var x = new StaticContext(n, n, inFunction, false, NESTING_TOP);\n        Statements(t, x, n);\n        return n;\n    }\n\n    // We extend Array slightly with a top-of-stack method.\n    definitions.defineProperty(Array.prototype, \"top\",\n                               function() {\n                                   return this.length && this[this.length-1];\n                               }, false, false, true);\n\n    /*\n     * Node :: (tokenizer, optional init object) -> node\n     */\n    function Node(t, init) {\n        var token = t.token;\n        if (token) {\n            // If init.type exists it will override token.type.\n            this.type = token.type;\n            this.value = token.value;\n            this.lineno = token.lineno;\n\n            // Start and end are file positions for error handling.\n            this.start = token.start;\n            this.end = token.end;\n\n        } else {\n            this.lineno = t.lineno;\n        }\n\n        // Node uses a tokenizer for debugging (getSource, filename getter).\n        this.tokenizer = t;\n        this.children = [];\n\n        for (var prop in init)\n            this[prop] = init[prop];\n    }\n\n    var Np = Node.prototype = {};\n    Np.constructor = Node;\n    Np.toSource = Object.prototype.toSource;\n\n    // Always use push to add operands to an expression, to update start and end.\n    Np.push = function (kid) {\n        // kid can be null e.g. [1, , 2].\n        if (kid !== null) {\n            if (kid.start < this.start)\n                this.start = kid.start;\n            if (this.end < kid.end)\n                this.end = kid.end;\n        }\n        return this.children.push(kid);\n    }\n\n    Node.indentLevel = 0;\n\n    function tokenString(tt) {\n        var t = definitions.tokens[tt];\n        return /^\\W/.test(t) ? definitions.opTypeNames[t] : t.toUpperCase();\n    }\n\n    Np.toString = function () {\n        var a = [];\n        for (var i in this) {\n            if (this.hasOwnProperty(i) && i !== 'type' && i !== 'target')\n                a.push({id: i, value: this[i]});\n        }\n        a.sort(function (a,b) { return (a.id < b.id) ? -1 : 1; });\n        const INDENTATION = \"    \";\n        var n = ++Node.indentLevel;\n        var s = \"{\\n\" + INDENTATION.repeat(n) + \"type: \" + tokenString(this.type);\n        for (i = 0; i < a.length; i++)\n            s += \",\\n\" + INDENTATION.repeat(n) + a[i].id + \": \" + a[i].value;\n        n = --Node.indentLevel;\n        s += \"\\n\" + INDENTATION.repeat(n) + \"}\";\n        return s;\n    }\n\n    Np.getSource = function () {\n        return this.tokenizer.source.slice(this.start, this.end);\n    };\n\n    /*\n     * Helper init objects for common nodes.\n     */\n\n    const LOOP_INIT = { isLoop: true };\n\n    function blockInit() {\n        return { type: BLOCK, varDecls: [] };\n    }\n\n    function scriptInit() {\n        return { type: SCRIPT,\n                 funDecls: [],\n                 varDecls: [],\n                 modDecls: [],\n                 impDecls: [],\n                 expDecls: [],\n                 loadDeps: [],\n                 hasEmptyReturn: false,\n                 hasReturnWithValue: false,\n                 isGenerator: false };\n    }\n\n    definitions.defineGetter(Np, \"filename\",\n                             function() {\n                                 return this.tokenizer.filename;\n                             });\n\n    definitions.defineGetter(Np, \"length\",\n                             function() {\n                                 throw new Error(\"Node.prototype.length is gone; \" +\n                                                 \"use n.children.length instead\");\n                             });\n\n    definitions.defineProperty(String.prototype, \"repeat\",\n                               function(n) {\n                                   var s = \"\", t = this + s;\n                                   while (--n >= 0)\n                                       s += t;\n                                   return s;\n                               }, false, false, true);\n\n    function MaybeLeftParen(t, x) {\n        if (x.parenFreeMode)\n            return t.match(LEFT_PAREN) ? LEFT_PAREN : END;\n        return t.mustMatch(LEFT_PAREN).type;\n    }\n\n    function MaybeRightParen(t, p) {\n        if (p === LEFT_PAREN)\n            t.mustMatch(RIGHT_PAREN);\n    }\n\n    /*\n     * Statements :: (tokenizer, compiler context, node) -> void\n     *\n     * Parses a sequence of Statements.\n     */\n    function Statements(t, x, n) {\n        try {\n            while (!t.done && t.peek(true) !== RIGHT_CURLY)\n            { n.push(Statement(t, x)); }\n        } catch (e) {\n            if (t.done)\n            { t.unexpectedEOF = true; }\n            throw(e);\n        }\n    }\n\n    function Block(t, x) {\n        t.mustMatch(LEFT_CURLY);\n        var n = new Node(t, blockInit());\n        Statements(t, x.update({ parentBlock: n }).pushTarget(n), n);\n        t.mustMatch(RIGHT_CURLY);\n        return n;\n    }\n\n    const DECLARED_FORM = 0, EXPRESSED_FORM = 1, STATEMENT_FORM = 2;\n\n    /*\n     * Statement :: (tokenizer, compiler context) -> node\n     *\n     * Parses a Statement.\n     */\n    function Statement(t, x) {\n        var i, label, n, n2, p, c, ss, tt = t.get(true), tt2, x2, x3;\n\n        // Cases for statements ending in a right curly return early, avoiding the\n        // common semicolon insertion magic after this switch.\n        switch (tt) {\n          case FUNCTION:\n            // DECLARED_FORM extends funDecls of x, STATEMENT_FORM doesn't.\n            return FunctionDefinition(t, x, true,\n                                      (x.nesting !== NESTING_TOP)\n                                      ? STATEMENT_FORM\n                                      : DECLARED_FORM);\n\n          case LEFT_CURLY:\n            n = new Node(t, blockInit());\n            Statements(t, x.update({ parentBlock: n }).pushTarget(n).nest(NESTING_SHALLOW), n);\n            t.mustMatch(RIGHT_CURLY);\n            return n;\n\n          case IF:\n            n = new Node(t);\n            n.condition = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            n.thenPart = Statement(t, x2);\n            n.elsePart = t.match(ELSE) ? Statement(t, x2) : null;\n            return n;\n\n          case SWITCH:\n            // This allows CASEs after a DEFAULT, which is in the standard.\n            n = new Node(t, { cases: [], defaultIndex: -1 });\n            n.discriminant = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            t.mustMatch(LEFT_CURLY);\n            while ((tt = t.get()) !== RIGHT_CURLY) {\n                switch (tt) {\n                  case DEFAULT:\n                    if (n.defaultIndex >= 0)\n                        throw t.newSyntaxError(\"More than one switch default\");\n                    // FALL THROUGH\n                  case CASE:\n                    n2 = new Node(t);\n                    if (tt === DEFAULT)\n                        n.defaultIndex = n.cases.length;\n                    else\n                        n2.caseLabel = Expression(t, x2, COLON);\n                    break;\n\n                  default:\n                    throw t.newSyntaxError(\"Invalid switch case\");\n                }\n                t.mustMatch(COLON);\n                n2.statements = new Node(t, blockInit());\n                while ((tt=t.peek(true)) !== CASE && tt !== DEFAULT &&\n                        tt !== RIGHT_CURLY)\n                    n2.statements.push(Statement(t, x2));\n                n.cases.push(n2);\n            }\n            return n;\n\n          case FOR:\n            n = new Node(t, LOOP_INIT);\n            if (t.match(IDENTIFIER)) {\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(LEFT_PAREN);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            x3 = x.update({ inForLoopInit: true });\n            if ((tt = t.peek()) !== SEMICOLON) {\n                if (tt === VAR || tt === CONST) {\n                    t.get();\n                    n2 = Variables(t, x3);\n                } else if (tt === LET) {\n                    t.get();\n                    if (t.peek() === LEFT_PAREN) {\n                        n2 = LetBlock(t, x3, false);\n                    } else {\n                        // Let in for head, we need to add an implicit block\n                        // around the rest of the for.\n                        x3.parentBlock = n;\n                        n.varDecls = [];\n                        n2 = Variables(t, x3);\n                    }\n                } else {\n                    n2 = Expression(t, x3);\n                }\n            }\n            if (n2 && t.match(IN)) {\n                n.type = FOR_IN;\n                n.object = Expression(t, x3);\n                if (n2.type === VAR || n2.type === LET) {\n                    c = n2.children;\n\n                    // Destructuring turns one decl into multiples, so either\n                    // there must be only one destructuring or only one\n                    // decl.\n                    if (c.length !== 1 && n2.destructurings.length !== 1) {\n                        throw new SyntaxError(\"Invalid for..in left-hand side\",\n                                              t.filename, n2.lineno);\n                    }\n                    if (n2.destructurings.length > 0) {\n                        n.iterator = n2.destructurings[0];\n                    } else {\n                        n.iterator = c[0];\n                    }\n                    n.varDecl = n2;\n                } else {\n                    if (n2.type === ARRAY_INIT || n2.type === OBJECT_INIT) {\n                        n2.destructuredNames = checkDestructuring(t, x3, n2);\n                    }\n                    n.iterator = n2;\n                }\n            } else {\n                n.setup = n2;\n                t.mustMatch(SEMICOLON);\n                if (n.isEach)\n                    throw t.newSyntaxError(\"Invalid for each..in loop\");\n                n.condition = (t.peek() === SEMICOLON)\n                              ? null\n                              : Expression(t, x3);\n                t.mustMatch(SEMICOLON);\n                tt2 = t.peek();\n                n.update = (x.parenFreeMode\n                            ? tt2 === LEFT_CURLY || definitions.isStatementStartCode[tt2]\n                            : tt2 === RIGHT_PAREN)\n                           ? null\n                           : Expression(t, x3);\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(RIGHT_PAREN);\n            n.body = Statement(t, x2);\n            return n;\n\n          case WHILE:\n            n = new Node(t, { isLoop: true });\n            n.condition = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case DO:\n            n = new Node(t, { isLoop: true });\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            t.mustMatch(WHILE);\n            n.condition = HeadExpression(t, x);\n            if (!x.ecmaStrictMode) {\n                // <script language=\"JavaScript\"> (without version hints) may need\n                // automatic semicolon insertion without a newline after do-while.\n                // See http://bugzilla.mozilla.org/show_bug.cgi?id=238945.\n                t.match(SEMICOLON);\n                return n;\n            }\n            break;\n\n          case BREAK:\n          case CONTINUE:\n            n = new Node(t);\n\n            // handle the |foo: break foo;| corner case\n            x2 = x.pushTarget(n);\n\n            if (t.peekOnSameLine() === IDENTIFIER) {\n                t.get();\n                n.label = t.token.value;\n            }\n\n            n.target = n.label\n                     ? x2.labeledTargets.find(function(target) { return target.labels.has(n.label) })\n                     : x2.defaultTarget;\n\n            if (!n.target)\n                throw t.newSyntaxError(\"Invalid \" + ((tt === BREAK) ? \"break\" : \"continue\"));\n            if (!n.target.isLoop && tt === CONTINUE)\n                throw t.newSyntaxError(\"Invalid continue\");\n\n            break;\n\n          case TRY:\n            n = new Node(t, { catchClauses: [] });\n            n.tryBlock = Block(t, x);\n            while (t.match(CATCH)) {\n                n2 = new Node(t);\n                p = MaybeLeftParen(t, x);\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured catch identifiers.\n                    t.unget();\n                    n2.varName = DestructuringExpression(t, x, true);\n                    break;\n                  case IDENTIFIER:\n                    n2.varName = t.token.value;\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing identifier in catch\");\n                    break;\n                }\n                if (t.match(IF)) {\n                    if (x.ecma3OnlyMode)\n                        throw t.newSyntaxError(\"Illegal catch guard\");\n                    if (n.catchClauses.length && !n.catchClauses.top().guard)\n                        throw t.newSyntaxError(\"Guarded catch after unguarded\");\n                    n2.guard = Expression(t, x);\n                }\n                MaybeRightParen(t, p);\n                n2.block = Block(t, x);\n                n.catchClauses.push(n2);\n            }\n            if (t.match(FINALLY))\n                n.finallyBlock = Block(t, x);\n            if (!n.catchClauses.length && !n.finallyBlock)\n                throw t.newSyntaxError(\"Invalid try statement\");\n            return n;\n\n          case CATCH:\n          case FINALLY:\n            throw t.newSyntaxError(definitions.tokens[tt] + \" without preceding try\");\n\n          case THROW:\n            n = new Node(t);\n            n.exception = Expression(t, x);\n            break;\n\n          case RETURN:\n            n = ReturnOrYield(t, x);\n            break;\n\n          case WITH:\n            n = new Node(t);\n            n.object = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case VAR:\n          case CONST:\n            n = Variables(t, x);\n            break;\n\n          case LET:\n            if (t.peek() === LEFT_PAREN)\n                n = LetBlock(t, x, true);\n            else\n                n = Variables(t, x);\n            break;\n\n          case DEBUGGER:\n            n = new Node(t);\n            break;\n\n          case NEWLINE:\n          case SEMICOLON:\n            n = new Node(t, { type: SEMICOLON });\n            n.expression = null;\n            return n;\n\n          default:\n            if (tt === IDENTIFIER) {\n                tt = t.peek();\n                // Labeled statement.\n                if (tt === COLON) {\n                    label = t.token.value;\n                    if (x.allLabels.has(label))\n                        throw t.newSyntaxError(\"Duplicate label\");\n                    t.get();\n                    n = new Node(t, { type: LABEL, label: label });\n                    n.statement = Statement(t, x.pushLabel(label).nest(NESTING_SHALLOW));\n                    n.target = (n.statement.type === LABEL) ? n.statement.target : n.statement;\n                    return n;\n                }\n            }\n\n            // Expression statement.\n            // We unget the current token to parse the expression as a whole.\n            n = new Node(t, { type: SEMICOLON });\n            t.unget();\n            n.expression = Expression(t, x);\n            n.end = n.expression.end;\n            break;\n        }\n\n        MagicalSemicolon(t);\n        return n;\n    }\n\n    function MagicalSemicolon(t) {\n        var tt;\n        if (t.lineno === t.token.lineno) {\n            tt = t.peekOnSameLine();\n            if (tt !== END && tt !== NEWLINE && tt !== SEMICOLON && tt !== RIGHT_CURLY)\n                throw t.newSyntaxError(\"missing ; before statement\");\n        }\n        t.match(SEMICOLON);\n    }\n\n    function ReturnOrYield(t, x) {\n        var n, b, tt = t.token.type, tt2;\n\n        var parentScript = x.parentScript;\n\n        if (tt === RETURN) {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Return not in function\");\n        } else /* if (tt === YIELD) */ {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Yield not in function\");\n            parentScript.isGenerator = true;\n        }\n        n = new Node(t, { value: undefined });\n\n        tt2 = t.peek(true);\n        if (tt2 !== END && tt2 !== NEWLINE &&\n            tt2 !== SEMICOLON && tt2 !== RIGHT_CURLY\n            && (tt !== YIELD ||\n                (tt2 !== tt && tt2 !== RIGHT_BRACKET && tt2 !== RIGHT_PAREN &&\n                 tt2 !== COLON && tt2 !== COMMA))) {\n            if (tt === RETURN) {\n                n.value = Expression(t, x);\n                parentScript.hasReturnWithValue = true;\n            } else {\n                n.value = AssignExpression(t, x);\n            }\n        } else if (tt === RETURN) {\n            parentScript.hasEmptyReturn = true;\n        }\n\n        // Disallow return v; in generator.\n        if (parentScript.hasReturnWithValue && parentScript.isGenerator)\n            throw t.newSyntaxError(\"Generator returns a value\");\n\n        return n;\n    }\n\n    /*\n     * FunctionDefinition :: (tokenizer, compiler context, boolean,\n     *                        DECLARED_FORM or EXPRESSED_FORM or STATEMENT_FORM)\n     *                    -> node\n     */\n    function FunctionDefinition(t, x, requireName, functionForm) {\n        var tt;\n        var f = new Node(t, { params: [] });\n        if (f.type !== FUNCTION)\n            f.type = (f.value === \"get\") ? GETTER : SETTER;\n        if (t.match(IDENTIFIER))\n            f.name = t.token.value;\n        else if (requireName)\n            throw t.newSyntaxError(\"missing function identifier\");\n\n        var x2 = new StaticContext(null, null, true, false, NESTING_TOP);\n\n        t.mustMatch(LEFT_PAREN);\n        if (!t.match(RIGHT_PAREN)) {\n            do {\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured formal parameters.\n                    t.unget();\n                    f.params.push(DestructuringExpression(t, x2));\n                    break;\n                  case IDENTIFIER:\n                    f.params.push(t.token.value);\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing formal parameter\");\n                    break;\n                }\n            } while (t.match(COMMA));\n            t.mustMatch(RIGHT_PAREN);\n        }\n\n        // Do we have an expression closure or a normal body?\n        tt = t.get();\n        if (tt !== LEFT_CURLY)\n            t.unget();\n\n        if (tt !== LEFT_CURLY) {\n            f.body = AssignExpression(t, x2);\n            if (f.body.isGenerator)\n                throw t.newSyntaxError(\"Generator returns a value\");\n        } else {\n            f.body = Script(t, true);\n        }\n\n        if (tt === LEFT_CURLY)\n            t.mustMatch(RIGHT_CURLY);\n\n        f.end = t.token.end;\n        f.functionForm = functionForm;\n        if (functionForm === DECLARED_FORM)\n            x.parentScript.funDecls.push(f);\n        return f;\n    }\n\n    /*\n     * Variables :: (tokenizer, compiler context) -> node\n     *\n     * Parses a comma-separated list of var declarations (and maybe\n     * initializations).\n     */\n    function Variables(t, x, letBlock) {\n        var n, n2, ss, i, s, tt;\n\n        tt = t.token.type;\n        switch (tt) {\n          case VAR:\n          case CONST:\n            s = x.parentScript;\n            break;\n          case LET:\n            s = x.parentBlock;\n            break;\n          case LEFT_PAREN:\n            tt = LET;\n            s = letBlock;\n            break;\n        }\n\n        n = new Node(t, { type: tt, destructurings: [] });\n\n        do {\n            tt = t.get();\n            if (tt === LEFT_BRACKET || tt === LEFT_CURLY) {\n                // Need to unget to parse the full destructured expression.\n                t.unget();\n\n                var dexp = DestructuringExpression(t, x, true);\n\n                n2 = new Node(t, { type: IDENTIFIER,\n                                   name: dexp,\n                                   readOnly: n.type === CONST });\n                n.push(n2);\n                pushDestructuringVarDecls(n2.name.destructuredNames, s);\n                n.destructurings.push({ exp: dexp, decl: n2 });\n\n                if (x.inForLoopInit && t.peek() === IN) {\n                    continue;\n                }\n\n                t.mustMatch(ASSIGN);\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n\n                continue;\n            }\n\n            if (tt !== IDENTIFIER)\n                throw t.newSyntaxError(\"missing variable name\");\n\n            n2 = new Node(t, { type: IDENTIFIER,\n                               name: t.token.value,\n                               readOnly: n.type === CONST });\n            n.push(n2);\n            s.varDecls.push(n2);\n\n            if (t.match(ASSIGN)) {\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n            }\n        } while (t.match(COMMA));\n\n        return n;\n    }\n\n    /*\n     * LetBlock :: (tokenizer, compiler context, boolean) -> node\n     *\n     * Does not handle let inside of for loop init.\n     */\n    function LetBlock(t, x, isStatement) {\n        var n, n2;\n\n        // t.token.type must be LET\n        n = new Node(t, { type: LET_BLOCK, varDecls: [] });\n        t.mustMatch(LEFT_PAREN);\n        n.variables = Variables(t, x, n);\n        t.mustMatch(RIGHT_PAREN);\n\n        if (isStatement && t.peek() !== LEFT_CURLY) {\n            /*\n             * If this is really an expression in let statement guise, then we\n             * need to wrap the LET_BLOCK node in a SEMICOLON node so that we pop\n             * the return value of the expression.\n             */\n            n2 = new Node(t, { type: SEMICOLON,\n                               expression: n });\n            isStatement = false;\n        }\n\n        if (isStatement)\n            n.block = Block(t, x);\n        else\n            n.expression = AssignExpression(t, x);\n\n        return n;\n    }\n\n    function checkDestructuring(t, x, n, simpleNamesOnly) {\n        if (n.type === ARRAY_COMP)\n            throw t.newSyntaxError(\"Invalid array comprehension left-hand side\");\n        if (n.type !== ARRAY_INIT && n.type !== OBJECT_INIT)\n            return;\n\n        var lhss = {};\n        var nn, n2, idx, sub, cc, c = n.children;\n        for (var i = 0, j = c.length; i < j; i++) {\n            if (!(nn = c[i]))\n                continue;\n            if (nn.type === PROPERTY_INIT) {\n                cc = nn.children;\n                sub = cc[1];\n                idx = cc[0].value;\n            } else if (n.type === OBJECT_INIT) {\n                // Do we have destructuring shorthand {foo, bar}?\n                sub = nn;\n                idx = nn.value;\n            } else {\n                sub = nn;\n                idx = i;\n            }\n\n            if (sub.type === ARRAY_INIT || sub.type === OBJECT_INIT) {\n                lhss[idx] = checkDestructuring(t, x, sub, simpleNamesOnly);\n            } else {\n                if (simpleNamesOnly && sub.type !== IDENTIFIER) {\n                    // In declarations, lhs must be simple names\n                    throw t.newSyntaxError(\"missing name in pattern\");\n                }\n\n                lhss[idx] = sub;\n            }\n        }\n\n        return lhss;\n    }\n\n    function DestructuringExpression(t, x, simpleNamesOnly) {\n        var n = PrimaryExpression(t, x);\n        // Keep the list of lefthand sides for varDecls\n        n.destructuredNames = checkDestructuring(t, x, n, simpleNamesOnly);\n        return n;\n    }\n\n    function GeneratorExpression(t, x, e) {\n        return new Node(t, { type: GENERATOR,\n                             expression: e,\n                             tail: ComprehensionTail(t, x) });\n    }\n\n    function ComprehensionTail(t, x) {\n        var body, n, n2, n3, p;\n\n        // t.token.type must be FOR\n        body = new Node(t, { type: COMP_TAIL });\n\n        do {\n            // Comprehension tails are always for..in loops.\n            n = new Node(t, { type: FOR_IN, isLoop: true });\n            if (t.match(IDENTIFIER)) {\n                // But sometimes they're for each..in.\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            p = MaybeLeftParen(t, x);\n            switch(t.get()) {\n              case LEFT_BRACKET:\n              case LEFT_CURLY:\n                t.unget();\n                // Destructured left side of for in comprehension tails.\n                n.iterator = DestructuringExpression(t, x);\n                break;\n\n              case IDENTIFIER:\n                n.iterator = n3 = new Node(t, { type: IDENTIFIER });\n                n3.name = n3.value;\n                n.varDecl = n2 = new Node(t, { type: VAR });\n                n2.push(n3);\n                x.parentScript.varDecls.push(n3);\n                // Don't add to varDecls since the semantics of comprehensions is\n                // such that the variables are in their own function when\n                // desugared.\n                break;\n\n              default:\n                throw t.newSyntaxError(\"missing identifier\");\n            }\n            t.mustMatch(IN);\n            n.object = Expression(t, x);\n            MaybeRightParen(t, p);\n            body.push(n);\n        } while (t.match(FOR));\n\n        // Optional guard.\n        if (t.match(IF))\n            body.guard = HeadExpression(t, x);\n\n        return body;\n    }\n\n    function HeadExpression(t, x) {\n        var p = MaybeLeftParen(t, x);\n        var n = ParenExpression(t, x);\n        MaybeRightParen(t, p);\n        if (p === END && !n.parenthesized) {\n            var tt = t.peek();\n            if (tt !== LEFT_CURLY && !definitions.isStatementStartCode[tt])\n                throw t.newSyntaxError(\"Unparenthesized head followed by unbraced body\");\n        }\n        return n;\n    }\n\n    function ParenExpression(t, x) {\n        // Always accept the 'in' operator in a parenthesized expression,\n        // where it's unambiguous, even if we might be parsing the init of a\n        // for statement.\n        var n = Expression(t, x.update({ inForLoopInit: x.inForLoopInit &&\n                                                        (t.token.type === LEFT_PAREN) }));\n\n        if (t.match(FOR)) {\n            if (n.type === YIELD && !n.parenthesized)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (n.type === COMMA && !n.parenthesized)\n                throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            n = GeneratorExpression(t, x, n);\n        }\n\n        return n;\n    }\n\n    /*\n     * Expression :: (tokenizer, compiler context) -> node\n     *\n     * Top-down expression parser matched against SpiderMonkey.\n     */\n    function Expression(t, x) {\n        var n, n2;\n\n        n = AssignExpression(t, x);\n        if (t.match(COMMA)) {\n            n2 = new Node(t, { type: COMMA });\n            n2.push(n);\n            n = n2;\n            do {\n                n2 = n.children[n.children.length-1];\n                if (n2.type === YIELD && !n2.parenthesized)\n                    throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n                n.push(AssignExpression(t, x));\n            } while (t.match(COMMA));\n        }\n\n        return n;\n    }\n\n    function AssignExpression(t, x) {\n        var n, lhs;\n\n        // Have to treat yield like an operand because it could be the leftmost\n        // operand of the expression.\n        if (t.match(YIELD, true))\n            return ReturnOrYield(t, x);\n\n        n = new Node(t, { type: ASSIGN });\n        lhs = ConditionalExpression(t, x);\n\n        if (!t.match(ASSIGN)) {\n            return lhs;\n        }\n\n        switch (lhs.type) {\n          case OBJECT_INIT:\n          case ARRAY_INIT:\n            lhs.destructuredNames = checkDestructuring(t, x, lhs);\n            // FALL THROUGH\n          case IDENTIFIER: case DOT: case INDEX: case CALL:\n            break;\n          default:\n            throw t.newSyntaxError(\"Bad left-hand side of assignment\");\n            break;\n        }\n\n        n.assignOp = t.token.assignOp;\n        n.push(lhs);\n        n.push(AssignExpression(t, x));\n\n        return n;\n    }\n\n    function ConditionalExpression(t, x) {\n        var n, n2;\n\n        n = OrExpression(t, x);\n        if (t.match(HOOK)) {\n            n2 = n;\n            n = new Node(t, { type: HOOK });\n            n.push(n2);\n            /*\n             * Always accept the 'in' operator in the middle clause of a ternary,\n             * where it's unambiguous, even if we might be parsing the init of a\n             * for statement.\n             */\n            n.push(AssignExpression(t, x.update({ inForLoopInit: false })));\n            if (!t.match(COLON))\n                throw t.newSyntaxError(\"missing : after ?\");\n            n.push(AssignExpression(t, x));\n        }\n\n        return n;\n    }\n\n    function OrExpression(t, x) {\n        var n, n2;\n\n        n = AndExpression(t, x);\n        while (t.match(OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AndExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseOrExpression(t, x);\n        while (t.match(AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseOrExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseOrExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseXorExpression(t, x);\n        while (t.match(BITWISE_OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseXorExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseXorExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseAndExpression(t, x);\n        while (t.match(BITWISE_XOR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseAndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseAndExpression(t, x) {\n        var n, n2;\n\n        n = EqualityExpression(t, x);\n        while (t.match(BITWISE_AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(EqualityExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function EqualityExpression(t, x) {\n        var n, n2;\n\n        n = RelationalExpression(t, x);\n        while (t.match(EQ) || t.match(NE) ||\n               t.match(STRICT_EQ) || t.match(STRICT_NE)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(RelationalExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function RelationalExpression(t, x) {\n        var n, n2;\n\n        /*\n         * Uses of the in operator in shiftExprs are always unambiguous,\n         * so unset the flag that prohibits recognizing it.\n         */\n        var x2 = x.update({ inForLoopInit: false });\n        n = ShiftExpression(t, x2);\n        while ((t.match(LT) || t.match(LE) || t.match(GE) || t.match(GT) ||\n               (!x.inForLoopInit && t.match(IN)) ||\n               t.match(INSTANCEOF))) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(ShiftExpression(t, x2));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ShiftExpression(t, x) {\n        var n, n2;\n\n        n = AddExpression(t, x);\n        while (t.match(LSH) || t.match(RSH) || t.match(URSH)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AddExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AddExpression(t, x) {\n        var n, n2;\n\n        n = MultiplyExpression(t, x);\n        while (t.match(PLUS) || t.match(MINUS)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(MultiplyExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function MultiplyExpression(t, x) {\n        var n, n2;\n\n        n = UnaryExpression(t, x);\n        while (t.match(MUL) || t.match(DIV) || t.match(MOD)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(UnaryExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function UnaryExpression(t, x) {\n        var n, n2, tt;\n\n        switch (tt = t.get(true)) {\n          case DELETE: case VOID: case TYPEOF:\n          case NOT: case BITWISE_NOT: case PLUS: case MINUS:\n            if (tt === PLUS)\n                n = new Node(t, { type: UNARY_PLUS });\n            else if (tt === MINUS)\n                n = new Node(t, { type: UNARY_MINUS });\n            else\n                n = new Node(t);\n            n.push(UnaryExpression(t, x));\n            break;\n\n          case INCREMENT:\n          case DECREMENT:\n            // Prefix increment/decrement.\n            n = new Node(t);\n            n.push(MemberExpression(t, x, true));\n            break;\n\n          default:\n            t.unget();\n            n = MemberExpression(t, x, true);\n\n            // Don't look across a newline boundary for a postfix {in,de}crement.\n            if (t.tokens[(t.tokenIndex + t.lookahead - 1) & 3].lineno ===\n                t.lineno) {\n                if (t.match(INCREMENT) || t.match(DECREMENT)) {\n                    n2 = new Node(t, { postfix: true });\n                    n2.push(n);\n                    n = n2;\n                }\n            }\n            break;\n        }\n\n        return n;\n    }\n\n    function MemberExpression(t, x, allowCallSyntax) {\n        var n, n2, name, tt;\n\n        if (t.match(NEW)) {\n            n = new Node(t);\n            n.push(MemberExpression(t, x, false));\n            if (t.match(LEFT_PAREN)) {\n                n.type = NEW_WITH_ARGS;\n                n.push(ArgumentList(t, x));\n            }\n        } else {\n            n = PrimaryExpression(t, x);\n        }\n\n        while ((tt = t.get()) !== END) {\n            switch (tt) {\n              case DOT:\n                n2 = new Node(t);\n                n2.push(n);\n                t.mustMatch(IDENTIFIER);\n                n2.push(new Node(t));\n                break;\n\n              case LEFT_BRACKET:\n                n2 = new Node(t, { type: INDEX });\n                n2.push(n);\n                n2.push(Expression(t, x));\n                t.mustMatch(RIGHT_BRACKET);\n                break;\n\n              case LEFT_PAREN:\n                if (allowCallSyntax) {\n                    n2 = new Node(t, { type: CALL });\n                    n2.push(n);\n                    n2.push(ArgumentList(t, x));\n                    break;\n                }\n\n                // FALL THROUGH\n              default:\n                t.unget();\n                return n;\n            }\n\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ArgumentList(t, x) {\n        var n, n2;\n\n        n = new Node(t, { type: LIST });\n        if (t.match(RIGHT_PAREN, true))\n            return n;\n        do {\n            n2 = AssignExpression(t, x);\n            if (n2.type === YIELD && !n2.parenthesized && t.peek() === COMMA)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (t.match(FOR)) {\n                n2 = GeneratorExpression(t, x, n2);\n                if (n.children.length > 1 || t.peek(true) === COMMA)\n                    throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            }\n            n.push(n2);\n        } while (t.match(COMMA));\n        t.mustMatch(RIGHT_PAREN);\n\n        return n;\n    }\n\n    function PrimaryExpression(t, x) {\n        var n, n2, tt = t.get(true);\n\n        switch (tt) {\n          case FUNCTION:\n            n = FunctionDefinition(t, x, false, EXPRESSED_FORM);\n            break;\n\n          case LEFT_BRACKET:\n            n = new Node(t, { type: ARRAY_INIT });\n            while ((tt = t.peek(true)) !== RIGHT_BRACKET) {\n                if (tt === COMMA) {\n                    t.get();\n                    n.push(null);\n                    continue;\n                }\n                n.push(AssignExpression(t, x));\n                if (tt !== COMMA && !t.match(COMMA))\n                    break;\n            }\n\n            // If we matched exactly one element and got a FOR, we have an\n            // array comprehension.\n            if (n.children.length === 1 && t.match(FOR)) {\n                n2 = new Node(t, { type: ARRAY_COMP,\n                                   expression: n.children[0],\n                                   tail: ComprehensionTail(t, x) });\n                n = n2;\n            }\n            t.mustMatch(RIGHT_BRACKET);\n            break;\n\n          case LEFT_CURLY:\n            var id, fd;\n            n = new Node(t, { type: OBJECT_INIT });\n\n          object_init:\n            if (!t.match(RIGHT_CURLY)) {\n                do {\n                    tt = t.get();\n                    if ((t.token.value === \"get\" || t.token.value === \"set\") &&\n                        t.peek() === IDENTIFIER) {\n                        if (x.ecma3OnlyMode)\n                            throw t.newSyntaxError(\"Illegal property accessor\");\n                        n.push(FunctionDefinition(t, x, true, EXPRESSED_FORM));\n                    } else {\n                        switch (tt) {\n                          case IDENTIFIER: case NUMBER: case STRING:\n                            id = new Node(t, { type: IDENTIFIER });\n                            break;\n                          case RIGHT_CURLY:\n                            if (x.ecma3OnlyMode)\n                                throw t.newSyntaxError(\"Illegal trailing ,\");\n                            break object_init;\n                          default:\n                            if (t.token.value in definitions.keywords) {\n                                id = new Node(t, { type: IDENTIFIER });\n                                break;\n                            }\n                            throw t.newSyntaxError(\"Invalid property name\");\n                        }\n                        if (t.match(COLON)) {\n                            n2 = new Node(t, { type: PROPERTY_INIT });\n                            n2.push(id);\n                            n2.push(AssignExpression(t, x));\n                            n.push(n2);\n                        } else {\n                            // Support, e.g., |var {x, y} = o| as destructuring shorthand\n                            // for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.\n                            if (t.peek() !== COMMA && t.peek() !== RIGHT_CURLY)\n                                throw t.newSyntaxError(\"missing : after property\");\n                            n.push(id);\n                        }\n                    }\n                } while (t.match(COMMA));\n                t.mustMatch(RIGHT_CURLY);\n            }\n            break;\n\n          case LEFT_PAREN:\n            n = ParenExpression(t, x);\n            t.mustMatch(RIGHT_PAREN);\n            n.parenthesized = true;\n            break;\n\n          case LET:\n            n = LetBlock(t, x, false);\n            break;\n\n          case NULL: case THIS: case TRUE: case FALSE:\n          case IDENTIFIER: case NUMBER: case STRING: case REGEXP:\n            n = new Node(t);\n            break;\n\n          default:\n            throw t.newSyntaxError(\"missing operand\");\n            break;\n        }\n\n        return n;\n    }\n\n    /*\n     * parse :: (source, filename, line number) -> node\n     */\n    function parse(s, f, l) {\n        var t = new lexer.Tokenizer(s, f, l);\n        var n = Script(t, false);\n        if (!t.done)\n            throw t.newSyntaxError(\"Syntax error\");\n\n        return n;\n    }\n\n    /*\n     * parseStdin :: (source, {line number}) -> node\n     */\n    function parseStdin(s, ln) {\n        for (;;) {\n            try {\n                var t = new lexer.Tokenizer(s, \"stdin\", ln.value);\n                var n = Script(t, false);\n                ln.value = t.lineno;\n                return n;\n            } catch (e) {\n                if (!t.unexpectedEOF)\n                    throw e;\n                var more = readline();\n                if (!more)\n                    throw e;\n                s += \"\\n\" + more;\n            }\n        }\n    }\n\n    return {\n        parse: parse,\n        parseStdin: parseStdin,\n        Node: Node,\n        DECLARED_FORM: DECLARED_FORM,\n        EXPRESSED_FORM: EXPRESSED_FORM,\n        STATEMENT_FORM: STATEMENT_FORM,\n        Tokenizer: lexer.Tokenizer,\n        FunctionDefinition: FunctionDefinition\n    };\n\n}());\n\nvar exports = {\n  definitions: Narcissus.definitions,\n  lexer: Narcissus.lexer,\n  parser: Narcissus.parser\n};\n\nif (typeof module != 'undefined') {\n  module.exports = exports;\n};\n\n",
      "contentRenderedWithoutLayouts": "/* vim: set sw=4 ts=4 et tw=78: */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\nif (typeof module == 'undefined') {\n  this.Narcissus = new Object;\n}\n\nvar Narcissus = {\n    options: {\n        version: 185,\n    },\n    hostGlobal: this\n};\n\nNarcissus.definitions = (function() {\n\n    var tokens = [\n        // End of source.\n        \"END\",\n\n        // Operators and punctuators.  Some pair-wise order matters, e.g. (+, -)\n        // and (UNARY_PLUS, UNARY_MINUS).\n        \"\\n\", \";\",\n        \",\",\n        \"=\",\n        \"?\", \":\", \"CONDITIONAL\",\n        \"||\",\n        \"&&\",\n        \"|\",\n        \"^\",\n        \"&\",\n        \"==\", \"!=\", \"===\", \"!==\",\n        \"<\", \"<=\", \">=\", \">\",\n        \"<<\", \">>\", \">>>\",\n        \"+\", \"-\",\n        \"*\", \"/\", \"%\",\n        \"!\", \"~\", \"UNARY_PLUS\", \"UNARY_MINUS\",\n        \"++\", \"--\",\n        \".\",\n        \"[\", \"]\",\n        \"{\", \"}\",\n        \"(\", \")\",\n\n        // Nonterminal tree node type codes.\n        \"SCRIPT\", \"BLOCK\", \"LABEL\", \"FOR_IN\", \"CALL\", \"NEW_WITH_ARGS\", \"INDEX\",\n        \"ARRAY_INIT\", \"OBJECT_INIT\", \"PROPERTY_INIT\", \"GETTER\", \"SETTER\",\n        \"GROUP\", \"LIST\", \"LET_BLOCK\", \"ARRAY_COMP\", \"GENERATOR\", \"COMP_TAIL\",\n\n        // Terminals.\n        \"IDENTIFIER\", \"NUMBER\", \"STRING\", \"REGEXP\",\n\n        // Keywords.\n        \"break\",\n        \"case\", \"catch\", \"const\", \"continue\",\n        \"debugger\", \"default\", \"delete\", \"do\",\n        \"else\",\n        \"false\", \"finally\", \"for\", \"function\",\n        \"if\", \"in\", \"instanceof\",\n        \"let\",\n        \"new\", \"null\",\n        \"return\",\n        \"switch\",\n        \"this\", \"throw\", \"true\", \"try\", \"typeof\",\n        \"var\", \"void\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    var statementStartTokens = [\n        \"break\",\n        \"const\", \"continue\",\n        \"debugger\", \"do\",\n        \"for\",\n        \"if\",\n        \"return\",\n        \"switch\",\n        \"throw\", \"try\",\n        \"var\",\n        \"yield\",\n        \"while\", \"with\",\n    ];\n\n    // Operator and punctuator mapping from token to tree node type name.\n    // NB: because the lexer doesn't backtrack, all token prefixes must themselves\n    // be valid tokens (e.g. !== is acceptable because its prefixes are the valid\n    // tokens != and !).\n    var opTypeNames = {\n        '\\n':   \"NEWLINE\",\n        ';':    \"SEMICOLON\",\n        ',':    \"COMMA\",\n        '?':    \"HOOK\",\n        ':':    \"COLON\",\n        '||':   \"OR\",\n        '&&':   \"AND\",\n        '|':    \"BITWISE_OR\",\n        '^':    \"BITWISE_XOR\",\n        '&':    \"BITWISE_AND\",\n        '===':  \"STRICT_EQ\",\n        '==':   \"EQ\",\n        '=':    \"ASSIGN\",\n        '!==':  \"STRICT_NE\",\n        '!=':   \"NE\",\n        '<<':   \"LSH\",\n        '<=':   \"LE\",\n        '<':    \"LT\",\n        '>>>':  \"URSH\",\n        '>>':   \"RSH\",\n        '>=':   \"GE\",\n        '>':    \"GT\",\n        '++':   \"INCREMENT\",\n        '--':   \"DECREMENT\",\n        '+':    \"PLUS\",\n        '-':    \"MINUS\",\n        '*':    \"MUL\",\n        '/':    \"DIV\",\n        '%':    \"MOD\",\n        '!':    \"NOT\",\n        '~':    \"BITWISE_NOT\",\n        '.':    \"DOT\",\n        '[':    \"LEFT_BRACKET\",\n        ']':    \"RIGHT_BRACKET\",\n        '{':    \"LEFT_CURLY\",\n        '}':    \"RIGHT_CURLY\",\n        '(':    \"LEFT_PAREN\",\n        ')':    \"RIGHT_PAREN\"\n    };\n\n    // Hash of keyword identifier to tokens index.  NB: we must null __proto__ to\n    // avoid toString, etc. namespace pollution.\n    var keywords = {__proto__: null};\n\n    // Define const END, etc., based on the token names.  Also map name to index.\n    var tokenIds = {};\n\n    // Building up a string to be eval'd in different contexts.\n    var consts = \"const \";\n    for (var i = 0, j = tokens.length; i < j; i++) {\n        if (i > 0)\n            consts += \", \";\n        var t = tokens[i];\n        var name;\n        if (/^[a-z]/.test(t)) {\n            name = t.toUpperCase();\n            keywords[t] = i;\n        } else {\n            name = (/^\\W/.test(t) ? opTypeNames[t] : t);\n        }\n        consts += name + \" = \" + i;\n        tokenIds[name] = i;\n        tokens[t] = i;\n    }\n    consts += \";\";\n\n    var isStatementStartCode = {__proto__: null};\n    for (i = 0, j = statementStartTokens.length; i < j; i++)\n        isStatementStartCode[keywords[statementStartTokens[i]]] = true;\n\n    // Map assignment operators to their indexes in the tokens array.\n    var assignOps = ['|', '^', '&', '<<', '>>', '>>>', '+', '-', '*', '/', '%'];\n\n    for (i = 0, j = assignOps.length; i < j; i++) {\n        t = assignOps[i];\n        assignOps[t] = tokens[t];\n    }\n\n    function defineGetter(obj, prop, fn, dontDelete, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { get: fn, configurable: !dontDelete, enumerable: !dontEnum });\n    }\n\n    function defineProperty(obj, prop, val, dontDelete, readOnly, dontEnum) {\n        Object.defineProperty(obj, prop,\n                              { value: val, writable: !readOnly, configurable: !dontDelete,\n                                enumerable: !dontEnum });\n    }\n\n    // Returns true if fn is a native function.  (Note: SpiderMonkey specific.)\n    function isNativeCode(fn) {\n        // Relies on the toString method to identify native code.\n        return ((typeof fn) === \"function\") && fn.toString().match(/\\[native code\\]/);\n    }\n\n    function getPropertyDescriptor(obj, name) {\n        while (obj) {\n            if (({}).hasOwnProperty.call(obj, name))\n                return Object.getOwnPropertyDescriptor(obj, name);\n            obj = Object.getPrototypeOf(obj);\n        }\n    }\n\n    function getOwnProperties(obj) {\n        var map = {};\n        for (var name in Object.getOwnPropertyNames(obj))\n            map[name] = Object.getOwnPropertyDescriptor(obj, name);\n        return map;\n    }\n\n    function makePassthruHandler(obj) {\n        // Handler copied from\n        // http://wiki.ecmascript.org/doku.php?id=harmony:proxies&s=proxy%20object#examplea_no-op_forwarding_proxy\n        return {\n            getOwnPropertyDescriptor: function(name) {\n                var desc = Object.getOwnPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getPropertyDescriptor: function(name) {\n                var desc = getPropertyDescriptor(obj, name);\n\n                // a trapping proxy's properties must always be configurable\n                desc.configurable = true;\n                return desc;\n            },\n            getOwnPropertyNames: function() {\n                return Object.getOwnPropertyNames(obj);\n            },\n            defineProperty: function(name, desc) {\n                Object.defineProperty(obj, name, desc);\n            },\n            \"delete\": function(name) { return delete obj[name]; },\n            fix: function() {\n                if (Object.isFrozen(obj)) {\n                    return getOwnProperties(obj);\n                }\n\n                // As long as obj is not frozen, the proxy won't allow itself to be fixed.\n                return undefined; // will cause a TypeError to be thrown\n            },\n\n            has: function(name) { return name in obj; },\n            hasOwn: function(name) { return ({}).hasOwnProperty.call(obj, name); },\n            get: function(receiver, name) { return obj[name]; },\n\n            // bad behavior when set fails in non-strict mode\n            set: function(receiver, name, val) { obj[name] = val; return true; },\n            enumerate: function() {\n                var result = [];\n                for (name in obj) { result.push(name); };\n                return result;\n            },\n            keys: function() { return Object.keys(obj); }\n        };\n    }\n\n    // default function used when looking for a property in the global object\n    function noPropFound() { return undefined; }\n\n    var hasOwnProperty = ({}).hasOwnProperty;\n\n    function StringMap() {\n        this.table = Object.create(null, {});\n        this.size = 0;\n    }\n\n    StringMap.prototype = {\n        has: function(x) { return hasOwnProperty.call(this.table, x); },\n        set: function(x, v) {\n            if (!hasOwnProperty.call(this.table, x))\n                this.size++;\n            this.table[x] = v;\n        },\n        get: function(x) { return this.table[x]; },\n        getDef: function(x, thunk) {\n            if (!hasOwnProperty.call(this.table, x)) {\n                this.size++;\n                this.table[x] = thunk();\n            }\n            return this.table[x];\n        },\n        forEach: function(f) {\n            var table = this.table;\n            for (var key in table)\n                f.call(this, key, table[key]);\n        },\n        toString: function() { return \"[object StringMap]\" }\n    };\n\n    // non-destructive stack\n    function Stack(elts) {\n        this.elts = elts || null;\n    }\n\n    Stack.prototype = {\n        push: function(x) {\n            return new Stack({ top: x, rest: this.elts });\n        },\n        top: function() {\n            if (!this.elts)\n                throw new Error(\"empty stack\");\n            return this.elts.top;\n        },\n        isEmpty: function() {\n            return this.top === null;\n        },\n        find: function(test) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                if (test(elts.top))\n                    return elts.top;\n            }\n            return null;\n        },\n        has: function(x) {\n            return Boolean(this.find(function(elt) { return elt === x }));\n        },\n        forEach: function(f) {\n            for (var elts = this.elts; elts; elts = elts.rest) {\n                f(elts.top);\n            }\n        }\n    };\n\n    return {\n        tokens: tokens,\n        opTypeNames: opTypeNames,\n        keywords: keywords,\n        isStatementStartCode: isStatementStartCode,\n        tokenIds: tokenIds,\n        consts: consts,\n        assignOps: assignOps,\n        defineGetter: defineGetter,\n        defineProperty: defineProperty,\n        isNativeCode: isNativeCode,\n        makePassthruHandler: makePassthruHandler,\n        noPropFound: noPropFound,\n        StringMap: StringMap,\n        Stack: Stack\n    };\n}());\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Lexical scanner.\n */\n\nNarcissus.lexer = (function() {\n\n    var definitions = Narcissus.definitions;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    // Build up a trie of operator tokens.\n    var opTokens = {};\n    for (var op in definitions.opTypeNames) {\n        if (op === '\\n' || op === '.')\n            continue;\n\n        var node = opTokens;\n        for (var i = 0; i < op.length; i++) {\n            var ch = op[i];\n            if (!(ch in node))\n                node[ch] = {};\n            node = node[ch];\n            node.op = op;\n        }\n    }\n\n    /*\n     * Tokenizer :: (source, filename, line number) -> Tokenizer\n     */\n    function Tokenizer(s, f, l) {\n        this.cursor = 0;\n        this.source = String(s);\n        this.tokens = [];\n        this.tokenIndex = 0;\n        this.lookahead = 0;\n        this.scanNewlines = false;\n        this.unexpectedEOF = false;\n        this.filename = f || \"\";\n        this.lineno = l || 1;\n        this.comments = [];\n    }\n\n    Tokenizer.prototype = {\n        get done() {\n            // We need to set scanOperand to true here because the first thing\n            // might be a regexp.\n            return this.peek(true) === END;\n        },\n\n        get token() {\n            return this.tokens[this.tokenIndex];\n        },\n\n        match: function (tt, scanOperand) {\n            return this.get(scanOperand) === tt || this.unget();\n        },\n\n        mustMatch: function (tt) {\n            if (!this.match(tt)) {\n                throw this.newSyntaxError(\"Missing \" +\n                                          definitions.tokens[tt].toLowerCase());\n            }\n            return this.token;\n        },\n\n        peek: function (scanOperand) {\n            var tt, next;\n            if (this.lookahead) {\n                next = this.tokens[(this.tokenIndex + this.lookahead) & 3];\n                tt = (this.scanNewlines && next.lineno !== this.lineno)\n                     ? NEWLINE\n                     : next.type;\n            } else {\n                tt = this.get(scanOperand);\n                this.unget();\n            }\n            return tt;\n        },\n\n        peekOnSameLine: function (scanOperand) {\n            this.scanNewlines = true;\n            var tt = this.peek(scanOperand);\n            this.scanNewlines = false;\n            return tt;\n        },\n\n        // Eat comments and whitespace.\n        // toka: returns list of skipped comments\n        skip: function () {\n            var input = this.source;\n            var cstart;\n            var clineno;\n            var comments = [];\n            var comment;\n            var nlcount = 0;\n\n            for (;;) {\n                var ch = input[this.cursor++];\n                var next = input[this.cursor];\n                if (ch === '\\n' && !this.scanNewlines) {\n                    this.lineno++;\n                    nlcount++;\n                } else if (ch === '/' && next === '*') {\n                    cstart = this.cursor;\n                    clineno = this.lineno;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated comment\");\n\n                        if (ch === '*') {\n                            next = input[this.cursor];\n                            if (next === '/') {\n                                this.cursor++;\n                                comment = {\n                                    type: \"BLOCK_COMMENT\",\n                                    nlcount: nlcount,\n                                    start:cstart-1, end:this.cursor, lineno:clineno, endlineno: this.lineno,\n                                    value: input.substring(cstart+1,this.cursor-2)\n                                }\n                                // comments.push(comment);\n                                this.comments.push(comment);\n                                nlcount = 0;\n                                break;\n                            }\n                        } else if (ch === '\\n') {\n                            this.lineno++;\n                        }\n                    }\n                } else if (ch === '/' && next === '/') {\n                    cstart = this.cursor;\n                    this.cursor++;\n                    for (;;) {\n                        ch = input[this.cursor++];\n                        if (ch === undefined) {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            // comments.push(comment);\n                            this.comments.push(comment);\n                            return;\n                            // return comments;\n                        }\n                        if (ch === '\\n') {\n                            comment = {\n                                type: \"LINE_COMMENT\",\n                                start: cstart, end:this.cursor,\n                                lineno: this.lineno, nlcount: nlcount,\n                                value: input.substring(cstart+1,this.cursor-1)\n                            };\n\n                            //comments.push(  );\n                            this.comments.push(comment);\n                            nlcount = 0;\n                            this.lineno++;\n                            break;\n                        }\n                    }\n                } else if (ch !== ' ' && ch !== '\\t') {\n                    this.cursor--;\n                    // return comments;\n                    return;\n                }\n            }\n        },\n\n        // Lex the exponential part of a number, if present. Return true iff an\n        // exponential part was found.\n        lexExponent: function() {\n            var input = this.source;\n            var next = input[this.cursor];\n            if (next === 'e' || next === 'E') {\n                this.cursor++;\n                ch = input[this.cursor++];\n                if (ch === '+' || ch === '-')\n                    ch = input[this.cursor++];\n\n                if (ch < '0' || ch > '9')\n                    throw this.newSyntaxError(\"Missing exponent\");\n\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                return true;\n            }\n\n            return false;\n        },\n\n        lexZeroNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            ch = input[this.cursor++];\n            if (ch === '.') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n                token.value = parseFloat(token.start, this.cursor);\n            } else if (ch === 'x' || ch === 'X') {\n                do {\n                    ch = input[this.cursor++];\n                } while ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||\n                         (ch >= 'A' && ch <= 'F'));\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else if (ch >= '0' && ch <= '7') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '7');\n                this.cursor--;\n\n                token.value = parseInt(input.substring(token.start, this.cursor));\n            } else {\n                this.cursor--;\n                this.lexExponent();     // 0E1, &c.\n                token.value = 0;\n            }\n        },\n\n        lexNumber: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = NUMBER;\n\n            var floating = false;\n            do {\n                ch = input[this.cursor++];\n                if (ch === '.' && !floating) {\n                    floating = true;\n                    ch = input[this.cursor++];\n                }\n            } while (ch >= '0' && ch <= '9');\n\n            this.cursor--;\n\n            var exponent = this.lexExponent();\n            floating = floating || exponent;\n\n            var str = input.substring(token.start, this.cursor);\n            token.value = floating ? parseFloat(str) : parseInt(str);\n        },\n\n        lexDot: function (ch) {\n            var token = this.token, input = this.source;\n            var next = input[this.cursor];\n            if (next >= '0' && next <= '9') {\n                do {\n                    ch = input[this.cursor++];\n                } while (ch >= '0' && ch <= '9');\n                this.cursor--;\n\n                this.lexExponent();\n\n                token.type = NUMBER;\n                token.value = parseFloat(token.start, this.cursor);\n            } else {\n                token.type = DOT;\n                token.assignOp = null;\n                token.value = '.';\n            }\n        },\n\n        lexString: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = STRING;\n\n            var hasEscapes = false;\n            var delim = ch;\n            while ((ch = input[this.cursor++]) !== delim) {\n                // [JS2COFFEE] Fixed to make it work on a browser\n                if (this.cursor >= input.length)\n                    throw this.newSyntaxError(\"Unterminated string literal\");\n                if (ch === '\\\\') {\n                    hasEscapes = true;\n                    if (++this.cursor == input.length)\n                        throw this.newSyntaxError(\"Unterminated string literal\");\n                }\n            }\n\n            token.value = hasEscapes\n                          ? eval(input.substring(token.start, this.cursor))\n                          : input.substring(token.start + 1, this.cursor - 1);\n        },\n\n        lexRegExp: function (ch) {\n            var token = this.token, input = this.source;\n            token.type = REGEXP;\n\n            do {\n                ch = input[this.cursor++];\n                if (ch === '\\\\') {\n                    this.cursor++;\n                } else if (ch === '[') {\n                    do {\n                        if (ch === undefined)\n                            throw this.newSyntaxError(\"Unterminated character class\");\n\n                        if (ch === '\\\\')\n                            this.cursor++;\n\n                        ch = input[this.cursor++];\n                    } while (ch !== ']');\n                } else if (ch === undefined) {\n                    throw this.newSyntaxError(\"Unterminated regex\");\n                }\n            } while (ch !== '/');\n\n            do {\n                ch = input[this.cursor++];\n            } while (ch >= 'a' && ch <= 'z');\n\n            this.cursor--;\n\n            token.value = eval(input.substring(token.start, this.cursor));\n        },\n\n        lexOp: function (ch) {\n            var token = this.token, input = this.source;\n\n            // A bit ugly, but it seems wasteful to write a trie lookup routine\n            // for only 3 characters...\n            var node = opTokens[ch];\n            var next = input[this.cursor];\n            if (next in node) {\n                node = node[next];\n                this.cursor++;\n                next = input[this.cursor];\n                if (next in node) {\n                    node = node[next];\n                    this.cursor++;\n                    next = input[this.cursor];\n                }\n            }\n\n            var op = node.op;\n            if (definitions.assignOps[op] && input[this.cursor] === '=') {\n                this.cursor++;\n                token.type = ASSIGN;\n                token.assignOp = definitions.tokenIds[definitions.opTypeNames[op]];\n                op += '=';\n            } else {\n                token.type = definitions.tokenIds[definitions.opTypeNames[op]];\n                token.assignOp = null;\n            }\n\n            token.value = op;\n        },\n\n        // FIXME: Unicode escape sequences\n        // FIXME: Unicode identifiers\n        lexIdent: function (ch) {\n            var token = this.token, input = this.source;\n\n            do {\n                ch = input[this.cursor++];\n            } while ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||\n                     (ch >= '0' && ch <= '9') || ch === '$' || ch === '_');\n\n            this.cursor--;  // Put the non-word character back.\n\n            var id = input.substring(token.start, this.cursor);\n            token.type = definitions.keywords[id] || IDENTIFIER;\n            token.value = id;\n        },\n\n        /*\n         * Tokenizer.get :: void -> token type\n         *\n         * Consume input *only* if there is no lookahead.\n         * Dispatch to the appropriate lexing function depending on the input.\n         */\n        get: function (scanOperand) {\n            var token;\n            while (this.lookahead) {\n                --this.lookahead;\n                this.tokenIndex = (this.tokenIndex + 1) & 3;\n                token = this.tokens[this.tokenIndex];\n                if (token.type !== NEWLINE || this.scanNewlines)\n                    return token.type;\n            }\n\n            // var comments =\n            this.skip();\n\n            this.tokenIndex = (this.tokenIndex + 1) & 3;\n            token = this.tokens[this.tokenIndex];\n            if (!token)\n                this.tokens[this.tokenIndex] = token = {};\n\n            var input = this.source;\n            if (this.cursor === input.length)\n                return token.type = END;\n\n            token.start = this.cursor;\n            token.lineno = this.lineno;\n\n            var ch = input[this.cursor++];\n            if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch === '$' || ch === '_') {\n                this.lexIdent(ch);\n            } else if (scanOperand && ch === '/') {\n                this.lexRegExp(ch);\n            } else if (ch in opTokens) {\n                this.lexOp(ch);\n            } else if (ch === '.') {\n                this.lexDot(ch);\n            } else if (ch >= '1' && ch <= '9') {\n                this.lexNumber(ch);\n            } else if (ch === '0') {\n                this.lexZeroNumber(ch);\n            } else if (ch === '\"' || ch === \"'\") {\n                this.lexString(ch);\n            } else if (this.scanNewlines && ch === '\\n') {\n                token.type = NEWLINE;\n                token.value = '\\n';\n                this.lineno++;\n            } else {\n                throw this.newSyntaxError(\"Illegal token\");\n            }\n\n            token.end = this.cursor;\n            // token.comments = [comments,this.skip()];\n            return token.type;\n        },\n\n        /*\n         * Tokenizer.unget :: void -> undefined\n         *\n         * Match depends on unget returning undefined.\n         */\n        unget: function () {\n            if (++this.lookahead === 4) throw \"PANIC: too much lookahead!\";\n            this.tokenIndex = (this.tokenIndex - 1) & 3;\n        },\n\n        newSyntaxError: function (m) {\n            var e = new SyntaxError(m, this.filename, this.lineno);\n            e.source = this.source;\n            e.cursor = this.lookahead\n                       ? this.tokens[(this.tokenIndex + this.lookahead) & 3].start\n                       : this.cursor;\n            return e;\n        },\n    };\n\n    return { Tokenizer: Tokenizer };\n\n}());\n\n/* -*- Mode: JS; tab-width: 4; indent-tabs-mode: nil; -*-\n * vim: set sw=4 ts=4 et tw=78:\n * ***** BEGIN LICENSE BLOCK *****\n *\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Narcissus JavaScript engine.\n *\n * The Initial Developer of the Original Code is\n * Brendan Eich <brendan@mozilla.org>.\n * Portions created by the Initial Developer are Copyright (C) 2004\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Tom Austin <taustin@ucsc.edu>\n *   Brendan Eich <brendan@mozilla.org>\n *   Shu-Yu Guo <shu@rfrn.org>\n *   Dave Herman <dherman@mozilla.com>\n *   Dimitris Vardoulakis <dimvar@ccs.neu.edu>\n *   Patrick Walton <pcwalton@mozilla.com>\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/*\n * Narcissus - JS implemented in JS.\n *\n * Parser.\n */\n\nNarcissus.parser = (function() {\n\n    var lexer = Narcissus.lexer;\n    var definitions = Narcissus.definitions;\n\n    const StringMap = definitions.StringMap;\n    const Stack = definitions.Stack;\n\n    // Set constants in the local scope.\n    eval(definitions.consts);\n\n    /*\n     * pushDestructuringVarDecls :: (node, hoisting node) -> void\n     *\n     * Recursively add all destructured declarations to varDecls.\n     */\n    function pushDestructuringVarDecls(n, s) {\n        for (var i in n) {\n            var sub = n[i];\n            if (sub.type === IDENTIFIER) {\n                s.varDecls.push(sub);\n            } else {\n                pushDestructuringVarDecls(sub, s);\n            }\n        }\n    }\n\n    // NESTING_TOP: top-level\n    // NESTING_SHALLOW: nested within static forms such as { ... } or labeled statement\n    // NESTING_DEEP: nested within dynamic forms such as if, loops, etc.\n    const NESTING_TOP = 0, NESTING_SHALLOW = 1, NESTING_DEEP = 2;\n\n    function StaticContext(parentScript, parentBlock, inFunction, inForLoopInit, nesting) {\n        this.parentScript = parentScript;\n        this.parentBlock = parentBlock;\n        this.inFunction = inFunction;\n        this.inForLoopInit = inForLoopInit;\n        this.nesting = nesting;\n        this.allLabels = new Stack();\n        this.currentLabels = new Stack();\n        this.labeledTargets = new Stack();\n        this.defaultTarget = null;\n        Narcissus.options.ecma3OnlyMode && (this.ecma3OnlyMode = true);\n        Narcissus.options.parenFreeMode && (this.parenFreeMode = true);\n    }\n\n    StaticContext.prototype = {\n        ecma3OnlyMode: false,\n        parenFreeMode: false,\n        // non-destructive update via prototype extension\n        update: function(ext) {\n            var desc = {};\n            for (var key in ext) {\n                desc[key] = {\n                    value: ext[key],\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                }\n            }\n            return Object.create(this, desc);\n        },\n        pushLabel: function(label) {\n            return this.update({ currentLabels: this.currentLabels.push(label),\n                                 allLabels: this.allLabels.push(label) });\n        },\n        pushTarget: function(target) {\n            var isDefaultTarget = target.isLoop || target.type === SWITCH;\n\n            if (this.currentLabels.isEmpty()) {\n                return isDefaultTarget\n                     ? this.update({ defaultTarget: target })\n                     : this;\n            }\n\n            target.labels = new StringMap();\n            this.currentLabels.forEach(function(label) {\n                target.labels.set(label, true);\n            });\n            return this.update({ currentLabels: new Stack(),\n                                 labeledTargets: this.labeledTargets.push(target),\n                                 defaultTarget: isDefaultTarget\n                                                ? target\n                                                : this.defaultTarget });\n        },\n        nest: function(atLeast) {\n            var nesting = Math.max(this.nesting, atLeast);\n            return (nesting !== this.nesting)\n                 ? this.update({ nesting: nesting })\n                 : this;\n        }\n    };\n\n    /*\n     * Script :: (tokenizer, boolean) -> node\n     *\n     * Parses the toplevel and function bodies.\n     */\n    function Script(t, inFunction) {\n        var n = new Node(t, scriptInit());\n        var x = new StaticContext(n, n, inFunction, false, NESTING_TOP);\n        Statements(t, x, n);\n        return n;\n    }\n\n    // We extend Array slightly with a top-of-stack method.\n    definitions.defineProperty(Array.prototype, \"top\",\n                               function() {\n                                   return this.length && this[this.length-1];\n                               }, false, false, true);\n\n    /*\n     * Node :: (tokenizer, optional init object) -> node\n     */\n    function Node(t, init) {\n        var token = t.token;\n        if (token) {\n            // If init.type exists it will override token.type.\n            this.type = token.type;\n            this.value = token.value;\n            this.lineno = token.lineno;\n\n            // Start and end are file positions for error handling.\n            this.start = token.start;\n            this.end = token.end;\n\n        } else {\n            this.lineno = t.lineno;\n        }\n\n        // Node uses a tokenizer for debugging (getSource, filename getter).\n        this.tokenizer = t;\n        this.children = [];\n\n        for (var prop in init)\n            this[prop] = init[prop];\n    }\n\n    var Np = Node.prototype = {};\n    Np.constructor = Node;\n    Np.toSource = Object.prototype.toSource;\n\n    // Always use push to add operands to an expression, to update start and end.\n    Np.push = function (kid) {\n        // kid can be null e.g. [1, , 2].\n        if (kid !== null) {\n            if (kid.start < this.start)\n                this.start = kid.start;\n            if (this.end < kid.end)\n                this.end = kid.end;\n        }\n        return this.children.push(kid);\n    }\n\n    Node.indentLevel = 0;\n\n    function tokenString(tt) {\n        var t = definitions.tokens[tt];\n        return /^\\W/.test(t) ? definitions.opTypeNames[t] : t.toUpperCase();\n    }\n\n    Np.toString = function () {\n        var a = [];\n        for (var i in this) {\n            if (this.hasOwnProperty(i) && i !== 'type' && i !== 'target')\n                a.push({id: i, value: this[i]});\n        }\n        a.sort(function (a,b) { return (a.id < b.id) ? -1 : 1; });\n        const INDENTATION = \"    \";\n        var n = ++Node.indentLevel;\n        var s = \"{\\n\" + INDENTATION.repeat(n) + \"type: \" + tokenString(this.type);\n        for (i = 0; i < a.length; i++)\n            s += \",\\n\" + INDENTATION.repeat(n) + a[i].id + \": \" + a[i].value;\n        n = --Node.indentLevel;\n        s += \"\\n\" + INDENTATION.repeat(n) + \"}\";\n        return s;\n    }\n\n    Np.getSource = function () {\n        return this.tokenizer.source.slice(this.start, this.end);\n    };\n\n    /*\n     * Helper init objects for common nodes.\n     */\n\n    const LOOP_INIT = { isLoop: true };\n\n    function blockInit() {\n        return { type: BLOCK, varDecls: [] };\n    }\n\n    function scriptInit() {\n        return { type: SCRIPT,\n                 funDecls: [],\n                 varDecls: [],\n                 modDecls: [],\n                 impDecls: [],\n                 expDecls: [],\n                 loadDeps: [],\n                 hasEmptyReturn: false,\n                 hasReturnWithValue: false,\n                 isGenerator: false };\n    }\n\n    definitions.defineGetter(Np, \"filename\",\n                             function() {\n                                 return this.tokenizer.filename;\n                             });\n\n    definitions.defineGetter(Np, \"length\",\n                             function() {\n                                 throw new Error(\"Node.prototype.length is gone; \" +\n                                                 \"use n.children.length instead\");\n                             });\n\n    definitions.defineProperty(String.prototype, \"repeat\",\n                               function(n) {\n                                   var s = \"\", t = this + s;\n                                   while (--n >= 0)\n                                       s += t;\n                                   return s;\n                               }, false, false, true);\n\n    function MaybeLeftParen(t, x) {\n        if (x.parenFreeMode)\n            return t.match(LEFT_PAREN) ? LEFT_PAREN : END;\n        return t.mustMatch(LEFT_PAREN).type;\n    }\n\n    function MaybeRightParen(t, p) {\n        if (p === LEFT_PAREN)\n            t.mustMatch(RIGHT_PAREN);\n    }\n\n    /*\n     * Statements :: (tokenizer, compiler context, node) -> void\n     *\n     * Parses a sequence of Statements.\n     */\n    function Statements(t, x, n) {\n        try {\n            while (!t.done && t.peek(true) !== RIGHT_CURLY)\n            { n.push(Statement(t, x)); }\n        } catch (e) {\n            if (t.done)\n            { t.unexpectedEOF = true; }\n            throw(e);\n        }\n    }\n\n    function Block(t, x) {\n        t.mustMatch(LEFT_CURLY);\n        var n = new Node(t, blockInit());\n        Statements(t, x.update({ parentBlock: n }).pushTarget(n), n);\n        t.mustMatch(RIGHT_CURLY);\n        return n;\n    }\n\n    const DECLARED_FORM = 0, EXPRESSED_FORM = 1, STATEMENT_FORM = 2;\n\n    /*\n     * Statement :: (tokenizer, compiler context) -> node\n     *\n     * Parses a Statement.\n     */\n    function Statement(t, x) {\n        var i, label, n, n2, p, c, ss, tt = t.get(true), tt2, x2, x3;\n\n        // Cases for statements ending in a right curly return early, avoiding the\n        // common semicolon insertion magic after this switch.\n        switch (tt) {\n          case FUNCTION:\n            // DECLARED_FORM extends funDecls of x, STATEMENT_FORM doesn't.\n            return FunctionDefinition(t, x, true,\n                                      (x.nesting !== NESTING_TOP)\n                                      ? STATEMENT_FORM\n                                      : DECLARED_FORM);\n\n          case LEFT_CURLY:\n            n = new Node(t, blockInit());\n            Statements(t, x.update({ parentBlock: n }).pushTarget(n).nest(NESTING_SHALLOW), n);\n            t.mustMatch(RIGHT_CURLY);\n            return n;\n\n          case IF:\n            n = new Node(t);\n            n.condition = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            n.thenPart = Statement(t, x2);\n            n.elsePart = t.match(ELSE) ? Statement(t, x2) : null;\n            return n;\n\n          case SWITCH:\n            // This allows CASEs after a DEFAULT, which is in the standard.\n            n = new Node(t, { cases: [], defaultIndex: -1 });\n            n.discriminant = HeadExpression(t, x);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            t.mustMatch(LEFT_CURLY);\n            while ((tt = t.get()) !== RIGHT_CURLY) {\n                switch (tt) {\n                  case DEFAULT:\n                    if (n.defaultIndex >= 0)\n                        throw t.newSyntaxError(\"More than one switch default\");\n                    // FALL THROUGH\n                  case CASE:\n                    n2 = new Node(t);\n                    if (tt === DEFAULT)\n                        n.defaultIndex = n.cases.length;\n                    else\n                        n2.caseLabel = Expression(t, x2, COLON);\n                    break;\n\n                  default:\n                    throw t.newSyntaxError(\"Invalid switch case\");\n                }\n                t.mustMatch(COLON);\n                n2.statements = new Node(t, blockInit());\n                while ((tt=t.peek(true)) !== CASE && tt !== DEFAULT &&\n                        tt !== RIGHT_CURLY)\n                    n2.statements.push(Statement(t, x2));\n                n.cases.push(n2);\n            }\n            return n;\n\n          case FOR:\n            n = new Node(t, LOOP_INIT);\n            if (t.match(IDENTIFIER)) {\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(LEFT_PAREN);\n            x2 = x.pushTarget(n).nest(NESTING_DEEP);\n            x3 = x.update({ inForLoopInit: true });\n            if ((tt = t.peek()) !== SEMICOLON) {\n                if (tt === VAR || tt === CONST) {\n                    t.get();\n                    n2 = Variables(t, x3);\n                } else if (tt === LET) {\n                    t.get();\n                    if (t.peek() === LEFT_PAREN) {\n                        n2 = LetBlock(t, x3, false);\n                    } else {\n                        // Let in for head, we need to add an implicit block\n                        // around the rest of the for.\n                        x3.parentBlock = n;\n                        n.varDecls = [];\n                        n2 = Variables(t, x3);\n                    }\n                } else {\n                    n2 = Expression(t, x3);\n                }\n            }\n            if (n2 && t.match(IN)) {\n                n.type = FOR_IN;\n                n.object = Expression(t, x3);\n                if (n2.type === VAR || n2.type === LET) {\n                    c = n2.children;\n\n                    // Destructuring turns one decl into multiples, so either\n                    // there must be only one destructuring or only one\n                    // decl.\n                    if (c.length !== 1 && n2.destructurings.length !== 1) {\n                        throw new SyntaxError(\"Invalid for..in left-hand side\",\n                                              t.filename, n2.lineno);\n                    }\n                    if (n2.destructurings.length > 0) {\n                        n.iterator = n2.destructurings[0];\n                    } else {\n                        n.iterator = c[0];\n                    }\n                    n.varDecl = n2;\n                } else {\n                    if (n2.type === ARRAY_INIT || n2.type === OBJECT_INIT) {\n                        n2.destructuredNames = checkDestructuring(t, x3, n2);\n                    }\n                    n.iterator = n2;\n                }\n            } else {\n                n.setup = n2;\n                t.mustMatch(SEMICOLON);\n                if (n.isEach)\n                    throw t.newSyntaxError(\"Invalid for each..in loop\");\n                n.condition = (t.peek() === SEMICOLON)\n                              ? null\n                              : Expression(t, x3);\n                t.mustMatch(SEMICOLON);\n                tt2 = t.peek();\n                n.update = (x.parenFreeMode\n                            ? tt2 === LEFT_CURLY || definitions.isStatementStartCode[tt2]\n                            : tt2 === RIGHT_PAREN)\n                           ? null\n                           : Expression(t, x3);\n            }\n            if (!x.parenFreeMode)\n                t.mustMatch(RIGHT_PAREN);\n            n.body = Statement(t, x2);\n            return n;\n\n          case WHILE:\n            n = new Node(t, { isLoop: true });\n            n.condition = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case DO:\n            n = new Node(t, { isLoop: true });\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            t.mustMatch(WHILE);\n            n.condition = HeadExpression(t, x);\n            if (!x.ecmaStrictMode) {\n                // <script language=\"JavaScript\"> (without version hints) may need\n                // automatic semicolon insertion without a newline after do-while.\n                // See http://bugzilla.mozilla.org/show_bug.cgi?id=238945.\n                t.match(SEMICOLON);\n                return n;\n            }\n            break;\n\n          case BREAK:\n          case CONTINUE:\n            n = new Node(t);\n\n            // handle the |foo: break foo;| corner case\n            x2 = x.pushTarget(n);\n\n            if (t.peekOnSameLine() === IDENTIFIER) {\n                t.get();\n                n.label = t.token.value;\n            }\n\n            n.target = n.label\n                     ? x2.labeledTargets.find(function(target) { return target.labels.has(n.label) })\n                     : x2.defaultTarget;\n\n            if (!n.target)\n                throw t.newSyntaxError(\"Invalid \" + ((tt === BREAK) ? \"break\" : \"continue\"));\n            if (!n.target.isLoop && tt === CONTINUE)\n                throw t.newSyntaxError(\"Invalid continue\");\n\n            break;\n\n          case TRY:\n            n = new Node(t, { catchClauses: [] });\n            n.tryBlock = Block(t, x);\n            while (t.match(CATCH)) {\n                n2 = new Node(t);\n                p = MaybeLeftParen(t, x);\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured catch identifiers.\n                    t.unget();\n                    n2.varName = DestructuringExpression(t, x, true);\n                    break;\n                  case IDENTIFIER:\n                    n2.varName = t.token.value;\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing identifier in catch\");\n                    break;\n                }\n                if (t.match(IF)) {\n                    if (x.ecma3OnlyMode)\n                        throw t.newSyntaxError(\"Illegal catch guard\");\n                    if (n.catchClauses.length && !n.catchClauses.top().guard)\n                        throw t.newSyntaxError(\"Guarded catch after unguarded\");\n                    n2.guard = Expression(t, x);\n                }\n                MaybeRightParen(t, p);\n                n2.block = Block(t, x);\n                n.catchClauses.push(n2);\n            }\n            if (t.match(FINALLY))\n                n.finallyBlock = Block(t, x);\n            if (!n.catchClauses.length && !n.finallyBlock)\n                throw t.newSyntaxError(\"Invalid try statement\");\n            return n;\n\n          case CATCH:\n          case FINALLY:\n            throw t.newSyntaxError(definitions.tokens[tt] + \" without preceding try\");\n\n          case THROW:\n            n = new Node(t);\n            n.exception = Expression(t, x);\n            break;\n\n          case RETURN:\n            n = ReturnOrYield(t, x);\n            break;\n\n          case WITH:\n            n = new Node(t);\n            n.object = HeadExpression(t, x);\n            n.body = Statement(t, x.pushTarget(n).nest(NESTING_DEEP));\n            return n;\n\n          case VAR:\n          case CONST:\n            n = Variables(t, x);\n            break;\n\n          case LET:\n            if (t.peek() === LEFT_PAREN)\n                n = LetBlock(t, x, true);\n            else\n                n = Variables(t, x);\n            break;\n\n          case DEBUGGER:\n            n = new Node(t);\n            break;\n\n          case NEWLINE:\n          case SEMICOLON:\n            n = new Node(t, { type: SEMICOLON });\n            n.expression = null;\n            return n;\n\n          default:\n            if (tt === IDENTIFIER) {\n                tt = t.peek();\n                // Labeled statement.\n                if (tt === COLON) {\n                    label = t.token.value;\n                    if (x.allLabels.has(label))\n                        throw t.newSyntaxError(\"Duplicate label\");\n                    t.get();\n                    n = new Node(t, { type: LABEL, label: label });\n                    n.statement = Statement(t, x.pushLabel(label).nest(NESTING_SHALLOW));\n                    n.target = (n.statement.type === LABEL) ? n.statement.target : n.statement;\n                    return n;\n                }\n            }\n\n            // Expression statement.\n            // We unget the current token to parse the expression as a whole.\n            n = new Node(t, { type: SEMICOLON });\n            t.unget();\n            n.expression = Expression(t, x);\n            n.end = n.expression.end;\n            break;\n        }\n\n        MagicalSemicolon(t);\n        return n;\n    }\n\n    function MagicalSemicolon(t) {\n        var tt;\n        if (t.lineno === t.token.lineno) {\n            tt = t.peekOnSameLine();\n            if (tt !== END && tt !== NEWLINE && tt !== SEMICOLON && tt !== RIGHT_CURLY)\n                throw t.newSyntaxError(\"missing ; before statement\");\n        }\n        t.match(SEMICOLON);\n    }\n\n    function ReturnOrYield(t, x) {\n        var n, b, tt = t.token.type, tt2;\n\n        var parentScript = x.parentScript;\n\n        if (tt === RETURN) {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Return not in function\");\n        } else /* if (tt === YIELD) */ {\n            if (!x.inFunction)\n                throw t.newSyntaxError(\"Yield not in function\");\n            parentScript.isGenerator = true;\n        }\n        n = new Node(t, { value: undefined });\n\n        tt2 = t.peek(true);\n        if (tt2 !== END && tt2 !== NEWLINE &&\n            tt2 !== SEMICOLON && tt2 !== RIGHT_CURLY\n            && (tt !== YIELD ||\n                (tt2 !== tt && tt2 !== RIGHT_BRACKET && tt2 !== RIGHT_PAREN &&\n                 tt2 !== COLON && tt2 !== COMMA))) {\n            if (tt === RETURN) {\n                n.value = Expression(t, x);\n                parentScript.hasReturnWithValue = true;\n            } else {\n                n.value = AssignExpression(t, x);\n            }\n        } else if (tt === RETURN) {\n            parentScript.hasEmptyReturn = true;\n        }\n\n        // Disallow return v; in generator.\n        if (parentScript.hasReturnWithValue && parentScript.isGenerator)\n            throw t.newSyntaxError(\"Generator returns a value\");\n\n        return n;\n    }\n\n    /*\n     * FunctionDefinition :: (tokenizer, compiler context, boolean,\n     *                        DECLARED_FORM or EXPRESSED_FORM or STATEMENT_FORM)\n     *                    -> node\n     */\n    function FunctionDefinition(t, x, requireName, functionForm) {\n        var tt;\n        var f = new Node(t, { params: [] });\n        if (f.type !== FUNCTION)\n            f.type = (f.value === \"get\") ? GETTER : SETTER;\n        if (t.match(IDENTIFIER))\n            f.name = t.token.value;\n        else if (requireName)\n            throw t.newSyntaxError(\"missing function identifier\");\n\n        var x2 = new StaticContext(null, null, true, false, NESTING_TOP);\n\n        t.mustMatch(LEFT_PAREN);\n        if (!t.match(RIGHT_PAREN)) {\n            do {\n                switch (t.get()) {\n                  case LEFT_BRACKET:\n                  case LEFT_CURLY:\n                    // Destructured formal parameters.\n                    t.unget();\n                    f.params.push(DestructuringExpression(t, x2));\n                    break;\n                  case IDENTIFIER:\n                    f.params.push(t.token.value);\n                    break;\n                  default:\n                    throw t.newSyntaxError(\"missing formal parameter\");\n                    break;\n                }\n            } while (t.match(COMMA));\n            t.mustMatch(RIGHT_PAREN);\n        }\n\n        // Do we have an expression closure or a normal body?\n        tt = t.get();\n        if (tt !== LEFT_CURLY)\n            t.unget();\n\n        if (tt !== LEFT_CURLY) {\n            f.body = AssignExpression(t, x2);\n            if (f.body.isGenerator)\n                throw t.newSyntaxError(\"Generator returns a value\");\n        } else {\n            f.body = Script(t, true);\n        }\n\n        if (tt === LEFT_CURLY)\n            t.mustMatch(RIGHT_CURLY);\n\n        f.end = t.token.end;\n        f.functionForm = functionForm;\n        if (functionForm === DECLARED_FORM)\n            x.parentScript.funDecls.push(f);\n        return f;\n    }\n\n    /*\n     * Variables :: (tokenizer, compiler context) -> node\n     *\n     * Parses a comma-separated list of var declarations (and maybe\n     * initializations).\n     */\n    function Variables(t, x, letBlock) {\n        var n, n2, ss, i, s, tt;\n\n        tt = t.token.type;\n        switch (tt) {\n          case VAR:\n          case CONST:\n            s = x.parentScript;\n            break;\n          case LET:\n            s = x.parentBlock;\n            break;\n          case LEFT_PAREN:\n            tt = LET;\n            s = letBlock;\n            break;\n        }\n\n        n = new Node(t, { type: tt, destructurings: [] });\n\n        do {\n            tt = t.get();\n            if (tt === LEFT_BRACKET || tt === LEFT_CURLY) {\n                // Need to unget to parse the full destructured expression.\n                t.unget();\n\n                var dexp = DestructuringExpression(t, x, true);\n\n                n2 = new Node(t, { type: IDENTIFIER,\n                                   name: dexp,\n                                   readOnly: n.type === CONST });\n                n.push(n2);\n                pushDestructuringVarDecls(n2.name.destructuredNames, s);\n                n.destructurings.push({ exp: dexp, decl: n2 });\n\n                if (x.inForLoopInit && t.peek() === IN) {\n                    continue;\n                }\n\n                t.mustMatch(ASSIGN);\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n\n                continue;\n            }\n\n            if (tt !== IDENTIFIER)\n                throw t.newSyntaxError(\"missing variable name\");\n\n            n2 = new Node(t, { type: IDENTIFIER,\n                               name: t.token.value,\n                               readOnly: n.type === CONST });\n            n.push(n2);\n            s.varDecls.push(n2);\n\n            if (t.match(ASSIGN)) {\n                if (t.token.assignOp)\n                    throw t.newSyntaxError(\"Invalid variable initialization\");\n\n                n2.initializer = AssignExpression(t, x);\n            }\n        } while (t.match(COMMA));\n\n        return n;\n    }\n\n    /*\n     * LetBlock :: (tokenizer, compiler context, boolean) -> node\n     *\n     * Does not handle let inside of for loop init.\n     */\n    function LetBlock(t, x, isStatement) {\n        var n, n2;\n\n        // t.token.type must be LET\n        n = new Node(t, { type: LET_BLOCK, varDecls: [] });\n        t.mustMatch(LEFT_PAREN);\n        n.variables = Variables(t, x, n);\n        t.mustMatch(RIGHT_PAREN);\n\n        if (isStatement && t.peek() !== LEFT_CURLY) {\n            /*\n             * If this is really an expression in let statement guise, then we\n             * need to wrap the LET_BLOCK node in a SEMICOLON node so that we pop\n             * the return value of the expression.\n             */\n            n2 = new Node(t, { type: SEMICOLON,\n                               expression: n });\n            isStatement = false;\n        }\n\n        if (isStatement)\n            n.block = Block(t, x);\n        else\n            n.expression = AssignExpression(t, x);\n\n        return n;\n    }\n\n    function checkDestructuring(t, x, n, simpleNamesOnly) {\n        if (n.type === ARRAY_COMP)\n            throw t.newSyntaxError(\"Invalid array comprehension left-hand side\");\n        if (n.type !== ARRAY_INIT && n.type !== OBJECT_INIT)\n            return;\n\n        var lhss = {};\n        var nn, n2, idx, sub, cc, c = n.children;\n        for (var i = 0, j = c.length; i < j; i++) {\n            if (!(nn = c[i]))\n                continue;\n            if (nn.type === PROPERTY_INIT) {\n                cc = nn.children;\n                sub = cc[1];\n                idx = cc[0].value;\n            } else if (n.type === OBJECT_INIT) {\n                // Do we have destructuring shorthand {foo, bar}?\n                sub = nn;\n                idx = nn.value;\n            } else {\n                sub = nn;\n                idx = i;\n            }\n\n            if (sub.type === ARRAY_INIT || sub.type === OBJECT_INIT) {\n                lhss[idx] = checkDestructuring(t, x, sub, simpleNamesOnly);\n            } else {\n                if (simpleNamesOnly && sub.type !== IDENTIFIER) {\n                    // In declarations, lhs must be simple names\n                    throw t.newSyntaxError(\"missing name in pattern\");\n                }\n\n                lhss[idx] = sub;\n            }\n        }\n\n        return lhss;\n    }\n\n    function DestructuringExpression(t, x, simpleNamesOnly) {\n        var n = PrimaryExpression(t, x);\n        // Keep the list of lefthand sides for varDecls\n        n.destructuredNames = checkDestructuring(t, x, n, simpleNamesOnly);\n        return n;\n    }\n\n    function GeneratorExpression(t, x, e) {\n        return new Node(t, { type: GENERATOR,\n                             expression: e,\n                             tail: ComprehensionTail(t, x) });\n    }\n\n    function ComprehensionTail(t, x) {\n        var body, n, n2, n3, p;\n\n        // t.token.type must be FOR\n        body = new Node(t, { type: COMP_TAIL });\n\n        do {\n            // Comprehension tails are always for..in loops.\n            n = new Node(t, { type: FOR_IN, isLoop: true });\n            if (t.match(IDENTIFIER)) {\n                // But sometimes they're for each..in.\n                if (t.token.value === \"each\")\n                    n.isEach = true;\n                else\n                    t.unget();\n            }\n            p = MaybeLeftParen(t, x);\n            switch(t.get()) {\n              case LEFT_BRACKET:\n              case LEFT_CURLY:\n                t.unget();\n                // Destructured left side of for in comprehension tails.\n                n.iterator = DestructuringExpression(t, x);\n                break;\n\n              case IDENTIFIER:\n                n.iterator = n3 = new Node(t, { type: IDENTIFIER });\n                n3.name = n3.value;\n                n.varDecl = n2 = new Node(t, { type: VAR });\n                n2.push(n3);\n                x.parentScript.varDecls.push(n3);\n                // Don't add to varDecls since the semantics of comprehensions is\n                // such that the variables are in their own function when\n                // desugared.\n                break;\n\n              default:\n                throw t.newSyntaxError(\"missing identifier\");\n            }\n            t.mustMatch(IN);\n            n.object = Expression(t, x);\n            MaybeRightParen(t, p);\n            body.push(n);\n        } while (t.match(FOR));\n\n        // Optional guard.\n        if (t.match(IF))\n            body.guard = HeadExpression(t, x);\n\n        return body;\n    }\n\n    function HeadExpression(t, x) {\n        var p = MaybeLeftParen(t, x);\n        var n = ParenExpression(t, x);\n        MaybeRightParen(t, p);\n        if (p === END && !n.parenthesized) {\n            var tt = t.peek();\n            if (tt !== LEFT_CURLY && !definitions.isStatementStartCode[tt])\n                throw t.newSyntaxError(\"Unparenthesized head followed by unbraced body\");\n        }\n        return n;\n    }\n\n    function ParenExpression(t, x) {\n        // Always accept the 'in' operator in a parenthesized expression,\n        // where it's unambiguous, even if we might be parsing the init of a\n        // for statement.\n        var n = Expression(t, x.update({ inForLoopInit: x.inForLoopInit &&\n                                                        (t.token.type === LEFT_PAREN) }));\n\n        if (t.match(FOR)) {\n            if (n.type === YIELD && !n.parenthesized)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (n.type === COMMA && !n.parenthesized)\n                throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            n = GeneratorExpression(t, x, n);\n        }\n\n        return n;\n    }\n\n    /*\n     * Expression :: (tokenizer, compiler context) -> node\n     *\n     * Top-down expression parser matched against SpiderMonkey.\n     */\n    function Expression(t, x) {\n        var n, n2;\n\n        n = AssignExpression(t, x);\n        if (t.match(COMMA)) {\n            n2 = new Node(t, { type: COMMA });\n            n2.push(n);\n            n = n2;\n            do {\n                n2 = n.children[n.children.length-1];\n                if (n2.type === YIELD && !n2.parenthesized)\n                    throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n                n.push(AssignExpression(t, x));\n            } while (t.match(COMMA));\n        }\n\n        return n;\n    }\n\n    function AssignExpression(t, x) {\n        var n, lhs;\n\n        // Have to treat yield like an operand because it could be the leftmost\n        // operand of the expression.\n        if (t.match(YIELD, true))\n            return ReturnOrYield(t, x);\n\n        n = new Node(t, { type: ASSIGN });\n        lhs = ConditionalExpression(t, x);\n\n        if (!t.match(ASSIGN)) {\n            return lhs;\n        }\n\n        switch (lhs.type) {\n          case OBJECT_INIT:\n          case ARRAY_INIT:\n            lhs.destructuredNames = checkDestructuring(t, x, lhs);\n            // FALL THROUGH\n          case IDENTIFIER: case DOT: case INDEX: case CALL:\n            break;\n          default:\n            throw t.newSyntaxError(\"Bad left-hand side of assignment\");\n            break;\n        }\n\n        n.assignOp = t.token.assignOp;\n        n.push(lhs);\n        n.push(AssignExpression(t, x));\n\n        return n;\n    }\n\n    function ConditionalExpression(t, x) {\n        var n, n2;\n\n        n = OrExpression(t, x);\n        if (t.match(HOOK)) {\n            n2 = n;\n            n = new Node(t, { type: HOOK });\n            n.push(n2);\n            /*\n             * Always accept the 'in' operator in the middle clause of a ternary,\n             * where it's unambiguous, even if we might be parsing the init of a\n             * for statement.\n             */\n            n.push(AssignExpression(t, x.update({ inForLoopInit: false })));\n            if (!t.match(COLON))\n                throw t.newSyntaxError(\"missing : after ?\");\n            n.push(AssignExpression(t, x));\n        }\n\n        return n;\n    }\n\n    function OrExpression(t, x) {\n        var n, n2;\n\n        n = AndExpression(t, x);\n        while (t.match(OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AndExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseOrExpression(t, x);\n        while (t.match(AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseOrExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseOrExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseXorExpression(t, x);\n        while (t.match(BITWISE_OR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseXorExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseXorExpression(t, x) {\n        var n, n2;\n\n        n = BitwiseAndExpression(t, x);\n        while (t.match(BITWISE_XOR)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(BitwiseAndExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function BitwiseAndExpression(t, x) {\n        var n, n2;\n\n        n = EqualityExpression(t, x);\n        while (t.match(BITWISE_AND)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(EqualityExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function EqualityExpression(t, x) {\n        var n, n2;\n\n        n = RelationalExpression(t, x);\n        while (t.match(EQ) || t.match(NE) ||\n               t.match(STRICT_EQ) || t.match(STRICT_NE)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(RelationalExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function RelationalExpression(t, x) {\n        var n, n2;\n\n        /*\n         * Uses of the in operator in shiftExprs are always unambiguous,\n         * so unset the flag that prohibits recognizing it.\n         */\n        var x2 = x.update({ inForLoopInit: false });\n        n = ShiftExpression(t, x2);\n        while ((t.match(LT) || t.match(LE) || t.match(GE) || t.match(GT) ||\n               (!x.inForLoopInit && t.match(IN)) ||\n               t.match(INSTANCEOF))) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(ShiftExpression(t, x2));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ShiftExpression(t, x) {\n        var n, n2;\n\n        n = AddExpression(t, x);\n        while (t.match(LSH) || t.match(RSH) || t.match(URSH)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(AddExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function AddExpression(t, x) {\n        var n, n2;\n\n        n = MultiplyExpression(t, x);\n        while (t.match(PLUS) || t.match(MINUS)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(MultiplyExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function MultiplyExpression(t, x) {\n        var n, n2;\n\n        n = UnaryExpression(t, x);\n        while (t.match(MUL) || t.match(DIV) || t.match(MOD)) {\n            n2 = new Node(t);\n            n2.push(n);\n            n2.push(UnaryExpression(t, x));\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function UnaryExpression(t, x) {\n        var n, n2, tt;\n\n        switch (tt = t.get(true)) {\n          case DELETE: case VOID: case TYPEOF:\n          case NOT: case BITWISE_NOT: case PLUS: case MINUS:\n            if (tt === PLUS)\n                n = new Node(t, { type: UNARY_PLUS });\n            else if (tt === MINUS)\n                n = new Node(t, { type: UNARY_MINUS });\n            else\n                n = new Node(t);\n            n.push(UnaryExpression(t, x));\n            break;\n\n          case INCREMENT:\n          case DECREMENT:\n            // Prefix increment/decrement.\n            n = new Node(t);\n            n.push(MemberExpression(t, x, true));\n            break;\n\n          default:\n            t.unget();\n            n = MemberExpression(t, x, true);\n\n            // Don't look across a newline boundary for a postfix {in,de}crement.\n            if (t.tokens[(t.tokenIndex + t.lookahead - 1) & 3].lineno ===\n                t.lineno) {\n                if (t.match(INCREMENT) || t.match(DECREMENT)) {\n                    n2 = new Node(t, { postfix: true });\n                    n2.push(n);\n                    n = n2;\n                }\n            }\n            break;\n        }\n\n        return n;\n    }\n\n    function MemberExpression(t, x, allowCallSyntax) {\n        var n, n2, name, tt;\n\n        if (t.match(NEW)) {\n            n = new Node(t);\n            n.push(MemberExpression(t, x, false));\n            if (t.match(LEFT_PAREN)) {\n                n.type = NEW_WITH_ARGS;\n                n.push(ArgumentList(t, x));\n            }\n        } else {\n            n = PrimaryExpression(t, x);\n        }\n\n        while ((tt = t.get()) !== END) {\n            switch (tt) {\n              case DOT:\n                n2 = new Node(t);\n                n2.push(n);\n                t.mustMatch(IDENTIFIER);\n                n2.push(new Node(t));\n                break;\n\n              case LEFT_BRACKET:\n                n2 = new Node(t, { type: INDEX });\n                n2.push(n);\n                n2.push(Expression(t, x));\n                t.mustMatch(RIGHT_BRACKET);\n                break;\n\n              case LEFT_PAREN:\n                if (allowCallSyntax) {\n                    n2 = new Node(t, { type: CALL });\n                    n2.push(n);\n                    n2.push(ArgumentList(t, x));\n                    break;\n                }\n\n                // FALL THROUGH\n              default:\n                t.unget();\n                return n;\n            }\n\n            n = n2;\n        }\n\n        return n;\n    }\n\n    function ArgumentList(t, x) {\n        var n, n2;\n\n        n = new Node(t, { type: LIST });\n        if (t.match(RIGHT_PAREN, true))\n            return n;\n        do {\n            n2 = AssignExpression(t, x);\n            if (n2.type === YIELD && !n2.parenthesized && t.peek() === COMMA)\n                throw t.newSyntaxError(\"Yield expression must be parenthesized\");\n            if (t.match(FOR)) {\n                n2 = GeneratorExpression(t, x, n2);\n                if (n.children.length > 1 || t.peek(true) === COMMA)\n                    throw t.newSyntaxError(\"Generator expression must be parenthesized\");\n            }\n            n.push(n2);\n        } while (t.match(COMMA));\n        t.mustMatch(RIGHT_PAREN);\n\n        return n;\n    }\n\n    function PrimaryExpression(t, x) {\n        var n, n2, tt = t.get(true);\n\n        switch (tt) {\n          case FUNCTION:\n            n = FunctionDefinition(t, x, false, EXPRESSED_FORM);\n            break;\n\n          case LEFT_BRACKET:\n            n = new Node(t, { type: ARRAY_INIT });\n            while ((tt = t.peek(true)) !== RIGHT_BRACKET) {\n                if (tt === COMMA) {\n                    t.get();\n                    n.push(null);\n                    continue;\n                }\n                n.push(AssignExpression(t, x));\n                if (tt !== COMMA && !t.match(COMMA))\n                    break;\n            }\n\n            // If we matched exactly one element and got a FOR, we have an\n            // array comprehension.\n            if (n.children.length === 1 && t.match(FOR)) {\n                n2 = new Node(t, { type: ARRAY_COMP,\n                                   expression: n.children[0],\n                                   tail: ComprehensionTail(t, x) });\n                n = n2;\n            }\n            t.mustMatch(RIGHT_BRACKET);\n            break;\n\n          case LEFT_CURLY:\n            var id, fd;\n            n = new Node(t, { type: OBJECT_INIT });\n\n          object_init:\n            if (!t.match(RIGHT_CURLY)) {\n                do {\n                    tt = t.get();\n                    if ((t.token.value === \"get\" || t.token.value === \"set\") &&\n                        t.peek() === IDENTIFIER) {\n                        if (x.ecma3OnlyMode)\n                            throw t.newSyntaxError(\"Illegal property accessor\");\n                        n.push(FunctionDefinition(t, x, true, EXPRESSED_FORM));\n                    } else {\n                        switch (tt) {\n                          case IDENTIFIER: case NUMBER: case STRING:\n                            id = new Node(t, { type: IDENTIFIER });\n                            break;\n                          case RIGHT_CURLY:\n                            if (x.ecma3OnlyMode)\n                                throw t.newSyntaxError(\"Illegal trailing ,\");\n                            break object_init;\n                          default:\n                            if (t.token.value in definitions.keywords) {\n                                id = new Node(t, { type: IDENTIFIER });\n                                break;\n                            }\n                            throw t.newSyntaxError(\"Invalid property name\");\n                        }\n                        if (t.match(COLON)) {\n                            n2 = new Node(t, { type: PROPERTY_INIT });\n                            n2.push(id);\n                            n2.push(AssignExpression(t, x));\n                            n.push(n2);\n                        } else {\n                            // Support, e.g., |var {x, y} = o| as destructuring shorthand\n                            // for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.\n                            if (t.peek() !== COMMA && t.peek() !== RIGHT_CURLY)\n                                throw t.newSyntaxError(\"missing : after property\");\n                            n.push(id);\n                        }\n                    }\n                } while (t.match(COMMA));\n                t.mustMatch(RIGHT_CURLY);\n            }\n            break;\n\n          case LEFT_PAREN:\n            n = ParenExpression(t, x);\n            t.mustMatch(RIGHT_PAREN);\n            n.parenthesized = true;\n            break;\n\n          case LET:\n            n = LetBlock(t, x, false);\n            break;\n\n          case NULL: case THIS: case TRUE: case FALSE:\n          case IDENTIFIER: case NUMBER: case STRING: case REGEXP:\n            n = new Node(t);\n            break;\n\n          default:\n            throw t.newSyntaxError(\"missing operand\");\n            break;\n        }\n\n        return n;\n    }\n\n    /*\n     * parse :: (source, filename, line number) -> node\n     */\n    function parse(s, f, l) {\n        var t = new lexer.Tokenizer(s, f, l);\n        var n = Script(t, false);\n        if (!t.done)\n            throw t.newSyntaxError(\"Syntax error\");\n\n        return n;\n    }\n\n    /*\n     * parseStdin :: (source, {line number}) -> node\n     */\n    function parseStdin(s, ln) {\n        for (;;) {\n            try {\n                var t = new lexer.Tokenizer(s, \"stdin\", ln.value);\n                var n = Script(t, false);\n                ln.value = t.lineno;\n                return n;\n            } catch (e) {\n                if (!t.unexpectedEOF)\n                    throw e;\n                var more = readline();\n                if (!more)\n                    throw e;\n                s += \"\\n\" + more;\n            }\n        }\n    }\n\n    return {\n        parse: parse,\n        parseStdin: parseStdin,\n        Node: Node,\n        DECLARED_FORM: DECLARED_FORM,\n        EXPRESSED_FORM: EXPRESSED_FORM,\n        STATEMENT_FORM: STATEMENT_FORM,\n        Tokenizer: lexer.Tokenizer,\n        FunctionDefinition: FunctionDefinition\n    };\n\n}());\n\nvar exports = {\n  definitions: Narcissus.definitions,\n  lexer: Narcissus.lexer,\n  parser: Narcissus.parser\n};\n\nif (typeof module != 'undefined') {\n  module.exports = exports;\n};\n\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/lib/node_ext.js.coffee",
      "relativePath": "lib/node_ext.js.coffee",
      "basename": "node_ext",
      "outBasename": "node_ext",
      "extension": "coffee",
      "outExtension": "js",
      "extensions": [
        "js",
        "coffee"
      ],
      "filename": "node_ext.js.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/lib",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/lib/node_ext.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/lib",
      "outFilename": "node_ext.js",
      "relativeOutPath": "lib/node_ext.js",
      "relativeDirPath": "lib",
      "relativeOutDirPath": "lib",
      "relativeBase": "lib/node_ext",
      "relativeOutBase": "lib/node_ext",
      "contentType": "application/octet-stream",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:18.287Z",
      "rtime": "2014-01-20T02:05:25.513Z",
      "wtime": "2014-01-20T02:05:25.719Z",
      "exists": true,
      "encoding": "utf8",
      "source": "narcissus = require('./narcissus_packed')\n_         = require('underscore')\n\ntokens = narcissus.definitions.tokens\nparser = narcissus.parser\nNode   = parser.Node\n\n# ## Narcissus node helpers\n# Some extensions to the Node class to make things easier later on.\n\n# `left() / right()`\n# These are aliases for the first and last child.\n# Often helpful for things like binary operators.\nNode::left  = -> @children[0]\nNode::right = -> @children[1]\nNode::last  = -> @children[@children.length-1]\n\n# `walk()`\n# Traverses down a node and it's children.\nNode::walk  = (options, fn, parent=null, list=null) ->\n  fn parent, @, list  if parent\n\n  if options.last\n    @last().walk options, fn, @  if @last()?\n\n  @thenPart.walk options, fn, @, 'thenPart'  if @thenPart?\n  @elsePart.walk options, fn, @, 'elsePart'  if @elsePart?\n\n  if @cases\n    _.each @cases, (item) ->\n      item.statements.walk options, fn, item, 'cases'\n\n# `clone()`\n# Clones a given node.\nNode::clone = (hash) ->\n  for i of @\n    continue  if i in ['tokenizer', 'length', 'filename']\n    hash[i] ?= @[i]\n\n  new Node(@tokenizer, hash)\n\n# `toHash()` + `inspect()`\n# For debugging\n\n\nNode::toHash = (done=[])->\n  hash = {}\n\n  toHash = (what) ->\n\n    return null  unless what\n    if what.toHash\n      if what in done\n        return \"--recursive #{what.id}--\"\n      what.id = done.push(what)\n      what.toHash(done)\n    else\n      what\n\n  hash.type = @typeName()\n  hash.src  = @src()\n\n  for i of @\n    continue  if i in ['filename', 'length', 'type', 'start', 'end', 'tokenizer' ]\n    continue  if typeof @[i] == 'function'\n    continue  unless @[i]\n\n    if @[i].constructor == Array\n      hash[i] = _.map(@[i], (item) -> toHash(item))\n\n    else\n      hash[i] = toHash(@[i])\n\n  hash\n\nNode::inspect = ->\n  JSON.stringify @toHash(), null, '  '\n\n# `src()`\n# Returns the source for the node.\nNode::src   = -> @tokenizer.source.substr(@start, @end-@start)\n\n# `typeName()`\n# Returns the typename in lowercase. (eg, 'function')\nNode::typeName = -> Types[@type]\n\n# `isA()`\n# Typename check.\nNode::isA = (what...) -> Types[@type] in what\n\n# ## Types\n# The `Types` global object contains a map of Narcissus type numbers to type\n# names. It probably looks like:\n#\n#     Types = { ...\n#       '42': 'script',\n#       '43': 'block',\n#       '44': 'label',\n#       '45': 'for_in',\n#       ...\n#     }\n\nTypes = do ->\n  dict = {}\n  last = 0\n  for i of tokens\n    if typeof tokens[i] == 'number'\n      dict[tokens[i]] = i.toLowerCase()\n      last = tokens[i]\n\n  # Now extend it with a few more\n  dict[++last] = 'call_statement'\n  dict[++last] = 'existence_check'\n\n  dict\n\n# Inverse of Types\nTypenames = do ->\n  dict = {}\n  for i of Types\n    dict[Types[i]] = i\n\n  dict\n\n# ## Unsupported Error exception\n\n@NodeExt = exports = {Types, Typenames, Node}\nmodule.exports = exports  if module?\n\n",
      "content": "narcissus = require('./narcissus_packed')\n_         = require('underscore')\n\ntokens = narcissus.definitions.tokens\nparser = narcissus.parser\nNode   = parser.Node\n\n# ## Narcissus node helpers\n# Some extensions to the Node class to make things easier later on.\n\n# `left() / right()`\n# These are aliases for the first and last child.\n# Often helpful for things like binary operators.\nNode::left  = -> @children[0]\nNode::right = -> @children[1]\nNode::last  = -> @children[@children.length-1]\n\n# `walk()`\n# Traverses down a node and it's children.\nNode::walk  = (options, fn, parent=null, list=null) ->\n  fn parent, @, list  if parent\n\n  if options.last\n    @last().walk options, fn, @  if @last()?\n\n  @thenPart.walk options, fn, @, 'thenPart'  if @thenPart?\n  @elsePart.walk options, fn, @, 'elsePart'  if @elsePart?\n\n  if @cases\n    _.each @cases, (item) ->\n      item.statements.walk options, fn, item, 'cases'\n\n# `clone()`\n# Clones a given node.\nNode::clone = (hash) ->\n  for i of @\n    continue  if i in ['tokenizer', 'length', 'filename']\n    hash[i] ?= @[i]\n\n  new Node(@tokenizer, hash)\n\n# `toHash()` + `inspect()`\n# For debugging\n\n\nNode::toHash = (done=[])->\n  hash = {}\n\n  toHash = (what) ->\n\n    return null  unless what\n    if what.toHash\n      if what in done\n        return \"--recursive #{what.id}--\"\n      what.id = done.push(what)\n      what.toHash(done)\n    else\n      what\n\n  hash.type = @typeName()\n  hash.src  = @src()\n\n  for i of @\n    continue  if i in ['filename', 'length', 'type', 'start', 'end', 'tokenizer' ]\n    continue  if typeof @[i] == 'function'\n    continue  unless @[i]\n\n    if @[i].constructor == Array\n      hash[i] = _.map(@[i], (item) -> toHash(item))\n\n    else\n      hash[i] = toHash(@[i])\n\n  hash\n\nNode::inspect = ->\n  JSON.stringify @toHash(), null, '  '\n\n# `src()`\n# Returns the source for the node.\nNode::src   = -> @tokenizer.source.substr(@start, @end-@start)\n\n# `typeName()`\n# Returns the typename in lowercase. (eg, 'function')\nNode::typeName = -> Types[@type]\n\n# `isA()`\n# Typename check.\nNode::isA = (what...) -> Types[@type] in what\n\n# ## Types\n# The `Types` global object contains a map of Narcissus type numbers to type\n# names. It probably looks like:\n#\n#     Types = { ...\n#       '42': 'script',\n#       '43': 'block',\n#       '44': 'label',\n#       '45': 'for_in',\n#       ...\n#     }\n\nTypes = do ->\n  dict = {}\n  last = 0\n  for i of tokens\n    if typeof tokens[i] == 'number'\n      dict[tokens[i]] = i.toLowerCase()\n      last = tokens[i]\n\n  # Now extend it with a few more\n  dict[++last] = 'call_statement'\n  dict[++last] = 'existence_check'\n\n  dict\n\n# Inverse of Types\nTypenames = do ->\n  dict = {}\n  for i of Types\n    dict[Types[i]] = i\n\n  dict\n\n# ## Unsupported Error exception\n\n@NodeExt = exports = {Types, Typenames, Node}\nmodule.exports = exports  if module?\n\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "node_ext.js",
      "date": "2014-01-20T02:05:18.287Z",
      "slug": "lib-node-ext",
      "url": "/lib/node_ext.js",
      "urls": [
        "/lib/node_ext.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "narcissus = require('./narcissus_packed')\n_         = require('underscore')\n\ntokens = narcissus.definitions.tokens\nparser = narcissus.parser\nNode   = parser.Node\n\n# ## Narcissus node helpers\n# Some extensions to the Node class to make things easier later on.\n\n# `left() / right()`\n# These are aliases for the first and last child.\n# Often helpful for things like binary operators.\nNode::left  = -> @children[0]\nNode::right = -> @children[1]\nNode::last  = -> @children[@children.length-1]\n\n# `walk()`\n# Traverses down a node and it's children.\nNode::walk  = (options, fn, parent=null, list=null) ->\n  fn parent, @, list  if parent\n\n  if options.last\n    @last().walk options, fn, @  if @last()?\n\n  @thenPart.walk options, fn, @, 'thenPart'  if @thenPart?\n  @elsePart.walk options, fn, @, 'elsePart'  if @elsePart?\n\n  if @cases\n    _.each @cases, (item) ->\n      item.statements.walk options, fn, item, 'cases'\n\n# `clone()`\n# Clones a given node.\nNode::clone = (hash) ->\n  for i of @\n    continue  if i in ['tokenizer', 'length', 'filename']\n    hash[i] ?= @[i]\n\n  new Node(@tokenizer, hash)\n\n# `toHash()` + `inspect()`\n# For debugging\n\n\nNode::toHash = (done=[])->\n  hash = {}\n\n  toHash = (what) ->\n\n    return null  unless what\n    if what.toHash\n      if what in done\n        return \"--recursive #{what.id}--\"\n      what.id = done.push(what)\n      what.toHash(done)\n    else\n      what\n\n  hash.type = @typeName()\n  hash.src  = @src()\n\n  for i of @\n    continue  if i in ['filename', 'length', 'type', 'start', 'end', 'tokenizer' ]\n    continue  if typeof @[i] == 'function'\n    continue  unless @[i]\n\n    if @[i].constructor == Array\n      hash[i] = _.map(@[i], (item) -> toHash(item))\n\n    else\n      hash[i] = toHash(@[i])\n\n  hash\n\nNode::inspect = ->\n  JSON.stringify @toHash(), null, '  '\n\n# `src()`\n# Returns the source for the node.\nNode::src   = -> @tokenizer.source.substr(@start, @end-@start)\n\n# `typeName()`\n# Returns the typename in lowercase. (eg, 'function')\nNode::typeName = -> Types[@type]\n\n# `isA()`\n# Typename check.\nNode::isA = (what...) -> Types[@type] in what\n\n# ## Types\n# The `Types` global object contains a map of Narcissus type numbers to type\n# names. It probably looks like:\n#\n#     Types = { ...\n#       '42': 'script',\n#       '43': 'block',\n#       '44': 'label',\n#       '45': 'for_in',\n#       ...\n#     }\n\nTypes = do ->\n  dict = {}\n  last = 0\n  for i of tokens\n    if typeof tokens[i] == 'number'\n      dict[tokens[i]] = i.toLowerCase()\n      last = tokens[i]\n\n  # Now extend it with a few more\n  dict[++last] = 'call_statement'\n  dict[++last] = 'existence_check'\n\n  dict\n\n# Inverse of Types\nTypenames = do ->\n  dict = {}\n  for i of Types\n    dict[Types[i]] = i\n\n  dict\n\n# ## Unsupported Error exception\n\n@NodeExt = exports = {Types, Typenames, Node}\nmodule.exports = exports  if module?\n\n",
      "rendered": true,
      "contentRendered": "(function() {\n  var Node, Typenames, Types, exports, narcissus, parser, tokens, _,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice;\n\n  narcissus = require('./narcissus_packed');\n\n  _ = require('underscore');\n\n  tokens = narcissus.definitions.tokens;\n\n  parser = narcissus.parser;\n\n  Node = parser.Node;\n\n  Node.prototype.left = function() {\n    return this.children[0];\n  };\n\n  Node.prototype.right = function() {\n    return this.children[1];\n  };\n\n  Node.prototype.last = function() {\n    return this.children[this.children.length - 1];\n  };\n\n  Node.prototype.walk = function(options, fn, parent, list) {\n    if (parent == null) {\n      parent = null;\n    }\n    if (list == null) {\n      list = null;\n    }\n    if (parent) {\n      fn(parent, this, list);\n    }\n    if (options.last) {\n      if (this.last() != null) {\n        this.last().walk(options, fn, this);\n      }\n    }\n    if (this.thenPart != null) {\n      this.thenPart.walk(options, fn, this, 'thenPart');\n    }\n    if (this.elsePart != null) {\n      this.elsePart.walk(options, fn, this, 'elsePart');\n    }\n    if (this.cases) {\n      return _.each(this.cases, function(item) {\n        return item.statements.walk(options, fn, item, 'cases');\n      });\n    }\n  };\n\n  Node.prototype.clone = function(hash) {\n    var i;\n    for (i in this) {\n      if (i === 'tokenizer' || i === 'length' || i === 'filename') {\n        continue;\n      }\n      if (hash[i] == null) {\n        hash[i] = this[i];\n      }\n    }\n    return new Node(this.tokenizer, hash);\n  };\n\n  Node.prototype.toHash = function(done) {\n    var hash, i, toHash;\n    if (done == null) {\n      done = [];\n    }\n    hash = {};\n    toHash = function(what) {\n      if (!what) {\n        return null;\n      }\n      if (what.toHash) {\n        if (__indexOf.call(done, what) >= 0) {\n          return \"--recursive \" + what.id + \"--\";\n        }\n        what.id = done.push(what);\n        return what.toHash(done);\n      } else {\n        return what;\n      }\n    };\n    hash.type = this.typeName();\n    hash.src = this.src();\n    for (i in this) {\n      if (i === 'filename' || i === 'length' || i === 'type' || i === 'start' || i === 'end' || i === 'tokenizer') {\n        continue;\n      }\n      if (typeof this[i] === 'function') {\n        continue;\n      }\n      if (!this[i]) {\n        continue;\n      }\n      if (this[i].constructor === Array) {\n        hash[i] = _.map(this[i], function(item) {\n          return toHash(item);\n        });\n      } else {\n        hash[i] = toHash(this[i]);\n      }\n    }\n    return hash;\n  };\n\n  Node.prototype.inspect = function() {\n    return JSON.stringify(this.toHash(), null, '  ');\n  };\n\n  Node.prototype.src = function() {\n    return this.tokenizer.source.substr(this.start, this.end - this.start);\n  };\n\n  Node.prototype.typeName = function() {\n    return Types[this.type];\n  };\n\n  Node.prototype.isA = function() {\n    var what, _ref;\n    what = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return _ref = Types[this.type], __indexOf.call(what, _ref) >= 0;\n  };\n\n  Types = (function() {\n    var dict, i, last;\n    dict = {};\n    last = 0;\n    for (i in tokens) {\n      if (typeof tokens[i] === 'number') {\n        dict[tokens[i]] = i.toLowerCase();\n        last = tokens[i];\n      }\n    }\n    dict[++last] = 'call_statement';\n    dict[++last] = 'existence_check';\n    return dict;\n  })();\n\n  Typenames = (function() {\n    var dict, i;\n    dict = {};\n    for (i in Types) {\n      dict[Types[i]] = i;\n    }\n    return dict;\n  })();\n\n  this.NodeExt = exports = {\n    Types: Types,\n    Typenames: Typenames,\n    Node: Node\n  };\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = exports;\n  }\n\n}).call(this);\n",
      "contentRenderedWithoutLayouts": "(function() {\n  var Node, Typenames, Types, exports, narcissus, parser, tokens, _,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice;\n\n  narcissus = require('./narcissus_packed');\n\n  _ = require('underscore');\n\n  tokens = narcissus.definitions.tokens;\n\n  parser = narcissus.parser;\n\n  Node = parser.Node;\n\n  Node.prototype.left = function() {\n    return this.children[0];\n  };\n\n  Node.prototype.right = function() {\n    return this.children[1];\n  };\n\n  Node.prototype.last = function() {\n    return this.children[this.children.length - 1];\n  };\n\n  Node.prototype.walk = function(options, fn, parent, list) {\n    if (parent == null) {\n      parent = null;\n    }\n    if (list == null) {\n      list = null;\n    }\n    if (parent) {\n      fn(parent, this, list);\n    }\n    if (options.last) {\n      if (this.last() != null) {\n        this.last().walk(options, fn, this);\n      }\n    }\n    if (this.thenPart != null) {\n      this.thenPart.walk(options, fn, this, 'thenPart');\n    }\n    if (this.elsePart != null) {\n      this.elsePart.walk(options, fn, this, 'elsePart');\n    }\n    if (this.cases) {\n      return _.each(this.cases, function(item) {\n        return item.statements.walk(options, fn, item, 'cases');\n      });\n    }\n  };\n\n  Node.prototype.clone = function(hash) {\n    var i;\n    for (i in this) {\n      if (i === 'tokenizer' || i === 'length' || i === 'filename') {\n        continue;\n      }\n      if (hash[i] == null) {\n        hash[i] = this[i];\n      }\n    }\n    return new Node(this.tokenizer, hash);\n  };\n\n  Node.prototype.toHash = function(done) {\n    var hash, i, toHash;\n    if (done == null) {\n      done = [];\n    }\n    hash = {};\n    toHash = function(what) {\n      if (!what) {\n        return null;\n      }\n      if (what.toHash) {\n        if (__indexOf.call(done, what) >= 0) {\n          return \"--recursive \" + what.id + \"--\";\n        }\n        what.id = done.push(what);\n        return what.toHash(done);\n      } else {\n        return what;\n      }\n    };\n    hash.type = this.typeName();\n    hash.src = this.src();\n    for (i in this) {\n      if (i === 'filename' || i === 'length' || i === 'type' || i === 'start' || i === 'end' || i === 'tokenizer') {\n        continue;\n      }\n      if (typeof this[i] === 'function') {\n        continue;\n      }\n      if (!this[i]) {\n        continue;\n      }\n      if (this[i].constructor === Array) {\n        hash[i] = _.map(this[i], function(item) {\n          return toHash(item);\n        });\n      } else {\n        hash[i] = toHash(this[i]);\n      }\n    }\n    return hash;\n  };\n\n  Node.prototype.inspect = function() {\n    return JSON.stringify(this.toHash(), null, '  ');\n  };\n\n  Node.prototype.src = function() {\n    return this.tokenizer.source.substr(this.start, this.end - this.start);\n  };\n\n  Node.prototype.typeName = function() {\n    return Types[this.type];\n  };\n\n  Node.prototype.isA = function() {\n    var what, _ref;\n    what = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return _ref = Types[this.type], __indexOf.call(what, _ref) >= 0;\n  };\n\n  Types = (function() {\n    var dict, i, last;\n    dict = {};\n    last = 0;\n    for (i in tokens) {\n      if (typeof tokens[i] === 'number') {\n        dict[tokens[i]] = i.toLowerCase();\n        last = tokens[i];\n      }\n    }\n    dict[++last] = 'call_statement';\n    dict[++last] = 'existence_check';\n    return dict;\n  })();\n\n  Typenames = (function() {\n    var dict, i;\n    dict = {};\n    for (i in Types) {\n      dict[Types[i]] = i;\n    }\n    return dict;\n  })();\n\n  this.NodeExt = exports = {\n    Types: Types,\n    Typenames: Typenames,\n    Node: Node\n  };\n\n  if (typeof module !== \"undefined\" && module !== null) {\n    module.exports = exports;\n  }\n\n}).call(this);\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/everything.js.coffee",
      "relativePath": "test/everything.js.coffee",
      "basename": "everything",
      "outBasename": "everything",
      "extension": "coffee",
      "outExtension": "js",
      "extensions": [
        "js",
        "coffee"
      ],
      "filename": "everything.js.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/everything.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test",
      "outFilename": "everything.js",
      "relativeOutPath": "test/everything.js",
      "relativeDirPath": "test",
      "relativeOutDirPath": "test",
      "relativeBase": "test/everything",
      "relativeOutBase": "test/everything",
      "contentType": "application/octet-stream",
      "outContentType": "application/javascript",
      "ctime": "2014-01-16T09:00:29.000Z",
      "mtime": "2014-01-20T02:05:18.303Z",
      "rtime": "2014-01-20T02:05:25.518Z",
      "wtime": "2014-01-20T02:05:25.721Z",
      "exists": true,
      "encoding": "utf8",
      "source": "js2c = require('../lib/js2coffee')\nglob = require('glob').globSync or require('glob').sync\nfs = require('fs')\n_ = require('underscore')\njoe = require('joe')\nassert = require('assert')\nansidiff = require('ansidiff')\n\nbuild = js2c.build\n\nfiles = glob(__dirname+'/features/*.js')\n\njoe.suite 'js2coffee', (suite,test) ->\n  _.each files, (f) ->\n    test f, ->\n\n      ###\n        to pass build options for you test, your first line should look like this:\n        // OPTIONS: {\"single_quotes\": true}\n      ###\n\n      # default options\n      options = {no_comments: true}\n      optionsPattern = /^\\/\\/\\s*OPTIONS:\\s*(.*)/\n      input = fs.readFileSync(f).toString().trim()\n      matches = input.match optionsPattern\n      if matches?\n        try\n          opts = JSON.parse(matches[1])\n          _(options).extend opts # merge default options to parsed opts\n        catch err\n          console.error \"Could not parse options for test file: #{f}\"\n          console.error err.message\n          throw err\n\n      output = build(input, options).trim()\n      expected = fs.readFileSync(f.replace('.js', '.coffee')).toString().trim()\n\n      if output isnt expected\n        # show colored diff\n        console.error ansidiff.lines output, expected\n\n      assert.equal(output, expected)\n",
      "content": "js2c = require('../lib/js2coffee')\nglob = require('glob').globSync or require('glob').sync\nfs = require('fs')\n_ = require('underscore')\njoe = require('joe')\nassert = require('assert')\nansidiff = require('ansidiff')\n\nbuild = js2c.build\n\nfiles = glob(__dirname+'/features/*.js')\n\njoe.suite 'js2coffee', (suite,test) ->\n  _.each files, (f) ->\n    test f, ->\n\n      ###\n        to pass build options for you test, your first line should look like this:\n        // OPTIONS: {\"single_quotes\": true}\n      ###\n\n      # default options\n      options = {no_comments: true}\n      optionsPattern = /^\\/\\/\\s*OPTIONS:\\s*(.*)/\n      input = fs.readFileSync(f).toString().trim()\n      matches = input.match optionsPattern\n      if matches?\n        try\n          opts = JSON.parse(matches[1])\n          _(options).extend opts # merge default options to parsed opts\n        catch err\n          console.error \"Could not parse options for test file: #{f}\"\n          console.error err.message\n          throw err\n\n      output = build(input, options).trim()\n      expected = fs.readFileSync(f.replace('.js', '.coffee')).toString().trim()\n\n      if output isnt expected\n        # show colored diff\n        console.error ansidiff.lines output, expected\n\n      assert.equal(output, expected)\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "everything.js",
      "date": "2014-01-20T02:05:18.303Z",
      "slug": "test-everything",
      "url": "/test/everything.js",
      "urls": [
        "/test/everything.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "js2c = require('../lib/js2coffee')\nglob = require('glob').globSync or require('glob').sync\nfs = require('fs')\n_ = require('underscore')\njoe = require('joe')\nassert = require('assert')\nansidiff = require('ansidiff')\n\nbuild = js2c.build\n\nfiles = glob(__dirname+'/features/*.js')\n\njoe.suite 'js2coffee', (suite,test) ->\n  _.each files, (f) ->\n    test f, ->\n\n      ###\n        to pass build options for you test, your first line should look like this:\n        // OPTIONS: {\"single_quotes\": true}\n      ###\n\n      # default options\n      options = {no_comments: true}\n      optionsPattern = /^\\/\\/\\s*OPTIONS:\\s*(.*)/\n      input = fs.readFileSync(f).toString().trim()\n      matches = input.match optionsPattern\n      if matches?\n        try\n          opts = JSON.parse(matches[1])\n          _(options).extend opts # merge default options to parsed opts\n        catch err\n          console.error \"Could not parse options for test file: #{f}\"\n          console.error err.message\n          throw err\n\n      output = build(input, options).trim()\n      expected = fs.readFileSync(f.replace('.js', '.coffee')).toString().trim()\n\n      if output isnt expected\n        # show colored diff\n        console.error ansidiff.lines output, expected\n\n      assert.equal(output, expected)\n",
      "rendered": true,
      "contentRendered": "(function() {\n  var ansidiff, assert, build, files, fs, glob, joe, js2c, _;\n\n  js2c = require('../lib/js2coffee');\n\n  glob = require('glob').globSync || require('glob').sync;\n\n  fs = require('fs');\n\n  _ = require('underscore');\n\n  joe = require('joe');\n\n  assert = require('assert');\n\n  ansidiff = require('ansidiff');\n\n  build = js2c.build;\n\n  files = glob(__dirname + '/features/*.js');\n\n  joe.suite('js2coffee', function(suite, test) {\n    return _.each(files, function(f) {\n      return test(f, function() {\n        /*\n          to pass build options for you test, your first line should look like this:\n          // OPTIONS: {\"single_quotes\": true}\n        */\n\n        var err, expected, input, matches, options, optionsPattern, opts, output;\n        options = {\n          no_comments: true\n        };\n        optionsPattern = /^\\/\\/\\s*OPTIONS:\\s*(.*)/;\n        input = fs.readFileSync(f).toString().trim();\n        matches = input.match(optionsPattern);\n        if (matches != null) {\n          try {\n            opts = JSON.parse(matches[1]);\n            _(options).extend(opts);\n          } catch (_error) {\n            err = _error;\n            console.error(\"Could not parse options for test file: \" + f);\n            console.error(err.message);\n            throw err;\n          }\n        }\n        output = build(input, options).trim();\n        expected = fs.readFileSync(f.replace('.js', '.coffee')).toString().trim();\n        if (output !== expected) {\n          console.error(ansidiff.lines(output, expected));\n        }\n        return assert.equal(output, expected);\n      });\n    });\n  });\n\n}).call(this);\n",
      "contentRenderedWithoutLayouts": "(function() {\n  var ansidiff, assert, build, files, fs, glob, joe, js2c, _;\n\n  js2c = require('../lib/js2coffee');\n\n  glob = require('glob').globSync || require('glob').sync;\n\n  fs = require('fs');\n\n  _ = require('underscore');\n\n  joe = require('joe');\n\n  assert = require('assert');\n\n  ansidiff = require('ansidiff');\n\n  build = js2c.build;\n\n  files = glob(__dirname + '/features/*.js');\n\n  joe.suite('js2coffee', function(suite, test) {\n    return _.each(files, function(f) {\n      return test(f, function() {\n        /*\n          to pass build options for you test, your first line should look like this:\n          // OPTIONS: {\"single_quotes\": true}\n        */\n\n        var err, expected, input, matches, options, optionsPattern, opts, output;\n        options = {\n          no_comments: true\n        };\n        optionsPattern = /^\\/\\/\\s*OPTIONS:\\s*(.*)/;\n        input = fs.readFileSync(f).toString().trim();\n        matches = input.match(optionsPattern);\n        if (matches != null) {\n          try {\n            opts = JSON.parse(matches[1]);\n            _(options).extend(opts);\n          } catch (_error) {\n            err = _error;\n            console.error(\"Could not parse options for test file: \" + f);\n            console.error(err.message);\n            throw err;\n          }\n        }\n        output = build(input, options).trim();\n        expected = fs.readFileSync(f.replace('.js', '.coffee')).toString().trim();\n        if (output !== expected) {\n          console.error(ansidiff.lines(output, expected));\n        }\n        return assert.equal(output, expected);\n      });\n    });\n  });\n\n}).call(this);\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/anon_invocation.coffee",
      "relativePath": "test/features/anon_invocation.coffee",
      "basename": "anon_invocation",
      "outBasename": "anon_invocation",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "anon_invocation.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/anon_invocation.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "anon_invocation.coffee",
      "relativeOutPath": "test/features/anon_invocation.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/anon_invocation",
      "relativeOutBase": "test/features/anon_invocation",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.671Z",
      "rtime": "2014-01-20T02:05:24.547Z",
      "wtime": "2014-01-20T02:05:25.725Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(($) ->\n  $\n) jQuery\n(($) ->\n  $\n)()\n",
      "content": "(($) ->\n  $\n) jQuery\n(($) ->\n  $\n)()\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "anon_invocation.coffee",
      "date": "2014-01-20T02:05:19.671Z",
      "slug": "test-features-anon-invocation",
      "url": "/test/features/anon_invocation.coffee",
      "urls": [
        "/test/features/anon_invocation.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(($) ->\n  $\n) jQuery\n(($) ->\n  $\n)()\n",
      "rendered": true,
      "contentRendered": "(($) ->\n  $\n) jQuery\n(($) ->\n  $\n)()\n",
      "contentRenderedWithoutLayouts": "(($) ->\n  $\n) jQuery\n(($) ->\n  $\n)()\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/anon_invocation.js",
      "relativePath": "test/features/anon_invocation.js",
      "basename": "anon_invocation",
      "outBasename": "anon_invocation",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "anon_invocation.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/anon_invocation.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "anon_invocation.js",
      "relativeOutPath": "test/features/anon_invocation.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/anon_invocation",
      "relativeOutBase": "test/features/anon_invocation",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:19.701Z",
      "rtime": "2014-01-20T02:05:24.552Z",
      "wtime": "2014-01-20T02:05:25.729Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(function ($) { return $; }(jQuery));\n(function ($) { return $; }());\n",
      "content": "(function ($) { return $; }(jQuery));\n(function ($) { return $; }());\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "anon_invocation.js",
      "date": "2014-01-20T02:05:19.701Z",
      "slug": "test-features-anon-invocation",
      "url": "/test/features/anon_invocation.js",
      "urls": [
        "/test/features/anon_invocation.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(function ($) { return $; }(jQuery));\n(function ($) { return $; }());\n",
      "rendered": true,
      "contentRendered": "(function ($) { return $; }(jQuery));\n(function ($) { return $; }());\n",
      "contentRenderedWithoutLayouts": "(function ($) { return $; }(jQuery));\n(function ($) { return $; }());\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/array_literals.coffee",
      "relativePath": "test/features/array_literals.coffee",
      "basename": "array_literals",
      "outBasename": "array_literals",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "array_literals.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/array_literals.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "array_literals.coffee",
      "relativeOutPath": "test/features/array_literals.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/array_literals",
      "relativeOutBase": "test/features/array_literals",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.726Z",
      "rtime": "2014-01-20T02:05:24.557Z",
      "wtime": "2014-01-20T02:05:25.738Z",
      "exists": true,
      "encoding": "utf8",
      "source": "arr1 = []\narr2 = [\n  1\n  3\n  4\n]\nconsole.log arr2[1][0] is [4]\n",
      "content": "arr1 = []\narr2 = [\n  1\n  3\n  4\n]\nconsole.log arr2[1][0] is [4]\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "array_literals.coffee",
      "date": "2014-01-20T02:05:19.726Z",
      "slug": "test-features-array-literals",
      "url": "/test/features/array_literals.coffee",
      "urls": [
        "/test/features/array_literals.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "arr1 = []\narr2 = [\n  1\n  3\n  4\n]\nconsole.log arr2[1][0] is [4]\n",
      "rendered": true,
      "contentRendered": "arr1 = []\narr2 = [\n  1\n  3\n  4\n]\nconsole.log arr2[1][0] is [4]\n",
      "contentRenderedWithoutLayouts": "arr1 = []\narr2 = [\n  1\n  3\n  4\n]\nconsole.log arr2[1][0] is [4]\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/array_literals.js",
      "relativePath": "test/features/array_literals.js",
      "basename": "array_literals",
      "outBasename": "array_literals",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "array_literals.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/array_literals.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "array_literals.js",
      "relativeOutPath": "test/features/array_literals.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/array_literals",
      "relativeOutBase": "test/features/array_literals",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.754Z",
      "rtime": "2014-01-20T02:05:24.562Z",
      "wtime": "2014-01-20T02:05:25.736Z",
      "exists": true,
      "encoding": "utf8",
      "source": "var arr1 = [];\nvar arr2 = [1,3,4];\nconsole.log(arr2[1][0] == [4]);\n",
      "content": "var arr1 = [];\nvar arr2 = [1,3,4];\nconsole.log(arr2[1][0] == [4]);\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "array_literals.js",
      "date": "2014-01-20T02:05:19.754Z",
      "slug": "test-features-array-literals",
      "url": "/test/features/array_literals.js",
      "urls": [
        "/test/features/array_literals.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "var arr1 = [];\nvar arr2 = [1,3,4];\nconsole.log(arr2[1][0] == [4]);\n",
      "rendered": true,
      "contentRendered": "var arr1 = [];\nvar arr2 = [1,3,4];\nconsole.log(arr2[1][0] == [4]);\n",
      "contentRenderedWithoutLayouts": "var arr1 = [];\nvar arr2 = [1,3,4];\nconsole.log(arr2[1][0] == [4]);\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/assign.coffee",
      "relativePath": "test/features/assign.coffee",
      "basename": "assign",
      "outBasename": "assign",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "assign.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/assign.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "assign.coffee",
      "relativeOutPath": "test/features/assign.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/assign",
      "relativeOutBase": "test/features/assign",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.783Z",
      "rtime": "2014-01-20T02:05:24.567Z",
      "wtime": "2014-01-20T02:05:25.741Z",
      "exists": true,
      "encoding": "utf8",
      "source": "a = 2\na += 1\na -= 1\na *= 4\na /= 2\na %= 0\na <<= 0\na ^= 0\n",
      "content": "a = 2\na += 1\na -= 1\na *= 4\na /= 2\na %= 0\na <<= 0\na ^= 0\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "assign.coffee",
      "date": "2014-01-20T02:05:19.783Z",
      "slug": "test-features-assign",
      "url": "/test/features/assign.coffee",
      "urls": [
        "/test/features/assign.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "a = 2\na += 1\na -= 1\na *= 4\na /= 2\na %= 0\na <<= 0\na ^= 0\n",
      "rendered": true,
      "contentRendered": "a = 2\na += 1\na -= 1\na *= 4\na /= 2\na %= 0\na <<= 0\na ^= 0\n",
      "contentRenderedWithoutLayouts": "a = 2\na += 1\na -= 1\na *= 4\na /= 2\na %= 0\na <<= 0\na ^= 0\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/assign.js",
      "relativePath": "test/features/assign.js",
      "basename": "assign",
      "outBasename": "assign",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "assign.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/assign.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "assign.js",
      "relativeOutPath": "test/features/assign.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/assign",
      "relativeOutBase": "test/features/assign",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.802Z",
      "rtime": "2014-01-20T02:05:24.573Z",
      "wtime": "2014-01-20T02:05:25.749Z",
      "exists": true,
      "encoding": "utf8",
      "source": "a = 2;\na += 1;\na -= 1;\na *= 4;\na /= 2;\na %= 0;\na <<= 0;\na ^= 0;\n",
      "content": "a = 2;\na += 1;\na -= 1;\na *= 4;\na /= 2;\na %= 0;\na <<= 0;\na ^= 0;\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "assign.js",
      "date": "2014-01-20T02:05:19.802Z",
      "slug": "test-features-assign",
      "url": "/test/features/assign.js",
      "urls": [
        "/test/features/assign.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "a = 2;\na += 1;\na -= 1;\na *= 4;\na /= 2;\na %= 0;\na <<= 0;\na ^= 0;\n",
      "rendered": true,
      "contentRendered": "a = 2;\na += 1;\na -= 1;\na *= 4;\na /= 2;\na %= 0;\na <<= 0;\na ^= 0;\n",
      "contentRenderedWithoutLayouts": "a = 2;\na += 1;\na -= 1;\na *= 4;\na /= 2;\na %= 0;\na <<= 0;\na ^= 0;\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/assignment.coffee",
      "relativePath": "test/features/assignment.coffee",
      "basename": "assignment",
      "outBasename": "assignment",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "assignment.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/assignment.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "assignment.coffee",
      "relativeOutPath": "test/features/assignment.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/assignment",
      "relativeOutBase": "test/features/assignment",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.822Z",
      "rtime": "2014-01-20T02:05:24.578Z",
      "wtime": "2014-01-20T02:05:25.747Z",
      "exists": true,
      "encoding": "utf8",
      "source": "off_ = 2\n",
      "content": "off_ = 2\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "assignment.coffee",
      "date": "2014-01-20T02:05:19.822Z",
      "slug": "test-features-assignment",
      "url": "/test/features/assignment.coffee",
      "urls": [
        "/test/features/assignment.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "off_ = 2\n",
      "rendered": true,
      "contentRendered": "off_ = 2\n",
      "contentRenderedWithoutLayouts": "off_ = 2\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/assignment.js",
      "relativePath": "test/features/assignment.js",
      "basename": "assignment",
      "outBasename": "assignment",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "assignment.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/assignment.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "assignment.js",
      "relativeOutPath": "test/features/assignment.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/assignment",
      "relativeOutBase": "test/features/assignment",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.838Z",
      "rtime": "2014-01-20T02:05:24.583Z",
      "wtime": "2014-01-20T02:05:25.755Z",
      "exists": true,
      "encoding": "utf8",
      "source": "off = 2",
      "content": "off = 2",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "assignment.js",
      "date": "2014-01-20T02:05:19.838Z",
      "slug": "test-features-assignment",
      "url": "/test/features/assignment.js",
      "urls": [
        "/test/features/assignment.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "off = 2",
      "rendered": true,
      "contentRendered": "off = 2",
      "contentRenderedWithoutLayouts": "off = 2",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/bitwise_shift.coffee",
      "relativePath": "test/features/bitwise_shift.coffee",
      "basename": "bitwise_shift",
      "outBasename": "bitwise_shift",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "bitwise_shift.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/bitwise_shift.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "bitwise_shift.coffee",
      "relativeOutPath": "test/features/bitwise_shift.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/bitwise_shift",
      "relativeOutBase": "test/features/bitwise_shift",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.861Z",
      "rtime": "2014-01-20T02:05:24.588Z",
      "wtime": "2014-01-20T02:05:25.759Z",
      "exists": true,
      "encoding": "utf8",
      "source": "value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16)\n",
      "content": "value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16)\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "bitwise_shift.coffee",
      "date": "2014-01-20T02:05:19.861Z",
      "slug": "test-features-bitwise-shift",
      "url": "/test/features/bitwise_shift.coffee",
      "urls": [
        "/test/features/bitwise_shift.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16)\n",
      "rendered": true,
      "contentRendered": "value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16)\n",
      "contentRenderedWithoutLayouts": "value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16)\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/bitwise_shift.js",
      "relativePath": "test/features/bitwise_shift.js",
      "basename": "bitwise_shift",
      "outBasename": "bitwise_shift",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "bitwise_shift.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/bitwise_shift.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "bitwise_shift.js",
      "relativeOutPath": "test/features/bitwise_shift.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/bitwise_shift",
      "relativeOutBase": "test/features/bitwise_shift",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.878Z",
      "rtime": "2014-01-20T02:05:24.593Z",
      "wtime": "2014-01-20T02:05:25.764Z",
      "exists": true,
      "encoding": "utf8",
      "source": "value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);\n",
      "content": "value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "bitwise_shift.js",
      "date": "2014-01-20T02:05:19.878Z",
      "slug": "test-features-bitwise-shift",
      "url": "/test/features/bitwise_shift.js",
      "urls": [
        "/test/features/bitwise_shift.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);\n",
      "rendered": true,
      "contentRendered": "value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);\n",
      "contentRenderedWithoutLayouts": "value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/blank_lines.coffee",
      "relativePath": "test/features/blank_lines.coffee",
      "basename": "blank_lines",
      "outBasename": "blank_lines",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "blank_lines.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/blank_lines.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "blank_lines.coffee",
      "relativeOutPath": "test/features/blank_lines.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/blank_lines",
      "relativeOutBase": "test/features/blank_lines",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.909Z",
      "rtime": "2014-01-20T02:05:24.598Z",
      "wtime": "2014-01-20T02:05:25.767Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = 2\ny = 3\n",
      "content": "x = 2\ny = 3\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "blank_lines.coffee",
      "date": "2014-01-20T02:05:19.909Z",
      "slug": "test-features-blank-lines",
      "url": "/test/features/blank_lines.coffee",
      "urls": [
        "/test/features/blank_lines.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = 2\ny = 3\n",
      "rendered": true,
      "contentRendered": "x = 2\ny = 3\n",
      "contentRenderedWithoutLayouts": "x = 2\ny = 3\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/blank_lines.js",
      "relativePath": "test/features/blank_lines.js",
      "basename": "blank_lines",
      "outBasename": "blank_lines",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "blank_lines.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/blank_lines.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "blank_lines.js",
      "relativeOutPath": "test/features/blank_lines.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/blank_lines",
      "relativeOutBase": "test/features/blank_lines",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.930Z",
      "rtime": "2014-01-20T02:05:24.603Z",
      "wtime": "2014-01-20T02:05:25.771Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = 2\n\n\ny = 3",
      "content": "x = 2\n\n\ny = 3",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "blank_lines.js",
      "date": "2014-01-20T02:05:19.930Z",
      "slug": "test-features-blank-lines",
      "url": "/test/features/blank_lines.js",
      "urls": [
        "/test/features/blank_lines.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = 2\n\n\ny = 3",
      "rendered": true,
      "contentRendered": "x = 2\n\n\ny = 3",
      "contentRenderedWithoutLayouts": "x = 2\n\n\ny = 3",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/blank_regex.coffee",
      "relativePath": "test/features/blank_regex.coffee",
      "basename": "blank_regex",
      "outBasename": "blank_regex",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "blank_regex.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/blank_regex.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "blank_regex.coffee",
      "relativeOutPath": "test/features/blank_regex.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/blank_regex",
      "relativeOutBase": "test/features/blank_regex",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.952Z",
      "rtime": "2014-01-20T02:05:24.608Z",
      "wtime": "2014-01-20T02:05:25.773Z",
      "exists": true,
      "encoding": "utf8",
      "source": "RegExp(\" \", \"g\")\n",
      "content": "RegExp(\" \", \"g\")\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "blank_regex.coffee",
      "date": "2014-01-20T02:05:19.952Z",
      "slug": "test-features-blank-regex",
      "url": "/test/features/blank_regex.coffee",
      "urls": [
        "/test/features/blank_regex.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "RegExp(\" \", \"g\")\n",
      "rendered": true,
      "contentRendered": "RegExp(\" \", \"g\")\n",
      "contentRenderedWithoutLayouts": "RegExp(\" \", \"g\")\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/blank_regex.js",
      "relativePath": "test/features/blank_regex.js",
      "basename": "blank_regex",
      "outBasename": "blank_regex",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "blank_regex.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/blank_regex.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "blank_regex.js",
      "relativeOutPath": "test/features/blank_regex.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/blank_regex",
      "relativeOutBase": "test/features/blank_regex",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:19.972Z",
      "rtime": "2014-01-20T02:05:24.613Z",
      "wtime": "2014-01-20T02:05:25.777Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/ /g",
      "content": "/ /g",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "blank_regex.js",
      "date": "2014-01-20T02:05:19.972Z",
      "slug": "test-features-blank-regex",
      "url": "/test/features/blank_regex.js",
      "urls": [
        "/test/features/blank_regex.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "/ /g",
      "rendered": true,
      "contentRendered": "/ /g",
      "contentRenderedWithoutLayouts": "/ /g",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/call_statement.coffee",
      "relativePath": "test/features/call_statement.coffee",
      "basename": "call_statement",
      "outBasename": "call_statement",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "call_statement.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/call_statement.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "call_statement.coffee",
      "relativeOutPath": "test/features/call_statement.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/call_statement",
      "relativeOutBase": "test/features/call_statement",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:19.991Z",
      "rtime": "2014-01-20T02:05:24.619Z",
      "wtime": "2014-01-20T02:05:25.786Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = ->\n  alert 2 + 2\n  alert y(10)\n  return\n$.get\n  ajax: true\n  url: \"foo\"\n",
      "content": "x = ->\n  alert 2 + 2\n  alert y(10)\n  return\n$.get\n  ajax: true\n  url: \"foo\"\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "call_statement.coffee",
      "date": "2014-01-20T02:05:19.991Z",
      "slug": "test-features-call-statement",
      "url": "/test/features/call_statement.coffee",
      "urls": [
        "/test/features/call_statement.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = ->\n  alert 2 + 2\n  alert y(10)\n  return\n$.get\n  ajax: true\n  url: \"foo\"\n",
      "rendered": true,
      "contentRendered": "x = ->\n  alert 2 + 2\n  alert y(10)\n  return\n$.get\n  ajax: true\n  url: \"foo\"\n",
      "contentRenderedWithoutLayouts": "x = ->\n  alert 2 + 2\n  alert y(10)\n  return\n$.get\n  ajax: true\n  url: \"foo\"\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/call_statement.js",
      "relativePath": "test/features/call_statement.js",
      "basename": "call_statement",
      "outBasename": "call_statement",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "call_statement.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/call_statement.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "call_statement.js",
      "relativeOutPath": "test/features/call_statement.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/call_statement",
      "relativeOutBase": "test/features/call_statement",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.009Z",
      "rtime": "2014-01-20T02:05:24.624Z",
      "wtime": "2014-01-20T02:05:25.789Z",
      "exists": true,
      "encoding": "utf8",
      "source": "function x() {\n  alert(2+2);\n  alert(y(10));\n}\n\n$.get({\n  ajax: true,\n  url: 'foo'\n});\n",
      "content": "function x() {\n  alert(2+2);\n  alert(y(10));\n}\n\n$.get({\n  ajax: true,\n  url: 'foo'\n});\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "call_statement.js",
      "date": "2014-01-20T02:05:20.009Z",
      "slug": "test-features-call-statement",
      "url": "/test/features/call_statement.js",
      "urls": [
        "/test/features/call_statement.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "function x() {\n  alert(2+2);\n  alert(y(10));\n}\n\n$.get({\n  ajax: true,\n  url: 'foo'\n});\n",
      "rendered": true,
      "contentRendered": "function x() {\n  alert(2+2);\n  alert(y(10));\n}\n\n$.get({\n  ajax: true,\n  url: 'foo'\n});\n",
      "contentRenderedWithoutLayouts": "function x() {\n  alert(2+2);\n  alert(y(10));\n}\n\n$.get({\n  ajax: true,\n  url: 'foo'\n});\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/crlf.coffee",
      "relativePath": "test/features/crlf.coffee",
      "basename": "crlf",
      "outBasename": "crlf",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "crlf.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/crlf.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "crlf.coffee",
      "relativeOutPath": "test/features/crlf.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/crlf",
      "relativeOutBase": "test/features/crlf",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.033Z",
      "rtime": "2014-01-20T02:05:24.632Z",
      "wtime": "2014-01-20T02:05:25.795Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = 3\ny = 2\n",
      "content": "x = 3\ny = 2\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "crlf.coffee",
      "date": "2014-01-20T02:05:20.033Z",
      "slug": "test-features-crlf",
      "url": "/test/features/crlf.coffee",
      "urls": [
        "/test/features/crlf.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = 3\ny = 2\n",
      "rendered": true,
      "contentRendered": "x = 3\ny = 2\n",
      "contentRenderedWithoutLayouts": "x = 3\ny = 2\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/crlf.js",
      "relativePath": "test/features/crlf.js",
      "basename": "crlf",
      "outBasename": "crlf",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "crlf.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/crlf.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "crlf.js",
      "relativeOutPath": "test/features/crlf.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/crlf",
      "relativeOutBase": "test/features/crlf",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.059Z",
      "rtime": "2014-01-20T02:05:24.639Z",
      "wtime": "2014-01-20T02:05:25.799Z",
      "exists": true,
      "encoding": "utf8",
      "source": "var x = 3\nvar y = 2\n",
      "content": "var x = 3\nvar y = 2\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "crlf.js",
      "date": "2014-01-20T02:05:20.059Z",
      "slug": "test-features-crlf",
      "url": "/test/features/crlf.js",
      "urls": [
        "/test/features/crlf.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "var x = 3\nvar y = 2\n",
      "rendered": true,
      "contentRendered": "var x = 3\nvar y = 2\n",
      "contentRenderedWithoutLayouts": "var x = 3\nvar y = 2\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/debugger.coffee",
      "relativePath": "test/features/debugger.coffee",
      "basename": "debugger",
      "outBasename": "debugger",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "debugger.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/debugger.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "debugger.coffee",
      "relativeOutPath": "test/features/debugger.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/debugger",
      "relativeOutBase": "test/features/debugger",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.084Z",
      "rtime": "2014-01-20T02:05:24.648Z",
      "wtime": "2014-01-20T02:05:25.803Z",
      "exists": true,
      "encoding": "utf8",
      "source": "debugger\n",
      "content": "debugger\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "debugger.coffee",
      "date": "2014-01-20T02:05:20.084Z",
      "slug": "test-features-debugger",
      "url": "/test/features/debugger.coffee",
      "urls": [
        "/test/features/debugger.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "debugger\n",
      "rendered": true,
      "contentRendered": "debugger\n",
      "contentRenderedWithoutLayouts": "debugger\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/debugger.js",
      "relativePath": "test/features/debugger.js",
      "basename": "debugger",
      "outBasename": "debugger",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "debugger.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/debugger.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "debugger.js",
      "relativeOutPath": "test/features/debugger.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/debugger",
      "relativeOutBase": "test/features/debugger",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.109Z",
      "rtime": "2014-01-20T02:05:24.654Z",
      "wtime": "2014-01-20T02:05:25.809Z",
      "exists": true,
      "encoding": "utf8",
      "source": "debugger;\n",
      "content": "debugger;\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "debugger.js",
      "date": "2014-01-20T02:05:20.109Z",
      "slug": "test-features-debugger",
      "url": "/test/features/debugger.js",
      "urls": [
        "/test/features/debugger.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "debugger;\n",
      "rendered": true,
      "contentRendered": "debugger;\n",
      "contentRenderedWithoutLayouts": "debugger;\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/delete.coffee",
      "relativePath": "test/features/delete.coffee",
      "basename": "delete",
      "outBasename": "delete",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "delete.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/delete.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "delete.coffee",
      "relativeOutPath": "test/features/delete.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/delete",
      "relativeOutBase": "test/features/delete",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.132Z",
      "rtime": "2014-01-20T02:05:24.661Z",
      "wtime": "2014-01-20T02:05:25.813Z",
      "exists": true,
      "encoding": "utf8",
      "source": "delete a[x]\n\n",
      "content": "delete a[x]\n\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "delete.coffee",
      "date": "2014-01-20T02:05:20.132Z",
      "slug": "test-features-delete",
      "url": "/test/features/delete.coffee",
      "urls": [
        "/test/features/delete.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "delete a[x]\n\n",
      "rendered": true,
      "contentRendered": "delete a[x]\n\n",
      "contentRenderedWithoutLayouts": "delete a[x]\n\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/delete.js",
      "relativePath": "test/features/delete.js",
      "basename": "delete",
      "outBasename": "delete",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "delete.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/delete.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "delete.js",
      "relativeOutPath": "test/features/delete.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/delete",
      "relativeOutBase": "test/features/delete",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.151Z",
      "rtime": "2014-01-20T02:05:24.669Z",
      "wtime": "2014-01-20T02:05:25.817Z",
      "exists": true,
      "encoding": "utf8",
      "source": "delete a[x];",
      "content": "delete a[x];",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "delete.js",
      "date": "2014-01-20T02:05:20.151Z",
      "slug": "test-features-delete",
      "url": "/test/features/delete.js",
      "urls": [
        "/test/features/delete.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "delete a[x];",
      "rendered": true,
      "contentRendered": "delete a[x];",
      "contentRenderedWithoutLayouts": "delete a[x];",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/destructuring_assignment.coffee",
      "relativePath": "test/features/destructuring_assignment.coffee",
      "basename": "destructuring_assignment",
      "outBasename": "destructuring_assignment",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "destructuring_assignment.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/destructuring_assignment.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "destructuring_assignment.coffee",
      "relativeOutPath": "test/features/destructuring_assignment.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/destructuring_assignment",
      "relativeOutBase": "test/features/destructuring_assignment",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.169Z",
      "rtime": "2014-01-20T02:05:24.675Z",
      "wtime": "2014-01-20T02:05:25.821Z",
      "exists": true,
      "encoding": "utf8",
      "source": "[\n  a\n  b\n] = [\n  b\n  a\n]\n",
      "content": "[\n  a\n  b\n] = [\n  b\n  a\n]\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "destructuring_assignment.coffee",
      "date": "2014-01-20T02:05:20.169Z",
      "slug": "test-features-destructuring-assignment",
      "url": "/test/features/destructuring_assignment.coffee",
      "urls": [
        "/test/features/destructuring_assignment.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "[\n  a\n  b\n] = [\n  b\n  a\n]\n",
      "rendered": true,
      "contentRendered": "[\n  a\n  b\n] = [\n  b\n  a\n]\n",
      "contentRenderedWithoutLayouts": "[\n  a\n  b\n] = [\n  b\n  a\n]\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/destructuring_assignment.js",
      "relativePath": "test/features/destructuring_assignment.js",
      "basename": "destructuring_assignment",
      "outBasename": "destructuring_assignment",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "destructuring_assignment.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/destructuring_assignment.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "destructuring_assignment.js",
      "relativeOutPath": "test/features/destructuring_assignment.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/destructuring_assignment",
      "relativeOutBase": "test/features/destructuring_assignment",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.199Z",
      "rtime": "2014-01-20T02:05:24.680Z",
      "wtime": "2014-01-20T02:05:25.825Z",
      "exists": true,
      "encoding": "utf8",
      "source": "[a,b] = [b,a];\n",
      "content": "[a,b] = [b,a];\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "destructuring_assignment.js",
      "date": "2014-01-20T02:05:20.199Z",
      "slug": "test-features-destructuring-assignment",
      "url": "/test/features/destructuring_assignment.js",
      "urls": [
        "/test/features/destructuring_assignment.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "[a,b] = [b,a];\n",
      "rendered": true,
      "contentRendered": "[a,b] = [b,a];\n",
      "contentRenderedWithoutLayouts": "[a,b] = [b,a];\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/destructuring_in_functions.coffee",
      "relativePath": "test/features/destructuring_in_functions.coffee",
      "basename": "destructuring_in_functions",
      "outBasename": "destructuring_in_functions",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "destructuring_in_functions.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/destructuring_in_functions.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "destructuring_in_functions.coffee",
      "relativeOutPath": "test/features/destructuring_in_functions.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/destructuring_in_functions",
      "relativeOutBase": "test/features/destructuring_in_functions",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.223Z",
      "rtime": "2014-01-20T02:05:24.686Z",
      "wtime": "2014-01-20T02:05:25.828Z",
      "exists": true,
      "encoding": "utf8",
      "source": "([a]) ->\n  true\n\n([\n  a\n  b\n]) ->\n  true\n\n([\n  a\n  b\n], c) ->\n  true\n\n(x, [\n  a\n  b\n]) ->\n  true\n\n(x, [\n  a\n  b\n], c) ->\n  true\n",
      "content": "([a]) ->\n  true\n\n([\n  a\n  b\n]) ->\n  true\n\n([\n  a\n  b\n], c) ->\n  true\n\n(x, [\n  a\n  b\n]) ->\n  true\n\n(x, [\n  a\n  b\n], c) ->\n  true\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "destructuring_in_functions.coffee",
      "date": "2014-01-20T02:05:20.223Z",
      "slug": "test-features-destructuring-in-functions",
      "url": "/test/features/destructuring_in_functions.coffee",
      "urls": [
        "/test/features/destructuring_in_functions.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "([a]) ->\n  true\n\n([\n  a\n  b\n]) ->\n  true\n\n([\n  a\n  b\n], c) ->\n  true\n\n(x, [\n  a\n  b\n]) ->\n  true\n\n(x, [\n  a\n  b\n], c) ->\n  true\n",
      "rendered": true,
      "contentRendered": "([a]) ->\n  true\n\n([\n  a\n  b\n]) ->\n  true\n\n([\n  a\n  b\n], c) ->\n  true\n\n(x, [\n  a\n  b\n]) ->\n  true\n\n(x, [\n  a\n  b\n], c) ->\n  true\n",
      "contentRenderedWithoutLayouts": "([a]) ->\n  true\n\n([\n  a\n  b\n]) ->\n  true\n\n([\n  a\n  b\n], c) ->\n  true\n\n(x, [\n  a\n  b\n]) ->\n  true\n\n(x, [\n  a\n  b\n], c) ->\n  true\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/destructuring_in_functions.js",
      "relativePath": "test/features/destructuring_in_functions.js",
      "basename": "destructuring_in_functions",
      "outBasename": "destructuring_in_functions",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "destructuring_in_functions.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/destructuring_in_functions.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "destructuring_in_functions.js",
      "relativeOutPath": "test/features/destructuring_in_functions.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/destructuring_in_functions",
      "relativeOutBase": "test/features/destructuring_in_functions",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.251Z",
      "rtime": "2014-01-20T02:05:24.692Z",
      "wtime": "2014-01-20T02:05:25.830Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(function([a]){return true;});\n(function([a,b]){return true;});\n(function([a,b],c){return true;});\n(function(x,[a,b]){return true;});\n(function(x,[a,b],c){return true;});\n",
      "content": "(function([a]){return true;});\n(function([a,b]){return true;});\n(function([a,b],c){return true;});\n(function(x,[a,b]){return true;});\n(function(x,[a,b],c){return true;});\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "destructuring_in_functions.js",
      "date": "2014-01-20T02:05:20.251Z",
      "slug": "test-features-destructuring-in-functions",
      "url": "/test/features/destructuring_in_functions.js",
      "urls": [
        "/test/features/destructuring_in_functions.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(function([a]){return true;});\n(function([a,b]){return true;});\n(function([a,b],c){return true;});\n(function(x,[a,b]){return true;});\n(function(x,[a,b],c){return true;});\n",
      "rendered": true,
      "contentRendered": "(function([a]){return true;});\n(function([a,b]){return true;});\n(function([a,b],c){return true;});\n(function(x,[a,b]){return true;});\n(function(x,[a,b],c){return true;});\n",
      "contentRenderedWithoutLayouts": "(function([a]){return true;});\n(function([a,b]){return true;});\n(function([a,b],c){return true;});\n(function(x,[a,b]){return true;});\n(function(x,[a,b],c){return true;});\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/do.coffee",
      "relativePath": "test/features/do.coffee",
      "basename": "do",
      "outBasename": "do",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "do.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/do.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "do.coffee",
      "relativeOutPath": "test/features/do.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/do",
      "relativeOutBase": "test/features/do",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.269Z",
      "rtime": "2014-01-20T02:05:24.697Z",
      "wtime": "2014-01-20T02:05:25.837Z",
      "exists": true,
      "encoding": "utf8",
      "source": "i = 0\nloop\n  console.log i\n  i++\n  break unless i < 14\n\n",
      "content": "i = 0\nloop\n  console.log i\n  i++\n  break unless i < 14\n\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "do.coffee",
      "date": "2014-01-20T02:05:20.269Z",
      "slug": "test-features-do",
      "url": "/test/features/do.coffee",
      "urls": [
        "/test/features/do.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "i = 0\nloop\n  console.log i\n  i++\n  break unless i < 14\n\n",
      "rendered": true,
      "contentRendered": "i = 0\nloop\n  console.log i\n  i++\n  break unless i < 14\n\n",
      "contentRenderedWithoutLayouts": "i = 0\nloop\n  console.log i\n  i++\n  break unless i < 14\n\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/do.js",
      "relativePath": "test/features/do.js",
      "basename": "do",
      "outBasename": "do",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "do.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/do.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "do.js",
      "relativeOutPath": "test/features/do.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/do",
      "relativeOutBase": "test/features/do",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.294Z",
      "rtime": "2014-01-20T02:05:24.702Z",
      "wtime": "2014-01-20T02:05:25.841Z",
      "exists": true,
      "encoding": "utf8",
      "source": "var i = 0;\ndo {\n  console.log(i);\n  i++;\n} while (i < 14);\n",
      "content": "var i = 0;\ndo {\n  console.log(i);\n  i++;\n} while (i < 14);\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "do.js",
      "date": "2014-01-20T02:05:20.294Z",
      "slug": "test-features-do",
      "url": "/test/features/do.js",
      "urls": [
        "/test/features/do.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "var i = 0;\ndo {\n  console.log(i);\n  i++;\n} while (i < 14);\n",
      "rendered": true,
      "contentRendered": "var i = 0;\ndo {\n  console.log(i);\n  i++;\n} while (i < 14);\n",
      "contentRenderedWithoutLayouts": "var i = 0;\ndo {\n  console.log(i);\n  i++;\n} while (i < 14);\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/dont_unreserve_property_accessors.coffee",
      "relativePath": "test/features/dont_unreserve_property_accessors.coffee",
      "basename": "dont_unreserve_property_accessors",
      "outBasename": "dont_unreserve_property_accessors",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "dont_unreserve_property_accessors.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/dont_unreserve_property_accessors.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "dont_unreserve_property_accessors.coffee",
      "relativeOutPath": "test/features/dont_unreserve_property_accessors.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/dont_unreserve_property_accessors",
      "relativeOutBase": "test/features/dont_unreserve_property_accessors",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:20.323Z",
      "rtime": "2014-01-20T02:05:24.707Z",
      "wtime": "2014-01-20T02:05:25.845Z",
      "exists": true,
      "encoding": "utf8",
      "source": "io.on \"data\", ->\n  console.log \"Received\"\n  return\n\n@on \"data\", ->\n  console.log \"Received\"\n  return\n",
      "content": "io.on \"data\", ->\n  console.log \"Received\"\n  return\n\n@on \"data\", ->\n  console.log \"Received\"\n  return\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "dont_unreserve_property_accessors.coffee",
      "date": "2014-01-20T02:05:20.323Z",
      "slug": "test-features-dont-unreserve-property-accessors",
      "url": "/test/features/dont_unreserve_property_accessors.coffee",
      "urls": [
        "/test/features/dont_unreserve_property_accessors.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "io.on \"data\", ->\n  console.log \"Received\"\n  return\n\n@on \"data\", ->\n  console.log \"Received\"\n  return\n",
      "rendered": true,
      "contentRendered": "io.on \"data\", ->\n  console.log \"Received\"\n  return\n\n@on \"data\", ->\n  console.log \"Received\"\n  return\n",
      "contentRenderedWithoutLayouts": "io.on \"data\", ->\n  console.log \"Received\"\n  return\n\n@on \"data\", ->\n  console.log \"Received\"\n  return\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/dont_unreserve_property_accessors.js",
      "relativePath": "test/features/dont_unreserve_property_accessors.js",
      "basename": "dont_unreserve_property_accessors",
      "outBasename": "dont_unreserve_property_accessors",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "dont_unreserve_property_accessors.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/dont_unreserve_property_accessors.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "dont_unreserve_property_accessors.js",
      "relativeOutPath": "test/features/dont_unreserve_property_accessors.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/dont_unreserve_property_accessors",
      "relativeOutBase": "test/features/dont_unreserve_property_accessors",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.355Z",
      "rtime": "2014-01-20T02:05:24.712Z",
      "wtime": "2014-01-20T02:05:25.849Z",
      "exists": true,
      "encoding": "utf8",
      "source": "io.on('data', function() { console.log(\"Received\"); });\n\nthis.on('data', function() { console.log(\"Received\"); });\n",
      "content": "io.on('data', function() { console.log(\"Received\"); });\n\nthis.on('data', function() { console.log(\"Received\"); });\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "dont_unreserve_property_accessors.js",
      "date": "2014-01-20T02:05:20.355Z",
      "slug": "test-features-dont-unreserve-property-accessors",
      "url": "/test/features/dont_unreserve_property_accessors.js",
      "urls": [
        "/test/features/dont_unreserve_property_accessors.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "io.on('data', function() { console.log(\"Received\"); });\n\nthis.on('data', function() { console.log(\"Received\"); });\n",
      "rendered": true,
      "contentRendered": "io.on('data', function() { console.log(\"Received\"); });\n\nthis.on('data', function() { console.log(\"Received\"); });\n",
      "contentRenderedWithoutLayouts": "io.on('data', function() { console.log(\"Received\"); });\n\nthis.on('data', function() { console.log(\"Received\"); });\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/empty_catch.coffee",
      "relativePath": "test/features/empty_catch.coffee",
      "basename": "empty_catch",
      "outBasename": "empty_catch",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "empty_catch.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/empty_catch.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "empty_catch.coffee",
      "relativeOutPath": "test/features/empty_catch.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/empty_catch",
      "relativeOutBase": "test/features/empty_catch",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.376Z",
      "rtime": "2014-01-20T02:05:24.721Z",
      "wtime": "2014-01-20T02:05:25.853Z",
      "exists": true,
      "encoding": "utf8",
      "source": "try\n  alert \"OK\"\n",
      "content": "try\n  alert \"OK\"\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "empty_catch.coffee",
      "date": "2014-01-20T02:05:20.376Z",
      "slug": "test-features-empty-catch",
      "url": "/test/features/empty_catch.coffee",
      "urls": [
        "/test/features/empty_catch.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "try\n  alert \"OK\"\n",
      "rendered": true,
      "contentRendered": "try\n  alert \"OK\"\n",
      "contentRenderedWithoutLayouts": "try\n  alert \"OK\"\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/empty_catch.js",
      "relativePath": "test/features/empty_catch.js",
      "basename": "empty_catch",
      "outBasename": "empty_catch",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "empty_catch.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/empty_catch.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "empty_catch.js",
      "relativeOutPath": "test/features/empty_catch.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/empty_catch",
      "relativeOutBase": "test/features/empty_catch",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.396Z",
      "rtime": "2014-01-20T02:05:24.726Z",
      "wtime": "2014-01-20T02:05:25.856Z",
      "exists": true,
      "encoding": "utf8",
      "source": "try { alert(\"OK\"); } catch (e) {}\n",
      "content": "try { alert(\"OK\"); } catch (e) {}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "empty_catch.js",
      "date": "2014-01-20T02:05:20.396Z",
      "slug": "test-features-empty-catch",
      "url": "/test/features/empty_catch.js",
      "urls": [
        "/test/features/empty_catch.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "try { alert(\"OK\"); } catch (e) {}\n",
      "rendered": true,
      "contentRendered": "try { alert(\"OK\"); } catch (e) {}\n",
      "contentRenderedWithoutLayouts": "try { alert(\"OK\"); } catch (e) {}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/empty_function.coffee",
      "relativePath": "test/features/empty_function.coffee",
      "basename": "empty_function",
      "outBasename": "empty_function",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "empty_function.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/empty_function.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "empty_function.coffee",
      "relativeOutPath": "test/features/empty_function.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/empty_function",
      "relativeOutBase": "test/features/empty_function",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.424Z",
      "rtime": "2014-01-20T02:05:24.731Z",
      "wtime": "2014-01-20T02:05:25.861Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(($) ->\n)()\n",
      "content": "(($) ->\n)()\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "empty_function.coffee",
      "date": "2014-01-20T02:05:20.424Z",
      "slug": "test-features-empty-function",
      "url": "/test/features/empty_function.coffee",
      "urls": [
        "/test/features/empty_function.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(($) ->\n)()\n",
      "rendered": true,
      "contentRendered": "(($) ->\n)()\n",
      "contentRenderedWithoutLayouts": "(($) ->\n)()\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/empty_function.js",
      "relativePath": "test/features/empty_function.js",
      "basename": "empty_function",
      "outBasename": "empty_function",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "empty_function.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/empty_function.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "empty_function.js",
      "relativeOutPath": "test/features/empty_function.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/empty_function",
      "relativeOutBase": "test/features/empty_function",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:20.449Z",
      "rtime": "2014-01-20T02:05:24.736Z",
      "wtime": "2014-01-20T02:05:25.866Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(function($) {})()\n",
      "content": "(function($) {})()\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "empty_function.js",
      "date": "2014-01-20T02:05:20.449Z",
      "slug": "test-features-empty-function",
      "url": "/test/features/empty_function.js",
      "urls": [
        "/test/features/empty_function.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(function($) {})()\n",
      "rendered": true,
      "contentRendered": "(function($) {})()\n",
      "contentRenderedWithoutLayouts": "(function($) {})()\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/empty_function_bodies.coffee",
      "relativePath": "test/features/empty_function_bodies.coffee",
      "basename": "empty_function_bodies",
      "outBasename": "empty_function_bodies",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "empty_function_bodies.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/empty_function_bodies.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "empty_function_bodies.coffee",
      "relativeOutPath": "test/features/empty_function_bodies.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/empty_function_bodies",
      "relativeOutBase": "test/features/empty_function_bodies",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.468Z",
      "rtime": "2014-01-20T02:05:24.741Z",
      "wtime": "2014-01-20T02:05:25.870Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x =\n  v: ->\n    2\n\n  y: ->\n\n  z: ->\n",
      "content": "x =\n  v: ->\n    2\n\n  y: ->\n\n  z: ->\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "empty_function_bodies.coffee",
      "date": "2014-01-20T02:05:20.468Z",
      "slug": "test-features-empty-function-bodies",
      "url": "/test/features/empty_function_bodies.coffee",
      "urls": [
        "/test/features/empty_function_bodies.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x =\n  v: ->\n    2\n\n  y: ->\n\n  z: ->\n",
      "rendered": true,
      "contentRendered": "x =\n  v: ->\n    2\n\n  y: ->\n\n  z: ->\n",
      "contentRenderedWithoutLayouts": "x =\n  v: ->\n    2\n\n  y: ->\n\n  z: ->\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/empty_function_bodies.js",
      "relativePath": "test/features/empty_function_bodies.js",
      "basename": "empty_function_bodies",
      "outBasename": "empty_function_bodies",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "empty_function_bodies.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/empty_function_bodies.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "empty_function_bodies.js",
      "relativeOutPath": "test/features/empty_function_bodies.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/empty_function_bodies",
      "relativeOutBase": "test/features/empty_function_bodies",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.487Z",
      "rtime": "2014-01-20T02:05:24.746Z",
      "wtime": "2014-01-20T02:05:25.874Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = { v: function() { return 2; }, y: function(){}, z: function(){} };\n",
      "content": "x = { v: function() { return 2; }, y: function(){}, z: function(){} };\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "empty_function_bodies.js",
      "date": "2014-01-20T02:05:20.487Z",
      "slug": "test-features-empty-function-bodies",
      "url": "/test/features/empty_function_bodies.js",
      "urls": [
        "/test/features/empty_function_bodies.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = { v: function() { return 2; }, y: function(){}, z: function(){} };\n",
      "rendered": true,
      "contentRendered": "x = { v: function() { return 2; }, y: function(){}, z: function(){} };\n",
      "contentRenderedWithoutLayouts": "x = { v: function() { return 2; }, y: function(){}, z: function(){} };\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/empty_semicolon.coffee",
      "relativePath": "test/features/empty_semicolon.coffee",
      "basename": "empty_semicolon",
      "outBasename": "empty_semicolon",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "empty_semicolon.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/empty_semicolon.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "empty_semicolon.coffee",
      "relativeOutPath": "test/features/empty_semicolon.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/empty_semicolon",
      "relativeOutBase": "test/features/empty_semicolon",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.507Z",
      "rtime": "2014-01-20T02:05:24.751Z",
      "wtime": "2014-01-20T02:05:25.878Z",
      "exists": true,
      "encoding": "utf8",
      "source": "2\n3\n\n",
      "content": "2\n3\n\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "empty_semicolon.coffee",
      "date": "2014-01-20T02:05:20.507Z",
      "slug": "test-features-empty-semicolon",
      "url": "/test/features/empty_semicolon.coffee",
      "urls": [
        "/test/features/empty_semicolon.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "2\n3\n\n",
      "rendered": true,
      "contentRendered": "2\n3\n\n",
      "contentRenderedWithoutLayouts": "2\n3\n\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/empty_semicolon.js",
      "relativePath": "test/features/empty_semicolon.js",
      "basename": "empty_semicolon",
      "outBasename": "empty_semicolon",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "empty_semicolon.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/empty_semicolon.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "empty_semicolon.js",
      "relativeOutPath": "test/features/empty_semicolon.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/empty_semicolon",
      "relativeOutBase": "test/features/empty_semicolon",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.531Z",
      "rtime": "2014-01-20T02:05:24.756Z",
      "wtime": "2014-01-20T02:05:25.882Z",
      "exists": true,
      "encoding": "utf8",
      "source": "2;;;3\n",
      "content": "2;;;3\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "empty_semicolon.js",
      "date": "2014-01-20T02:05:20.531Z",
      "slug": "test-features-empty-semicolon",
      "url": "/test/features/empty_semicolon.js",
      "urls": [
        "/test/features/empty_semicolon.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "2;;;3\n",
      "rendered": true,
      "contentRendered": "2;;;3\n",
      "contentRenderedWithoutLayouts": "2;;;3\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/equal_regex.coffee",
      "relativePath": "test/features/equal_regex.coffee",
      "basename": "equal_regex",
      "outBasename": "equal_regex",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "equal_regex.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/equal_regex.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "equal_regex.coffee",
      "relativeOutPath": "test/features/equal_regex.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/equal_regex",
      "relativeOutBase": "test/features/equal_regex",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.555Z",
      "rtime": "2014-01-20T02:05:24.761Z",
      "wtime": "2014-01-20T02:05:25.890Z",
      "exists": true,
      "encoding": "utf8",
      "source": "re = RegExp(\"=\")\nconsole.log \"a = b\".match(re)\n\n",
      "content": "re = RegExp(\"=\")\nconsole.log \"a = b\".match(re)\n\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "equal_regex.coffee",
      "date": "2014-01-20T02:05:20.555Z",
      "slug": "test-features-equal-regex",
      "url": "/test/features/equal_regex.coffee",
      "urls": [
        "/test/features/equal_regex.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "re = RegExp(\"=\")\nconsole.log \"a = b\".match(re)\n\n",
      "rendered": true,
      "contentRendered": "re = RegExp(\"=\")\nconsole.log \"a = b\".match(re)\n\n",
      "contentRenderedWithoutLayouts": "re = RegExp(\"=\")\nconsole.log \"a = b\".match(re)\n\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/equal_regex.js",
      "relativePath": "test/features/equal_regex.js",
      "basename": "equal_regex",
      "outBasename": "equal_regex",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "equal_regex.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/equal_regex.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "equal_regex.js",
      "relativeOutPath": "test/features/equal_regex.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/equal_regex",
      "relativeOutBase": "test/features/equal_regex",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.574Z",
      "rtime": "2014-01-20T02:05:24.766Z",
      "wtime": "2014-01-20T02:05:25.895Z",
      "exists": true,
      "encoding": "utf8",
      "source": "var re = /=/;\nconsole.log('a = b'.match(re));\n",
      "content": "var re = /=/;\nconsole.log('a = b'.match(re));\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "equal_regex.js",
      "date": "2014-01-20T02:05:20.574Z",
      "slug": "test-features-equal-regex",
      "url": "/test/features/equal_regex.js",
      "urls": [
        "/test/features/equal_regex.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "var re = /=/;\nconsole.log('a = b'.match(re));\n",
      "rendered": true,
      "contentRendered": "var re = /=/;\nconsole.log('a = b'.match(re));\n",
      "contentRenderedWithoutLayouts": "var re = /=/;\nconsole.log('a = b'.match(re));\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/escape.coffee",
      "relativePath": "test/features/escape.coffee",
      "basename": "escape",
      "outBasename": "escape",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "escape.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/escape.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "escape.coffee",
      "relativeOutPath": "test/features/escape.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/escape",
      "relativeOutBase": "test/features/escape",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.592Z",
      "rtime": "2014-01-20T02:05:24.771Z",
      "wtime": "2014-01-20T02:05:25.901Z",
      "exists": true,
      "encoding": "utf8",
      "source": "foo = \"bar\"\nobj =\n  key: \"value\"\n  escape: \"rock'n roll\"\n  escapeAnother: \"rock\\\"n roll\"\n  array: [\n    \"one\"\n    2\n    \"tree\"\n  ]\n  mixed: \"hello\" + foo\n  \"empty foo bar\": \"\"\n  \"js-has-no-string-formatting\": '#{foo}' + '#{foo}'\n",
      "content": "foo = \"bar\"\nobj =\n  key: \"value\"\n  escape: \"rock'n roll\"\n  escapeAnother: \"rock\\\"n roll\"\n  array: [\n    \"one\"\n    2\n    \"tree\"\n  ]\n  mixed: \"hello\" + foo\n  \"empty foo bar\": \"\"\n  \"js-has-no-string-formatting\": '#{foo}' + '#{foo}'\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "escape.coffee",
      "date": "2014-01-20T02:05:20.592Z",
      "slug": "test-features-escape",
      "url": "/test/features/escape.coffee",
      "urls": [
        "/test/features/escape.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "foo = \"bar\"\nobj =\n  key: \"value\"\n  escape: \"rock'n roll\"\n  escapeAnother: \"rock\\\"n roll\"\n  array: [\n    \"one\"\n    2\n    \"tree\"\n  ]\n  mixed: \"hello\" + foo\n  \"empty foo bar\": \"\"\n  \"js-has-no-string-formatting\": '#{foo}' + '#{foo}'\n",
      "rendered": true,
      "contentRendered": "foo = \"bar\"\nobj =\n  key: \"value\"\n  escape: \"rock'n roll\"\n  escapeAnother: \"rock\\\"n roll\"\n  array: [\n    \"one\"\n    2\n    \"tree\"\n  ]\n  mixed: \"hello\" + foo\n  \"empty foo bar\": \"\"\n  \"js-has-no-string-formatting\": '#{foo}' + '#{foo}'\n",
      "contentRenderedWithoutLayouts": "foo = \"bar\"\nobj =\n  key: \"value\"\n  escape: \"rock'n roll\"\n  escapeAnother: \"rock\\\"n roll\"\n  array: [\n    \"one\"\n    2\n    \"tree\"\n  ]\n  mixed: \"hello\" + foo\n  \"empty foo bar\": \"\"\n  \"js-has-no-string-formatting\": '#{foo}' + '#{foo}'\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/escape.js",
      "relativePath": "test/features/escape.js",
      "basename": "escape",
      "outBasename": "escape",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "escape.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/escape.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "escape.js",
      "relativeOutPath": "test/features/escape.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/escape",
      "relativeOutBase": "test/features/escape",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.618Z",
      "rtime": "2014-01-20T02:05:24.776Z",
      "wtime": "2014-01-20T02:05:25.902Z",
      "exists": true,
      "encoding": "utf8",
      "source": "// OPTIONS: {\"single_quotes\": false}\nvar foo = 'bar';\n\nvar obj = {\n    key: \"value\",\n    escape: \"rock'n roll\",\n    escapeAnother: \"rock\\\"n roll\",\n    \"array\": [\"one\", 2, 'tree'],\n    'mixed': \"hello\" + foo,\n    'empty foo bar': '',\n    \"js-has-no-string-formatting\": \"#{foo}\" + '#{foo}'\n\n};",
      "content": "// OPTIONS: {\"single_quotes\": false}\nvar foo = 'bar';\n\nvar obj = {\n    key: \"value\",\n    escape: \"rock'n roll\",\n    escapeAnother: \"rock\\\"n roll\",\n    \"array\": [\"one\", 2, 'tree'],\n    'mixed': \"hello\" + foo,\n    'empty foo bar': '',\n    \"js-has-no-string-formatting\": \"#{foo}\" + '#{foo}'\n\n};",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "escape.js",
      "date": "2014-01-20T02:05:20.618Z",
      "slug": "test-features-escape",
      "url": "/test/features/escape.js",
      "urls": [
        "/test/features/escape.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "// OPTIONS: {\"single_quotes\": false}\nvar foo = 'bar';\n\nvar obj = {\n    key: \"value\",\n    escape: \"rock'n roll\",\n    escapeAnother: \"rock\\\"n roll\",\n    \"array\": [\"one\", 2, 'tree'],\n    'mixed': \"hello\" + foo,\n    'empty foo bar': '',\n    \"js-has-no-string-formatting\": \"#{foo}\" + '#{foo}'\n\n};",
      "rendered": true,
      "contentRendered": "// OPTIONS: {\"single_quotes\": false}\nvar foo = 'bar';\n\nvar obj = {\n    key: \"value\",\n    escape: \"rock'n roll\",\n    escapeAnother: \"rock\\\"n roll\",\n    \"array\": [\"one\", 2, 'tree'],\n    'mixed': \"hello\" + foo,\n    'empty foo bar': '',\n    \"js-has-no-string-formatting\": \"#{foo}\" + '#{foo}'\n\n};",
      "contentRenderedWithoutLayouts": "// OPTIONS: {\"single_quotes\": false}\nvar foo = 'bar';\n\nvar obj = {\n    key: \"value\",\n    escape: \"rock'n roll\",\n    escapeAnother: \"rock\\\"n roll\",\n    \"array\": [\"one\", 2, 'tree'],\n    'mixed': \"hello\" + foo,\n    'empty foo bar': '',\n    \"js-has-no-string-formatting\": \"#{foo}\" + '#{foo}'\n\n};",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/existence.coffee",
      "relativePath": "test/features/existence.coffee",
      "basename": "existence",
      "outBasename": "existence",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "existence.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/existence.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "existence.coffee",
      "relativeOutPath": "test/features/existence.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/existence",
      "relativeOutBase": "test/features/existence",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:20.653Z",
      "rtime": "2014-01-20T02:05:24.781Z",
      "wtime": "2014-01-20T02:05:25.907Z",
      "exists": true,
      "encoding": "utf8",
      "source": "ifChecks = ->\n  yep  if x\n  yep  unless x\n  return\nifNullChecks = ->\n  yep  unless x?\n  nah  if x is null\n  return\nvoidChecks = ->\n  yep  unless x?\n  nah  if x is undefined\n  yep  unless x?\n  return\nundefinedChecks = ->\n  nah  if typeof x is \"undefined\"\n  return\nedgeCase = ->\n  nah  if not x is y\n  return\nunlessChecks = ->\n  yep  if x?\n  nah  if x isnt null\n  wat  unless typeof x is \"undefined\"\n  return\nwhileAndFor = ->\n  yep  until x?\n  yep  while x is null\n  a\n  while not x?\n    yep\n    2\n  return\n",
      "content": "ifChecks = ->\n  yep  if x\n  yep  unless x\n  return\nifNullChecks = ->\n  yep  unless x?\n  nah  if x is null\n  return\nvoidChecks = ->\n  yep  unless x?\n  nah  if x is undefined\n  yep  unless x?\n  return\nundefinedChecks = ->\n  nah  if typeof x is \"undefined\"\n  return\nedgeCase = ->\n  nah  if not x is y\n  return\nunlessChecks = ->\n  yep  if x?\n  nah  if x isnt null\n  wat  unless typeof x is \"undefined\"\n  return\nwhileAndFor = ->\n  yep  until x?\n  yep  while x is null\n  a\n  while not x?\n    yep\n    2\n  return\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "existence.coffee",
      "date": "2014-01-20T02:05:20.653Z",
      "slug": "test-features-existence",
      "url": "/test/features/existence.coffee",
      "urls": [
        "/test/features/existence.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "ifChecks = ->\n  yep  if x\n  yep  unless x\n  return\nifNullChecks = ->\n  yep  unless x?\n  nah  if x is null\n  return\nvoidChecks = ->\n  yep  unless x?\n  nah  if x is undefined\n  yep  unless x?\n  return\nundefinedChecks = ->\n  nah  if typeof x is \"undefined\"\n  return\nedgeCase = ->\n  nah  if not x is y\n  return\nunlessChecks = ->\n  yep  if x?\n  nah  if x isnt null\n  wat  unless typeof x is \"undefined\"\n  return\nwhileAndFor = ->\n  yep  until x?\n  yep  while x is null\n  a\n  while not x?\n    yep\n    2\n  return\n",
      "rendered": true,
      "contentRendered": "ifChecks = ->\n  yep  if x\n  yep  unless x\n  return\nifNullChecks = ->\n  yep  unless x?\n  nah  if x is null\n  return\nvoidChecks = ->\n  yep  unless x?\n  nah  if x is undefined\n  yep  unless x?\n  return\nundefinedChecks = ->\n  nah  if typeof x is \"undefined\"\n  return\nedgeCase = ->\n  nah  if not x is y\n  return\nunlessChecks = ->\n  yep  if x?\n  nah  if x isnt null\n  wat  unless typeof x is \"undefined\"\n  return\nwhileAndFor = ->\n  yep  until x?\n  yep  while x is null\n  a\n  while not x?\n    yep\n    2\n  return\n",
      "contentRenderedWithoutLayouts": "ifChecks = ->\n  yep  if x\n  yep  unless x\n  return\nifNullChecks = ->\n  yep  unless x?\n  nah  if x is null\n  return\nvoidChecks = ->\n  yep  unless x?\n  nah  if x is undefined\n  yep  unless x?\n  return\nundefinedChecks = ->\n  nah  if typeof x is \"undefined\"\n  return\nedgeCase = ->\n  nah  if not x is y\n  return\nunlessChecks = ->\n  yep  if x?\n  nah  if x isnt null\n  wat  unless typeof x is \"undefined\"\n  return\nwhileAndFor = ->\n  yep  until x?\n  yep  while x is null\n  a\n  while not x?\n    yep\n    2\n  return\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/existence.js",
      "relativePath": "test/features/existence.js",
      "basename": "existence",
      "outBasename": "existence",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "existence.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/existence.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "existence.js",
      "relativeOutPath": "test/features/existence.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/existence",
      "relativeOutBase": "test/features/existence",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.677Z",
      "rtime": "2014-01-20T02:05:24.786Z",
      "wtime": "2014-01-20T02:05:25.913Z",
      "exists": true,
      "encoding": "utf8",
      "source": "function ifChecks() {\n    if (x) { yep }\n    if (!x) { yep }\n}\nfunction ifNullChecks() {\n    if (x==null) { yep }\n    if (x===null) { nah }\n}\nfunction voidChecks() {\n    if (x==void 0) { yep }\n    if (x===void 0) { nah }\n    if (x==void 1) { yep }\n}\nfunction undefinedChecks() {\n    if (typeof x == 'undefined') { nah }\n}\nfunction edgeCase() {\n    if (!x == y) { nah }\n}\n\nfunction unlessChecks() {\n    if (x!=null) { yep }\n    if (x!==null) { nah }\n    if (typeof x != 'undefined') { wat }\n}\n\nfunction whileAndFor() {\n    while (x==null) { yep }\n    while (x===null) { yep }\n\n    for (a;x==null;2) { yep }\n}\n",
      "content": "function ifChecks() {\n    if (x) { yep }\n    if (!x) { yep }\n}\nfunction ifNullChecks() {\n    if (x==null) { yep }\n    if (x===null) { nah }\n}\nfunction voidChecks() {\n    if (x==void 0) { yep }\n    if (x===void 0) { nah }\n    if (x==void 1) { yep }\n}\nfunction undefinedChecks() {\n    if (typeof x == 'undefined') { nah }\n}\nfunction edgeCase() {\n    if (!x == y) { nah }\n}\n\nfunction unlessChecks() {\n    if (x!=null) { yep }\n    if (x!==null) { nah }\n    if (typeof x != 'undefined') { wat }\n}\n\nfunction whileAndFor() {\n    while (x==null) { yep }\n    while (x===null) { yep }\n\n    for (a;x==null;2) { yep }\n}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "existence.js",
      "date": "2014-01-20T02:05:20.677Z",
      "slug": "test-features-existence",
      "url": "/test/features/existence.js",
      "urls": [
        "/test/features/existence.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "function ifChecks() {\n    if (x) { yep }\n    if (!x) { yep }\n}\nfunction ifNullChecks() {\n    if (x==null) { yep }\n    if (x===null) { nah }\n}\nfunction voidChecks() {\n    if (x==void 0) { yep }\n    if (x===void 0) { nah }\n    if (x==void 1) { yep }\n}\nfunction undefinedChecks() {\n    if (typeof x == 'undefined') { nah }\n}\nfunction edgeCase() {\n    if (!x == y) { nah }\n}\n\nfunction unlessChecks() {\n    if (x!=null) { yep }\n    if (x!==null) { nah }\n    if (typeof x != 'undefined') { wat }\n}\n\nfunction whileAndFor() {\n    while (x==null) { yep }\n    while (x===null) { yep }\n\n    for (a;x==null;2) { yep }\n}\n",
      "rendered": true,
      "contentRendered": "function ifChecks() {\n    if (x) { yep }\n    if (!x) { yep }\n}\nfunction ifNullChecks() {\n    if (x==null) { yep }\n    if (x===null) { nah }\n}\nfunction voidChecks() {\n    if (x==void 0) { yep }\n    if (x===void 0) { nah }\n    if (x==void 1) { yep }\n}\nfunction undefinedChecks() {\n    if (typeof x == 'undefined') { nah }\n}\nfunction edgeCase() {\n    if (!x == y) { nah }\n}\n\nfunction unlessChecks() {\n    if (x!=null) { yep }\n    if (x!==null) { nah }\n    if (typeof x != 'undefined') { wat }\n}\n\nfunction whileAndFor() {\n    while (x==null) { yep }\n    while (x===null) { yep }\n\n    for (a;x==null;2) { yep }\n}\n",
      "contentRenderedWithoutLayouts": "function ifChecks() {\n    if (x) { yep }\n    if (!x) { yep }\n}\nfunction ifNullChecks() {\n    if (x==null) { yep }\n    if (x===null) { nah }\n}\nfunction voidChecks() {\n    if (x==void 0) { yep }\n    if (x===void 0) { nah }\n    if (x==void 1) { yep }\n}\nfunction undefinedChecks() {\n    if (typeof x == 'undefined') { nah }\n}\nfunction edgeCase() {\n    if (!x == y) { nah }\n}\n\nfunction unlessChecks() {\n    if (x!=null) { yep }\n    if (x!==null) { nah }\n    if (typeof x != 'undefined') { wat }\n}\n\nfunction whileAndFor() {\n    while (x==null) { yep }\n    while (x===null) { yep }\n\n    for (a;x==null;2) { yep }\n}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/floating_point_numbers.coffee",
      "relativePath": "test/features/floating_point_numbers.coffee",
      "basename": "floating_point_numbers",
      "outBasename": "floating_point_numbers",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "floating_point_numbers.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/floating_point_numbers.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "floating_point_numbers.coffee",
      "relativeOutPath": "test/features/floating_point_numbers.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/floating_point_numbers",
      "relativeOutBase": "test/features/floating_point_numbers",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.701Z",
      "rtime": "2014-01-20T02:05:24.790Z",
      "wtime": "2014-01-20T02:05:25.917Z",
      "exists": true,
      "encoding": "utf8",
      "source": "0.094\n91\n9\n0\n-1\n-20.89889\n-424\n482934.00000001\n",
      "content": "0.094\n91\n9\n0\n-1\n-20.89889\n-424\n482934.00000001\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "floating_point_numbers.coffee",
      "date": "2014-01-20T02:05:20.701Z",
      "slug": "test-features-floating-point-numbers",
      "url": "/test/features/floating_point_numbers.coffee",
      "urls": [
        "/test/features/floating_point_numbers.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "0.094\n91\n9\n0\n-1\n-20.89889\n-424\n482934.00000001\n",
      "rendered": true,
      "contentRendered": "0.094\n91\n9\n0\n-1\n-20.89889\n-424\n482934.00000001\n",
      "contentRenderedWithoutLayouts": "0.094\n91\n9\n0\n-1\n-20.89889\n-424\n482934.00000001\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/floating_point_numbers.js",
      "relativePath": "test/features/floating_point_numbers.js",
      "basename": "floating_point_numbers",
      "outBasename": "floating_point_numbers",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "floating_point_numbers.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/floating_point_numbers.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "floating_point_numbers.js",
      "relativeOutPath": "test/features/floating_point_numbers.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/floating_point_numbers",
      "relativeOutBase": "test/features/floating_point_numbers",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.718Z",
      "rtime": "2014-01-20T02:05:24.795Z",
      "wtime": "2014-01-20T02:05:25.921Z",
      "exists": true,
      "encoding": "utf8",
      "source": "0.094;\n91;\n9;\n0;\n-1;\n-20.89889;\n-424;\n482934.00000001;\n",
      "content": "0.094;\n91;\n9;\n0;\n-1;\n-20.89889;\n-424;\n482934.00000001;\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "floating_point_numbers.js",
      "date": "2014-01-20T02:05:20.718Z",
      "slug": "test-features-floating-point-numbers",
      "url": "/test/features/floating_point_numbers.js",
      "urls": [
        "/test/features/floating_point_numbers.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "0.094;\n91;\n9;\n0;\n-1;\n-20.89889;\n-424;\n482934.00000001;\n",
      "rendered": true,
      "contentRendered": "0.094;\n91;\n9;\n0;\n-1;\n-20.89889;\n-424;\n482934.00000001;\n",
      "contentRenderedWithoutLayouts": "0.094;\n91;\n9;\n0;\n-1;\n-20.89889;\n-424;\n482934.00000001;\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/for.coffee",
      "relativePath": "test/features/for.coffee",
      "basename": "for",
      "outBasename": "for",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "for.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/for.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "for.coffee",
      "relativeOutPath": "test/features/for.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/for",
      "relativeOutBase": "test/features/for",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.740Z",
      "rtime": "2014-01-20T02:05:24.800Z",
      "wtime": "2014-01-20T02:05:25.925Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = 0\nwhile not x < 2\n  alert 1\n  x++\nwhile not x < 2\n  alert 1\nloop\n  alert 1\n  ++x\nloop\n  alert 1\n",
      "content": "x = 0\nwhile not x < 2\n  alert 1\n  x++\nwhile not x < 2\n  alert 1\nloop\n  alert 1\n  ++x\nloop\n  alert 1\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "for.coffee",
      "date": "2014-01-20T02:05:20.740Z",
      "slug": "test-features-for",
      "url": "/test/features/for.coffee",
      "urls": [
        "/test/features/for.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = 0\nwhile not x < 2\n  alert 1\n  x++\nwhile not x < 2\n  alert 1\nloop\n  alert 1\n  ++x\nloop\n  alert 1\n",
      "rendered": true,
      "contentRendered": "x = 0\nwhile not x < 2\n  alert 1\n  x++\nwhile not x < 2\n  alert 1\nloop\n  alert 1\n  ++x\nloop\n  alert 1\n",
      "contentRenderedWithoutLayouts": "x = 0\nwhile not x < 2\n  alert 1\n  x++\nwhile not x < 2\n  alert 1\nloop\n  alert 1\n  ++x\nloop\n  alert 1\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/for.js",
      "relativePath": "test/features/for.js",
      "basename": "for",
      "outBasename": "for",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "for.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/for.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "for.js",
      "relativeOutPath": "test/features/for.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/for",
      "relativeOutBase": "test/features/for",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.755Z",
      "rtime": "2014-01-20T02:05:24.805Z",
      "wtime": "2014-01-20T02:05:25.929Z",
      "exists": true,
      "encoding": "utf8",
      "source": "for (x=0; !x<2; x++) { alert(1) }\nfor (; !x<2; ) { alert(1) }\nfor (;;++x) { alert(1) }\nfor (;;) { alert(1) }\n",
      "content": "for (x=0; !x<2; x++) { alert(1) }\nfor (; !x<2; ) { alert(1) }\nfor (;;++x) { alert(1) }\nfor (;;) { alert(1) }\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "for.js",
      "date": "2014-01-20T02:05:20.755Z",
      "slug": "test-features-for",
      "url": "/test/features/for.js",
      "urls": [
        "/test/features/for.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "for (x=0; !x<2; x++) { alert(1) }\nfor (; !x<2; ) { alert(1) }\nfor (;;++x) { alert(1) }\nfor (;;) { alert(1) }\n",
      "rendered": true,
      "contentRendered": "for (x=0; !x<2; x++) { alert(1) }\nfor (; !x<2; ) { alert(1) }\nfor (;;++x) { alert(1) }\nfor (;;) { alert(1) }\n",
      "contentRenderedWithoutLayouts": "for (x=0; !x<2; x++) { alert(1) }\nfor (; !x<2; ) { alert(1) }\nfor (;;++x) { alert(1) }\nfor (;;) { alert(1) }\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/for_in.coffee",
      "relativePath": "test/features/for_in.coffee",
      "basename": "for_in",
      "outBasename": "for_in",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "for_in.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/for_in.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "for_in.coffee",
      "relativeOutPath": "test/features/for_in.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/for_in",
      "relativeOutBase": "test/features/for_in",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.780Z",
      "rtime": "2014-01-20T02:05:24.810Z",
      "wtime": "2014-01-20T02:05:25.933Z",
      "exists": true,
      "encoding": "utf8",
      "source": "for x of y\n  alert 1\nfor key of obj\n  continue",
      "content": "for x of y\n  alert 1\nfor key of obj\n  continue",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "for_in.coffee",
      "date": "2014-01-20T02:05:20.780Z",
      "slug": "test-features-for-in",
      "url": "/test/features/for_in.coffee",
      "urls": [
        "/test/features/for_in.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "for x of y\n  alert 1\nfor key of obj\n  continue",
      "rendered": true,
      "contentRendered": "for x of y\n  alert 1\nfor key of obj\n  continue",
      "contentRenderedWithoutLayouts": "for x of y\n  alert 1\nfor key of obj\n  continue",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/for_in.js",
      "relativePath": "test/features/for_in.js",
      "basename": "for_in",
      "outBasename": "for_in",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "for_in.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/for_in.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "for_in.js",
      "relativeOutPath": "test/features/for_in.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/for_in",
      "relativeOutBase": "test/features/for_in",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.796Z",
      "rtime": "2014-01-20T02:05:24.815Z",
      "wtime": "2014-01-20T02:05:25.938Z",
      "exists": true,
      "encoding": "utf8",
      "source": "for (x in y) { alert(1) }\nfor (key in obj) {}",
      "content": "for (x in y) { alert(1) }\nfor (key in obj) {}",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "for_in.js",
      "date": "2014-01-20T02:05:20.796Z",
      "slug": "test-features-for-in",
      "url": "/test/features/for_in.js",
      "urls": [
        "/test/features/for_in.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "for (x in y) { alert(1) }\nfor (key in obj) {}",
      "rendered": true,
      "contentRendered": "for (x in y) { alert(1) }\nfor (key in obj) {}",
      "contentRenderedWithoutLayouts": "for (x in y) { alert(1) }\nfor (key in obj) {}",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/function_chaining.coffee",
      "relativePath": "test/features/function_chaining.coffee",
      "basename": "function_chaining",
      "outBasename": "function_chaining",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "function_chaining.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/function_chaining.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "function_chaining.coffee",
      "relativeOutPath": "test/features/function_chaining.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/function_chaining",
      "relativeOutBase": "test/features/function_chaining",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.817Z",
      "rtime": "2014-01-20T02:05:24.820Z",
      "wtime": "2014-01-20T02:05:25.941Z",
      "exists": true,
      "encoding": "utf8",
      "source": "$(\"#foo\").css(opacity: 0).css(\n  left: 0\n  right: 0\n).highlight().animate opacity: 1\n$(\"#foo\").css(opacity: 0).css(\n  left: 0\n  right: 0\n).highlight().animate\n  opacity: 1\n  left: 20\n, 3\n",
      "content": "$(\"#foo\").css(opacity: 0).css(\n  left: 0\n  right: 0\n).highlight().animate opacity: 1\n$(\"#foo\").css(opacity: 0).css(\n  left: 0\n  right: 0\n).highlight().animate\n  opacity: 1\n  left: 20\n, 3\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "function_chaining.coffee",
      "date": "2014-01-20T02:05:20.817Z",
      "slug": "test-features-function-chaining",
      "url": "/test/features/function_chaining.coffee",
      "urls": [
        "/test/features/function_chaining.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "$(\"#foo\").css(opacity: 0).css(\n  left: 0\n  right: 0\n).highlight().animate opacity: 1\n$(\"#foo\").css(opacity: 0).css(\n  left: 0\n  right: 0\n).highlight().animate\n  opacity: 1\n  left: 20\n, 3\n",
      "rendered": true,
      "contentRendered": "$(\"#foo\").css(opacity: 0).css(\n  left: 0\n  right: 0\n).highlight().animate opacity: 1\n$(\"#foo\").css(opacity: 0).css(\n  left: 0\n  right: 0\n).highlight().animate\n  opacity: 1\n  left: 20\n, 3\n",
      "contentRenderedWithoutLayouts": "$(\"#foo\").css(opacity: 0).css(\n  left: 0\n  right: 0\n).highlight().animate opacity: 1\n$(\"#foo\").css(opacity: 0).css(\n  left: 0\n  right: 0\n).highlight().animate\n  opacity: 1\n  left: 20\n, 3\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/function_chaining.js",
      "relativePath": "test/features/function_chaining.js",
      "basename": "function_chaining",
      "outBasename": "function_chaining",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "function_chaining.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/function_chaining.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "function_chaining.js",
      "relativeOutPath": "test/features/function_chaining.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/function_chaining",
      "relativeOutBase": "test/features/function_chaining",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.835Z",
      "rtime": "2014-01-20T02:05:24.825Z",
      "wtime": "2014-01-20T02:05:25.945Z",
      "exists": true,
      "encoding": "utf8",
      "source": "$(\"#foo\").css({ opacity: 0 }).css({ left: 0, right: 0 }).highlight().animate({ opacity: 1 });\n$(\"#foo\").css({ opacity: 0 }).css({ left: 0, right: 0 }).highlight().animate({ opacity: 1, left: 20 }, 3);\n",
      "content": "$(\"#foo\").css({ opacity: 0 }).css({ left: 0, right: 0 }).highlight().animate({ opacity: 1 });\n$(\"#foo\").css({ opacity: 0 }).css({ left: 0, right: 0 }).highlight().animate({ opacity: 1, left: 20 }, 3);\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "function_chaining.js",
      "date": "2014-01-20T02:05:20.835Z",
      "slug": "test-features-function-chaining",
      "url": "/test/features/function_chaining.js",
      "urls": [
        "/test/features/function_chaining.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "$(\"#foo\").css({ opacity: 0 }).css({ left: 0, right: 0 }).highlight().animate({ opacity: 1 });\n$(\"#foo\").css({ opacity: 0 }).css({ left: 0, right: 0 }).highlight().animate({ opacity: 1, left: 20 }, 3);\n",
      "rendered": true,
      "contentRendered": "$(\"#foo\").css({ opacity: 0 }).css({ left: 0, right: 0 }).highlight().animate({ opacity: 1 });\n$(\"#foo\").css({ opacity: 0 }).css({ left: 0, right: 0 }).highlight().animate({ opacity: 1, left: 20 }, 3);\n",
      "contentRenderedWithoutLayouts": "$(\"#foo\").css({ opacity: 0 }).css({ left: 0, right: 0 }).highlight().animate({ opacity: 1 });\n$(\"#foo\").css({ opacity: 0 }).css({ left: 0, right: 0 }).highlight().animate({ opacity: 1, left: 20 }, 3);\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/function_order.coffee",
      "relativePath": "test/features/function_order.coffee",
      "basename": "function_order",
      "outBasename": "function_order",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "function_order.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/function_order.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "function_order.coffee",
      "relativeOutPath": "test/features/function_order.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/function_order",
      "relativeOutBase": "test/features/function_order",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:20.854Z",
      "rtime": "2014-01-20T02:05:24.830Z",
      "wtime": "2014-01-20T02:05:25.949Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = ->\n  y = ->\n    2\n  alert y()\n  z = ->\n    3\n\n  return\n",
      "content": "x = ->\n  y = ->\n    2\n  alert y()\n  z = ->\n    3\n\n  return\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "function_order.coffee",
      "date": "2014-01-20T02:05:20.854Z",
      "slug": "test-features-function-order",
      "url": "/test/features/function_order.coffee",
      "urls": [
        "/test/features/function_order.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = ->\n  y = ->\n    2\n  alert y()\n  z = ->\n    3\n\n  return\n",
      "rendered": true,
      "contentRendered": "x = ->\n  y = ->\n    2\n  alert y()\n  z = ->\n    3\n\n  return\n",
      "contentRenderedWithoutLayouts": "x = ->\n  y = ->\n    2\n  alert y()\n  z = ->\n    3\n\n  return\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/function_order.js",
      "relativePath": "test/features/function_order.js",
      "basename": "function_order",
      "outBasename": "function_order",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "function_order.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/function_order.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "function_order.js",
      "relativeOutPath": "test/features/function_order.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/function_order",
      "relativeOutBase": "test/features/function_order",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.873Z",
      "rtime": "2014-01-20T02:05:24.835Z",
      "wtime": "2014-01-20T02:05:25.953Z",
      "exists": true,
      "encoding": "utf8",
      "source": "var x = function() {\n    alert(y());\n    var z = function() { return 3; }\n    function y() { return 2; }\n}\n",
      "content": "var x = function() {\n    alert(y());\n    var z = function() { return 3; }\n    function y() { return 2; }\n}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "function_order.js",
      "date": "2014-01-20T02:05:20.873Z",
      "slug": "test-features-function-order",
      "url": "/test/features/function_order.js",
      "urls": [
        "/test/features/function_order.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "var x = function() {\n    alert(y());\n    var z = function() { return 3; }\n    function y() { return 2; }\n}\n",
      "rendered": true,
      "contentRendered": "var x = function() {\n    alert(y());\n    var z = function() { return 3; }\n    function y() { return 2; }\n}\n",
      "contentRenderedWithoutLayouts": "var x = function() {\n    alert(y());\n    var z = function() { return 3; }\n    function y() { return 2; }\n}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/function_property.coffee",
      "relativePath": "test/features/function_property.coffee",
      "basename": "function_property",
      "outBasename": "function_property",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "function_property.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/function_property.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "function_property.coffee",
      "relativeOutPath": "test/features/function_property.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/function_property",
      "relativeOutBase": "test/features/function_property",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-03T00:09:40.000Z",
      "mtime": "2014-01-20T02:05:20.891Z",
      "rtime": "2014-01-20T02:05:24.840Z",
      "wtime": "2014-01-20T02:05:25.957Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(->\n).apa\nf = (->\n).bind(this)",
      "content": "(->\n).apa\nf = (->\n).bind(this)",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "function_property.coffee",
      "date": "2014-01-20T02:05:20.891Z",
      "slug": "test-features-function-property",
      "url": "/test/features/function_property.coffee",
      "urls": [
        "/test/features/function_property.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(->\n).apa\nf = (->\n).bind(this)",
      "rendered": true,
      "contentRendered": "(->\n).apa\nf = (->\n).bind(this)",
      "contentRenderedWithoutLayouts": "(->\n).apa\nf = (->\n).bind(this)",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/function_property.js",
      "relativePath": "test/features/function_property.js",
      "basename": "function_property",
      "outBasename": "function_property",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "function_property.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/function_property.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "function_property.js",
      "relativeOutPath": "test/features/function_property.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/function_property",
      "relativeOutBase": "test/features/function_property",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-01-03T00:09:40.000Z",
      "mtime": "2014-01-20T02:05:20.910Z",
      "rtime": "2014-01-20T02:05:24.844Z",
      "wtime": "2014-01-20T02:05:25.962Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(function (){}.apa);\nvar f = function(){}.bind(this);",
      "content": "(function (){}.apa);\nvar f = function(){}.bind(this);",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "function_property.js",
      "date": "2014-01-20T02:05:20.910Z",
      "slug": "test-features-function-property",
      "url": "/test/features/function_property.js",
      "urls": [
        "/test/features/function_property.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(function (){}.apa);\nvar f = function(){}.bind(this);",
      "rendered": true,
      "contentRendered": "(function (){}.apa);\nvar f = function(){}.bind(this);",
      "contentRenderedWithoutLayouts": "(function (){}.apa);\nvar f = function(){}.bind(this);",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/function_with_keyword.coffee",
      "relativePath": "test/features/function_with_keyword.coffee",
      "basename": "function_with_keyword",
      "outBasename": "function_with_keyword",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "function_with_keyword.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/function_with_keyword.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "function_with_keyword.coffee",
      "relativeOutPath": "test/features/function_with_keyword.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/function_with_keyword",
      "relativeOutBase": "test/features/function_with_keyword",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.934Z",
      "rtime": "2014-01-20T02:05:24.849Z",
      "wtime": "2014-01-20T02:05:25.967Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = ->\n  \n",
      "content": "x = ->\n  \n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "function_with_keyword.coffee",
      "date": "2014-01-20T02:05:20.934Z",
      "slug": "test-features-function-with-keyword",
      "url": "/test/features/function_with_keyword.coffee",
      "urls": [
        "/test/features/function_with_keyword.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = ->\n  \n",
      "rendered": true,
      "contentRendered": "x = ->\n  \n",
      "contentRenderedWithoutLayouts": "x = ->\n  \n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/function_with_keyword.js",
      "relativePath": "test/features/function_with_keyword.js",
      "basename": "function_with_keyword",
      "outBasename": "function_with_keyword",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "function_with_keyword.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/function_with_keyword.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "function_with_keyword.js",
      "relativeOutPath": "test/features/function_with_keyword.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/function_with_keyword",
      "relativeOutBase": "test/features/function_with_keyword",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.953Z",
      "rtime": "2014-01-20T02:05:24.854Z",
      "wtime": "2014-01-20T02:05:25.971Z",
      "exists": true,
      "encoding": "utf8",
      "source": "function x() {}",
      "content": "function x() {}",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "function_with_keyword.js",
      "date": "2014-01-20T02:05:20.953Z",
      "slug": "test-features-function-with-keyword",
      "url": "/test/features/function_with_keyword.js",
      "urls": [
        "/test/features/function_with_keyword.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "function x() {}",
      "rendered": true,
      "contentRendered": "function x() {}",
      "contentRenderedWithoutLayouts": "function x() {}",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/hash.coffee",
      "relativePath": "test/features/hash.coffee",
      "basename": "hash",
      "outBasename": "hash",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "hash.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/hash.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "hash.coffee",
      "relativeOutPath": "test/features/hash.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/hash",
      "relativeOutBase": "test/features/hash",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.973Z",
      "rtime": "2014-01-20T02:05:24.859Z",
      "wtime": "2014-01-20T02:05:25.972Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x =\n  a: 2\n  b: 3\n  c:\n    one: 1\n\nconsole.log\n  two: 2\n  three: 3\n",
      "content": "x =\n  a: 2\n  b: 3\n  c:\n    one: 1\n\nconsole.log\n  two: 2\n  three: 3\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "hash.coffee",
      "date": "2014-01-20T02:05:20.973Z",
      "slug": "test-features-hash",
      "url": "/test/features/hash.coffee",
      "urls": [
        "/test/features/hash.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x =\n  a: 2\n  b: 3\n  c:\n    one: 1\n\nconsole.log\n  two: 2\n  three: 3\n",
      "rendered": true,
      "contentRendered": "x =\n  a: 2\n  b: 3\n  c:\n    one: 1\n\nconsole.log\n  two: 2\n  three: 3\n",
      "contentRenderedWithoutLayouts": "x =\n  a: 2\n  b: 3\n  c:\n    one: 1\n\nconsole.log\n  two: 2\n  three: 3\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/hash.js",
      "relativePath": "test/features/hash.js",
      "basename": "hash",
      "outBasename": "hash",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "hash.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/hash.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "hash.js",
      "relativeOutPath": "test/features/hash.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/hash",
      "relativeOutBase": "test/features/hash",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:20.993Z",
      "rtime": "2014-01-20T02:05:24.864Z",
      "wtime": "2014-01-20T02:05:25.978Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = {\n  a: 2,\n  b: 3,\n  c:\n    { one: 1 }\n}\n\nconsole.log({ two:2, three:3 });\n",
      "content": "x = {\n  a: 2,\n  b: 3,\n  c:\n    { one: 1 }\n}\n\nconsole.log({ two:2, three:3 });\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "hash.js",
      "date": "2014-01-20T02:05:20.993Z",
      "slug": "test-features-hash",
      "url": "/test/features/hash.js",
      "urls": [
        "/test/features/hash.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = {\n  a: 2,\n  b: 3,\n  c:\n    { one: 1 }\n}\n\nconsole.log({ two:2, three:3 });\n",
      "rendered": true,
      "contentRendered": "x = {\n  a: 2,\n  b: 3,\n  c:\n    { one: 1 }\n}\n\nconsole.log({ two:2, three:3 });\n",
      "contentRenderedWithoutLayouts": "x = {\n  a: 2,\n  b: 3,\n  c:\n    { one: 1 }\n}\n\nconsole.log({ two:2, three:3 });\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/if_return.coffee",
      "relativePath": "test/features/if_return.coffee",
      "basename": "if_return",
      "outBasename": "if_return",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "if_return.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/if_return.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "if_return.coffee",
      "relativeOutPath": "test/features/if_return.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/if_return",
      "relativeOutBase": "test/features/if_return",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.009Z",
      "rtime": "2014-01-20T02:05:24.869Z",
      "wtime": "2014-01-20T02:05:25.985Z",
      "exists": true,
      "encoding": "utf8",
      "source": "bar = ->\n  1  if 1\nfoo = ->\n  1  if 1\nbaz = ->\n  if 1\n    2\n  else\n    1\n",
      "content": "bar = ->\n  1  if 1\nfoo = ->\n  1  if 1\nbaz = ->\n  if 1\n    2\n  else\n    1\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "if_return.coffee",
      "date": "2014-01-20T02:05:21.009Z",
      "slug": "test-features-if-return",
      "url": "/test/features/if_return.coffee",
      "urls": [
        "/test/features/if_return.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "bar = ->\n  1  if 1\nfoo = ->\n  1  if 1\nbaz = ->\n  if 1\n    2\n  else\n    1\n",
      "rendered": true,
      "contentRendered": "bar = ->\n  1  if 1\nfoo = ->\n  1  if 1\nbaz = ->\n  if 1\n    2\n  else\n    1\n",
      "contentRenderedWithoutLayouts": "bar = ->\n  1  if 1\nfoo = ->\n  1  if 1\nbaz = ->\n  if 1\n    2\n  else\n    1\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/if_return.js",
      "relativePath": "test/features/if_return.js",
      "basename": "if_return",
      "outBasename": "if_return",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "if_return.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/if_return.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "if_return.js",
      "relativeOutPath": "test/features/if_return.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/if_return",
      "relativeOutBase": "test/features/if_return",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.027Z",
      "rtime": "2014-01-20T02:05:24.874Z",
      "wtime": "2014-01-20T02:05:25.982Z",
      "exists": true,
      "encoding": "utf8",
      "source": "function bar() {\n    if (1) return 1;\n}\nfunction foo() {\n    if (1) { return 1; }\n}\nfunction baz() {\n    if (1) return 2; else return 1;\n}\n",
      "content": "function bar() {\n    if (1) return 1;\n}\nfunction foo() {\n    if (1) { return 1; }\n}\nfunction baz() {\n    if (1) return 2; else return 1;\n}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "if_return.js",
      "date": "2014-01-20T02:05:21.027Z",
      "slug": "test-features-if-return",
      "url": "/test/features/if_return.js",
      "urls": [
        "/test/features/if_return.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "function bar() {\n    if (1) return 1;\n}\nfunction foo() {\n    if (1) { return 1; }\n}\nfunction baz() {\n    if (1) return 2; else return 1;\n}\n",
      "rendered": true,
      "contentRendered": "function bar() {\n    if (1) return 1;\n}\nfunction foo() {\n    if (1) { return 1; }\n}\nfunction baz() {\n    if (1) return 2; else return 1;\n}\n",
      "contentRenderedWithoutLayouts": "function bar() {\n    if (1) return 1;\n}\nfunction foo() {\n    if (1) { return 1; }\n}\nfunction baz() {\n    if (1) return 2; else return 1;\n}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/increment_decrement.coffee",
      "relativePath": "test/features/increment_decrement.coffee",
      "basename": "increment_decrement",
      "outBasename": "increment_decrement",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "increment_decrement.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/increment_decrement.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "increment_decrement.coffee",
      "relativeOutPath": "test/features/increment_decrement.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/increment_decrement",
      "relativeOutBase": "test/features/increment_decrement",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.048Z",
      "rtime": "2014-01-20T02:05:24.882Z",
      "wtime": "2014-01-20T02:05:25.994Z",
      "exists": true,
      "encoding": "utf8",
      "source": "a++\n++a\n--a\na--\na++ + a\na-- - a\n",
      "content": "a++\n++a\n--a\na--\na++ + a\na-- - a\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "increment_decrement.coffee",
      "date": "2014-01-20T02:05:21.048Z",
      "slug": "test-features-increment-decrement",
      "url": "/test/features/increment_decrement.coffee",
      "urls": [
        "/test/features/increment_decrement.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "a++\n++a\n--a\na--\na++ + a\na-- - a\n",
      "rendered": true,
      "contentRendered": "a++\n++a\n--a\na--\na++ + a\na-- - a\n",
      "contentRenderedWithoutLayouts": "a++\n++a\n--a\na--\na++ + a\na-- - a\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/increment_decrement.js",
      "relativePath": "test/features/increment_decrement.js",
      "basename": "increment_decrement",
      "outBasename": "increment_decrement",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "increment_decrement.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/increment_decrement.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "increment_decrement.js",
      "relativeOutPath": "test/features/increment_decrement.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/increment_decrement",
      "relativeOutBase": "test/features/increment_decrement",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.067Z",
      "rtime": "2014-01-20T02:05:24.888Z",
      "wtime": "2014-01-20T02:05:26.003Z",
      "exists": true,
      "encoding": "utf8",
      "source": "a++;\n++a;\n--a;\na--;\na+++a;\na---a;\n",
      "content": "a++;\n++a;\n--a;\na--;\na+++a;\na---a;\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "increment_decrement.js",
      "date": "2014-01-20T02:05:21.067Z",
      "slug": "test-features-increment-decrement",
      "url": "/test/features/increment_decrement.js",
      "urls": [
        "/test/features/increment_decrement.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "a++;\n++a;\n--a;\na--;\na+++a;\na---a;\n",
      "rendered": true,
      "contentRendered": "a++;\n++a;\n--a;\na--;\na+++a;\na---a;\n",
      "contentRenderedWithoutLayouts": "a++;\n++a;\n--a;\na--;\na+++a;\na---a;\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/index.coffee",
      "relativePath": "test/features/index.coffee",
      "basename": "index",
      "outBasename": "index",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "index.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/index.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "index.coffee",
      "relativeOutPath": "test/features/index.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/index",
      "relativeOutBase": "test/features/index",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.083Z",
      "rtime": "2014-01-20T02:05:24.893Z",
      "wtime": "2014-01-20T02:05:26.011Z",
      "exists": true,
      "encoding": "utf8",
      "source": "a[x] = 2\n",
      "content": "a[x] = 2\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "index.coffee",
      "date": "2014-01-20T02:05:21.083Z",
      "slug": "test-features-index",
      "url": "/test/features/index.coffee",
      "urls": [
        "/test/features/index.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "a[x] = 2\n",
      "rendered": true,
      "contentRendered": "a[x] = 2\n",
      "contentRenderedWithoutLayouts": "a[x] = 2\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/index.js",
      "relativePath": "test/features/index.js",
      "basename": "index",
      "outBasename": "index",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "index.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/index.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "index.js",
      "relativeOutPath": "test/features/index.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/index",
      "relativeOutBase": "test/features/index",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.099Z",
      "rtime": "2014-01-20T02:05:24.898Z",
      "wtime": "2014-01-20T02:05:26.009Z",
      "exists": true,
      "encoding": "utf8",
      "source": "a[x] = 2",
      "content": "a[x] = 2",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "index.js",
      "date": "2014-01-20T02:05:21.099Z",
      "slug": "test-features-index",
      "url": "/test/features/index.js",
      "urls": [
        "/test/features/index.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "a[x] = 2",
      "rendered": true,
      "contentRendered": "a[x] = 2",
      "contentRenderedWithoutLayouts": "a[x] = 2",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/instanceof.coffee",
      "relativePath": "test/features/instanceof.coffee",
      "basename": "instanceof",
      "outBasename": "instanceof",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "instanceof.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/instanceof.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "instanceof.coffee",
      "relativeOutPath": "test/features/instanceof.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/instanceof",
      "relativeOutBase": "test/features/instanceof",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.115Z",
      "rtime": "2014-01-20T02:05:24.902Z",
      "wtime": "2014-01-20T02:05:26.015Z",
      "exists": true,
      "encoding": "utf8",
      "source": "0 instanceof a\n(1 not instanceof a)\n!!(2 instanceof a)\n(3 not instanceof a)\n4  if a instanceof b\n5  unless a instanceof b\n(6 not instanceof a) or b\n(7 not instanceof a) + b\n8  if (a not instanceof b) or c\n9  if (a not instanceof b) + c\n",
      "content": "0 instanceof a\n(1 not instanceof a)\n!!(2 instanceof a)\n(3 not instanceof a)\n4  if a instanceof b\n5  unless a instanceof b\n(6 not instanceof a) or b\n(7 not instanceof a) + b\n8  if (a not instanceof b) or c\n9  if (a not instanceof b) + c\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "instanceof.coffee",
      "date": "2014-01-20T02:05:21.115Z",
      "slug": "test-features-instanceof",
      "url": "/test/features/instanceof.coffee",
      "urls": [
        "/test/features/instanceof.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "0 instanceof a\n(1 not instanceof a)\n!!(2 instanceof a)\n(3 not instanceof a)\n4  if a instanceof b\n5  unless a instanceof b\n(6 not instanceof a) or b\n(7 not instanceof a) + b\n8  if (a not instanceof b) or c\n9  if (a not instanceof b) + c\n",
      "rendered": true,
      "contentRendered": "0 instanceof a\n(1 not instanceof a)\n!!(2 instanceof a)\n(3 not instanceof a)\n4  if a instanceof b\n5  unless a instanceof b\n(6 not instanceof a) or b\n(7 not instanceof a) + b\n8  if (a not instanceof b) or c\n9  if (a not instanceof b) + c\n",
      "contentRenderedWithoutLayouts": "0 instanceof a\n(1 not instanceof a)\n!!(2 instanceof a)\n(3 not instanceof a)\n4  if a instanceof b\n5  unless a instanceof b\n(6 not instanceof a) or b\n(7 not instanceof a) + b\n8  if (a not instanceof b) or c\n9  if (a not instanceof b) + c\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/instanceof.js",
      "relativePath": "test/features/instanceof.js",
      "basename": "instanceof",
      "outBasename": "instanceof",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "instanceof.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/instanceof.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "instanceof.js",
      "relativeOutPath": "test/features/instanceof.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/instanceof",
      "relativeOutBase": "test/features/instanceof",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.135Z",
      "rtime": "2014-01-20T02:05:24.908Z",
      "wtime": "2014-01-20T02:05:26.019Z",
      "exists": true,
      "encoding": "utf8",
      "source": "0 instanceof a;\n!(1 instanceof a);\n!!(2 instanceof a);\n!!!(3 instanceof a);\nif(a instanceof b) 4;\nif(!(a instanceof b)) 5;\n!(6 instanceof a) || b;\n(!(7 instanceof a)) + b;\nif(!(a instanceof b) || c) 8;\nif(!(a instanceof b) + c) 9;\n",
      "content": "0 instanceof a;\n!(1 instanceof a);\n!!(2 instanceof a);\n!!!(3 instanceof a);\nif(a instanceof b) 4;\nif(!(a instanceof b)) 5;\n!(6 instanceof a) || b;\n(!(7 instanceof a)) + b;\nif(!(a instanceof b) || c) 8;\nif(!(a instanceof b) + c) 9;\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "instanceof.js",
      "date": "2014-01-20T02:05:21.135Z",
      "slug": "test-features-instanceof",
      "url": "/test/features/instanceof.js",
      "urls": [
        "/test/features/instanceof.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "0 instanceof a;\n!(1 instanceof a);\n!!(2 instanceof a);\n!!!(3 instanceof a);\nif(a instanceof b) 4;\nif(!(a instanceof b)) 5;\n!(6 instanceof a) || b;\n(!(7 instanceof a)) + b;\nif(!(a instanceof b) || c) 8;\nif(!(a instanceof b) + c) 9;\n",
      "rendered": true,
      "contentRendered": "0 instanceof a;\n!(1 instanceof a);\n!!(2 instanceof a);\n!!!(3 instanceof a);\nif(a instanceof b) 4;\nif(!(a instanceof b)) 5;\n!(6 instanceof a) || b;\n(!(7 instanceof a)) + b;\nif(!(a instanceof b) || c) 8;\nif(!(a instanceof b) + c) 9;\n",
      "contentRenderedWithoutLayouts": "0 instanceof a;\n!(1 instanceof a);\n!!(2 instanceof a);\n!!!(3 instanceof a);\nif(a instanceof b) 4;\nif(!(a instanceof b)) 5;\n!(6 instanceof a) || b;\n(!(7 instanceof a)) + b;\nif(!(a instanceof b) || c) 8;\nif(!(a instanceof b) + c) 9;\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/invocation_object_literal_first.coffee",
      "relativePath": "test/features/invocation_object_literal_first.coffee",
      "basename": "invocation_object_literal_first",
      "outBasename": "invocation_object_literal_first",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "invocation_object_literal_first.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/invocation_object_literal_first.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "invocation_object_literal_first.coffee",
      "relativeOutPath": "test/features/invocation_object_literal_first.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/invocation_object_literal_first",
      "relativeOutBase": "test/features/invocation_object_literal_first",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.151Z",
      "rtime": "2014-01-20T02:05:24.912Z",
      "wtime": "2014-01-20T02:05:26.024Z",
      "exists": true,
      "encoding": "utf8",
      "source": "test\n  url: url\n, options or {}\n",
      "content": "test\n  url: url\n, options or {}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "invocation_object_literal_first.coffee",
      "date": "2014-01-20T02:05:21.151Z",
      "slug": "test-features-invocation-object-literal-first",
      "url": "/test/features/invocation_object_literal_first.coffee",
      "urls": [
        "/test/features/invocation_object_literal_first.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "test\n  url: url\n, options or {}\n",
      "rendered": true,
      "contentRendered": "test\n  url: url\n, options or {}\n",
      "contentRenderedWithoutLayouts": "test\n  url: url\n, options or {}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/invocation_object_literal_first.js",
      "relativePath": "test/features/invocation_object_literal_first.js",
      "basename": "invocation_object_literal_first",
      "outBasename": "invocation_object_literal_first",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "invocation_object_literal_first.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/invocation_object_literal_first.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "invocation_object_literal_first.js",
      "relativeOutPath": "test/features/invocation_object_literal_first.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/invocation_object_literal_first",
      "relativeOutBase": "test/features/invocation_object_literal_first",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.168Z",
      "rtime": "2014-01-20T02:05:24.917Z",
      "wtime": "2014-01-20T02:05:26.030Z",
      "exists": true,
      "encoding": "utf8",
      "source": "test({url: url}, options || {});\n",
      "content": "test({url: url}, options || {});\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "invocation_object_literal_first.js",
      "date": "2014-01-20T02:05:21.168Z",
      "slug": "test-features-invocation-object-literal-first",
      "url": "/test/features/invocation_object_literal_first.js",
      "urls": [
        "/test/features/invocation_object_literal_first.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "test({url: url}, options || {});\n",
      "rendered": true,
      "contentRendered": "test({url: url}, options || {});\n",
      "contentRenderedWithoutLayouts": "test({url: url}, options || {});\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/jquery_wrapper.coffee",
      "relativePath": "test/features/jquery_wrapper.coffee",
      "basename": "jquery_wrapper",
      "outBasename": "jquery_wrapper",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "jquery_wrapper.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/jquery_wrapper.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "jquery_wrapper.coffee",
      "relativeOutPath": "test/features/jquery_wrapper.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/jquery_wrapper",
      "relativeOutBase": "test/features/jquery_wrapper",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.185Z",
      "rtime": "2014-01-20T02:05:24.922Z",
      "wtime": "2014-01-20T02:05:26.031Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(($) ->\n  new jQuery.fn.init(selector, context)\n) jQuery\n",
      "content": "(($) ->\n  new jQuery.fn.init(selector, context)\n) jQuery\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "jquery_wrapper.coffee",
      "date": "2014-01-20T02:05:21.185Z",
      "slug": "test-features-jquery-wrapper",
      "url": "/test/features/jquery_wrapper.coffee",
      "urls": [
        "/test/features/jquery_wrapper.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(($) ->\n  new jQuery.fn.init(selector, context)\n) jQuery\n",
      "rendered": true,
      "contentRendered": "(($) ->\n  new jQuery.fn.init(selector, context)\n) jQuery\n",
      "contentRenderedWithoutLayouts": "(($) ->\n  new jQuery.fn.init(selector, context)\n) jQuery\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/jquery_wrapper.js",
      "relativePath": "test/features/jquery_wrapper.js",
      "basename": "jquery_wrapper",
      "outBasename": "jquery_wrapper",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "jquery_wrapper.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/jquery_wrapper.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "jquery_wrapper.js",
      "relativeOutPath": "test/features/jquery_wrapper.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/jquery_wrapper",
      "relativeOutBase": "test/features/jquery_wrapper",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.201Z",
      "rtime": "2014-01-20T02:05:24.927Z",
      "wtime": "2014-01-20T02:05:26.038Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(function($) { return new jQuery.fn.init( selector, context ); })(jQuery);\n",
      "content": "(function($) { return new jQuery.fn.init( selector, context ); })(jQuery);\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "jquery_wrapper.js",
      "date": "2014-01-20T02:05:21.201Z",
      "slug": "test-features-jquery-wrapper",
      "url": "/test/features/jquery_wrapper.js",
      "urls": [
        "/test/features/jquery_wrapper.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(function($) { return new jQuery.fn.init( selector, context ); })(jQuery);\n",
      "rendered": true,
      "contentRendered": "(function($) { return new jQuery.fn.init( selector, context ); })(jQuery);\n",
      "contentRenderedWithoutLayouts": "(function($) { return new jQuery.fn.init( selector, context ); })(jQuery);\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/json_file.coffee",
      "relativePath": "test/features/json_file.coffee",
      "basename": "json_file",
      "outBasename": "json_file",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "json_file.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/json_file.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "json_file.coffee",
      "relativeOutPath": "test/features/json_file.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/json_file",
      "relativeOutBase": "test/features/json_file",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:21.218Z",
      "rtime": "2014-01-20T02:05:24.932Z",
      "wtime": "2014-01-20T02:05:26.044Z",
      "exists": true,
      "encoding": "utf8",
      "source": "module.exports = foo:\n  bar:\n    empty: []\n    oneElement: [\"one\"]\n    mixed: [\n      1\n      2\n      3\n      \"four\"\n      \"five\"\n    ]\n    nestedArray: [\n      \"1\"\n      \"2\"\n      [\n        \"3.1\"\n        \"3.2\"\n        [\n          \"3.3.1\"\n          \"3.3.2\"\n        ]\n      ]\n      \"4\"\n      \"5\"\n    ]\n    nestedMix: [\n      {\n        k1: 1\n        k2: 2\n        k3:\n          k4a: true\n          k4b: [\n            \"i\"\n            \"ii\"\n          ]\n      }\n      \"k5\"\n      {\n        k6: 6\n        k7: 7\n      }\n      {\n        k8: 8\n        k9: 9\n      }\n      \"k10\"\n    ]",
      "content": "module.exports = foo:\n  bar:\n    empty: []\n    oneElement: [\"one\"]\n    mixed: [\n      1\n      2\n      3\n      \"four\"\n      \"five\"\n    ]\n    nestedArray: [\n      \"1\"\n      \"2\"\n      [\n        \"3.1\"\n        \"3.2\"\n        [\n          \"3.3.1\"\n          \"3.3.2\"\n        ]\n      ]\n      \"4\"\n      \"5\"\n    ]\n    nestedMix: [\n      {\n        k1: 1\n        k2: 2\n        k3:\n          k4a: true\n          k4b: [\n            \"i\"\n            \"ii\"\n          ]\n      }\n      \"k5\"\n      {\n        k6: 6\n        k7: 7\n      }\n      {\n        k8: 8\n        k9: 9\n      }\n      \"k10\"\n    ]",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "json_file.coffee",
      "date": "2014-01-20T02:05:21.218Z",
      "slug": "test-features-json-file",
      "url": "/test/features/json_file.coffee",
      "urls": [
        "/test/features/json_file.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "module.exports = foo:\n  bar:\n    empty: []\n    oneElement: [\"one\"]\n    mixed: [\n      1\n      2\n      3\n      \"four\"\n      \"five\"\n    ]\n    nestedArray: [\n      \"1\"\n      \"2\"\n      [\n        \"3.1\"\n        \"3.2\"\n        [\n          \"3.3.1\"\n          \"3.3.2\"\n        ]\n      ]\n      \"4\"\n      \"5\"\n    ]\n    nestedMix: [\n      {\n        k1: 1\n        k2: 2\n        k3:\n          k4a: true\n          k4b: [\n            \"i\"\n            \"ii\"\n          ]\n      }\n      \"k5\"\n      {\n        k6: 6\n        k7: 7\n      }\n      {\n        k8: 8\n        k9: 9\n      }\n      \"k10\"\n    ]",
      "rendered": true,
      "contentRendered": "module.exports = foo:\n  bar:\n    empty: []\n    oneElement: [\"one\"]\n    mixed: [\n      1\n      2\n      3\n      \"four\"\n      \"five\"\n    ]\n    nestedArray: [\n      \"1\"\n      \"2\"\n      [\n        \"3.1\"\n        \"3.2\"\n        [\n          \"3.3.1\"\n          \"3.3.2\"\n        ]\n      ]\n      \"4\"\n      \"5\"\n    ]\n    nestedMix: [\n      {\n        k1: 1\n        k2: 2\n        k3:\n          k4a: true\n          k4b: [\n            \"i\"\n            \"ii\"\n          ]\n      }\n      \"k5\"\n      {\n        k6: 6\n        k7: 7\n      }\n      {\n        k8: 8\n        k9: 9\n      }\n      \"k10\"\n    ]",
      "contentRenderedWithoutLayouts": "module.exports = foo:\n  bar:\n    empty: []\n    oneElement: [\"one\"]\n    mixed: [\n      1\n      2\n      3\n      \"four\"\n      \"five\"\n    ]\n    nestedArray: [\n      \"1\"\n      \"2\"\n      [\n        \"3.1\"\n        \"3.2\"\n        [\n          \"3.3.1\"\n          \"3.3.2\"\n        ]\n      ]\n      \"4\"\n      \"5\"\n    ]\n    nestedMix: [\n      {\n        k1: 1\n        k2: 2\n        k3:\n          k4a: true\n          k4b: [\n            \"i\"\n            \"ii\"\n          ]\n      }\n      \"k5\"\n      {\n        k6: 6\n        k7: 7\n      }\n      {\n        k8: 8\n        k9: 9\n      }\n      \"k10\"\n    ]",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/json_file.json",
      "relativePath": "test/features/json_file.json",
      "basename": "json_file",
      "outBasename": "json_file",
      "extension": "json",
      "outExtension": "json",
      "extensions": [
        "json"
      ],
      "filename": "json_file.json",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/json_file.json",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "json_file.json",
      "relativeOutPath": "test/features/json_file.json",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/json_file",
      "relativeOutBase": "test/features/json_file",
      "contentType": "application/json",
      "outContentType": "application/json",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:21.235Z",
      "rtime": "2014-01-20T02:05:24.942Z",
      "wtime": "2014-01-20T02:05:26.042Z",
      "exists": true,
      "encoding": "utf8",
      "source": "{\n    \"foo2\": {\n        \"bar\": {\n            \"empty\": [],\n            \"oneElement\": [\"one\"],\n            \"mixed\": [1,2,3,\"four\",\"five\"],\n            \"nestedArray\": [\n                \"1\",\n                \"2\",\n                [\"3.1\", \"3.2\",[\"3.3.1\", \"3.3.2\"]],\n                \"4\",\n                \"5\"\n            ],\n            \"nestedMix\": [\n                {\n                    \"k1\": 1,\n                    \"k2\": 2,\n                    \"k3\": {\n                        \"k4a\":true,\n                        \"k4b\":[\"i\", \"ii\"]\n                    }\n                },\n                \"k5\",\n                {\n                    \"k6\": 6,\n                    \"k7\": 7\n\n                },\n                {\n                    \"k8\": 8,\n                    \"k9\": 9\n\n                },\n                \"k10\"\n            ]\n        }\n    }\n}",
      "content": "{\n    \"foo2\": {\n        \"bar\": {\n            \"empty\": [],\n            \"oneElement\": [\"one\"],\n            \"mixed\": [1,2,3,\"four\",\"five\"],\n            \"nestedArray\": [\n                \"1\",\n                \"2\",\n                [\"3.1\", \"3.2\",[\"3.3.1\", \"3.3.2\"]],\n                \"4\",\n                \"5\"\n            ],\n            \"nestedMix\": [\n                {\n                    \"k1\": 1,\n                    \"k2\": 2,\n                    \"k3\": {\n                        \"k4a\":true,\n                        \"k4b\":[\"i\", \"ii\"]\n                    }\n                },\n                \"k5\",\n                {\n                    \"k6\": 6,\n                    \"k7\": 7\n\n                },\n                {\n                    \"k8\": 8,\n                    \"k9\": 9\n\n                },\n                \"k10\"\n            ]\n        }\n    }\n}",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "json_file.json",
      "date": "2014-01-20T02:05:21.235Z",
      "slug": "test-features-json-file",
      "url": "/test/features/json_file.json",
      "urls": [
        "/test/features/json_file.json"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "{\n    \"foo2\": {\n        \"bar\": {\n            \"empty\": [],\n            \"oneElement\": [\"one\"],\n            \"mixed\": [1,2,3,\"four\",\"five\"],\n            \"nestedArray\": [\n                \"1\",\n                \"2\",\n                [\"3.1\", \"3.2\",[\"3.3.1\", \"3.3.2\"]],\n                \"4\",\n                \"5\"\n            ],\n            \"nestedMix\": [\n                {\n                    \"k1\": 1,\n                    \"k2\": 2,\n                    \"k3\": {\n                        \"k4a\":true,\n                        \"k4b\":[\"i\", \"ii\"]\n                    }\n                },\n                \"k5\",\n                {\n                    \"k6\": 6,\n                    \"k7\": 7\n\n                },\n                {\n                    \"k8\": 8,\n                    \"k9\": 9\n\n                },\n                \"k10\"\n            ]\n        }\n    }\n}",
      "rendered": true,
      "contentRendered": "{\n    \"foo2\": {\n        \"bar\": {\n            \"empty\": [],\n            \"oneElement\": [\"one\"],\n            \"mixed\": [1,2,3,\"four\",\"five\"],\n            \"nestedArray\": [\n                \"1\",\n                \"2\",\n                [\"3.1\", \"3.2\",[\"3.3.1\", \"3.3.2\"]],\n                \"4\",\n                \"5\"\n            ],\n            \"nestedMix\": [\n                {\n                    \"k1\": 1,\n                    \"k2\": 2,\n                    \"k3\": {\n                        \"k4a\":true,\n                        \"k4b\":[\"i\", \"ii\"]\n                    }\n                },\n                \"k5\",\n                {\n                    \"k6\": 6,\n                    \"k7\": 7\n\n                },\n                {\n                    \"k8\": 8,\n                    \"k9\": 9\n\n                },\n                \"k10\"\n            ]\n        }\n    }\n}",
      "contentRenderedWithoutLayouts": "{\n    \"foo2\": {\n        \"bar\": {\n            \"empty\": [],\n            \"oneElement\": [\"one\"],\n            \"mixed\": [1,2,3,\"four\",\"five\"],\n            \"nestedArray\": [\n                \"1\",\n                \"2\",\n                [\"3.1\", \"3.2\",[\"3.3.1\", \"3.3.2\"]],\n                \"4\",\n                \"5\"\n            ],\n            \"nestedMix\": [\n                {\n                    \"k1\": 1,\n                    \"k2\": 2,\n                    \"k3\": {\n                        \"k4a\":true,\n                        \"k4b\":[\"i\", \"ii\"]\n                    }\n                },\n                \"k5\",\n                {\n                    \"k6\": 6,\n                    \"k7\": 7\n\n                },\n                {\n                    \"k8\": 8,\n                    \"k9\": 9\n\n                },\n                \"k10\"\n            ]\n        }\n    }\n}",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/loop.coffee",
      "relativePath": "test/features/loop.coffee",
      "basename": "loop",
      "outBasename": "loop",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "loop.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/loop.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "loop.coffee",
      "relativeOutPath": "test/features/loop.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/loop",
      "relativeOutBase": "test/features/loop",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.252Z",
      "rtime": "2014-01-20T02:05:24.948Z",
      "wtime": "2014-01-20T02:05:26.052Z",
      "exists": true,
      "encoding": "utf8",
      "source": "loop\n  continue\nloop\n  x()\nloop\n  continue\nloop\n  x()\nx()  while 0.0\nloop\n  x()\n",
      "content": "loop\n  continue\nloop\n  x()\nloop\n  continue\nloop\n  x()\nx()  while 0.0\nloop\n  x()\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "loop.coffee",
      "date": "2014-01-20T02:05:21.252Z",
      "slug": "test-features-loop",
      "url": "/test/features/loop.coffee",
      "urls": [
        "/test/features/loop.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "loop\n  continue\nloop\n  x()\nloop\n  continue\nloop\n  x()\nx()  while 0.0\nloop\n  x()\n",
      "rendered": true,
      "contentRendered": "loop\n  continue\nloop\n  x()\nloop\n  continue\nloop\n  x()\nx()  while 0.0\nloop\n  x()\n",
      "contentRenderedWithoutLayouts": "loop\n  continue\nloop\n  x()\nloop\n  continue\nloop\n  x()\nx()  while 0.0\nloop\n  x()\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/loop.js",
      "relativePath": "test/features/loop.js",
      "basename": "loop",
      "outBasename": "loop",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "loop.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/loop.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "loop.js",
      "relativeOutPath": "test/features/loop.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/loop",
      "relativeOutBase": "test/features/loop",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.269Z",
      "rtime": "2014-01-20T02:05:24.953Z",
      "wtime": "2014-01-20T02:05:26.056Z",
      "exists": true,
      "encoding": "utf8",
      "source": "while (true) {}\nwhile (true) { x(); }\nwhile (100) {}\nwhile (100) { x(); }\nwhile (0.0) { x(); }\nwhile (0.01) { x(); }\n",
      "content": "while (true) {}\nwhile (true) { x(); }\nwhile (100) {}\nwhile (100) { x(); }\nwhile (0.0) { x(); }\nwhile (0.01) { x(); }\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "loop.js",
      "date": "2014-01-20T02:05:21.269Z",
      "slug": "test-features-loop",
      "url": "/test/features/loop.js",
      "urls": [
        "/test/features/loop.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "while (true) {}\nwhile (true) { x(); }\nwhile (100) {}\nwhile (100) { x(); }\nwhile (0.0) { x(); }\nwhile (0.01) { x(); }\n",
      "rendered": true,
      "contentRendered": "while (true) {}\nwhile (true) { x(); }\nwhile (100) {}\nwhile (100) { x(); }\nwhile (0.0) { x(); }\nwhile (0.01) { x(); }\n",
      "contentRenderedWithoutLayouts": "while (true) {}\nwhile (true) { x(); }\nwhile (100) {}\nwhile (100) { x(); }\nwhile (0.0) { x(); }\nwhile (0.01) { x(); }\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/no_return.coffee",
      "relativePath": "test/features/no_return.coffee",
      "basename": "no_return",
      "outBasename": "no_return",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "no_return.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/no_return.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "no_return.coffee",
      "relativeOutPath": "test/features/no_return.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/no_return",
      "relativeOutBase": "test/features/no_return",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:21.286Z",
      "rtime": "2014-01-20T02:05:24.961Z",
      "wtime": "2014-01-20T02:05:26.058Z",
      "exists": true,
      "encoding": "utf8",
      "source": "noReturn = ->\n  f()\n  return\nnoReturnIf1 = ->\n  if condition\n    doSomething()\n    1\n  else\n    doSomethingElse()\n  return\nnoReturnIf2 = ->\n  if condition\n    doSomething()\n  else\n    doSomethingElse()\n    2\n  return\n",
      "content": "noReturn = ->\n  f()\n  return\nnoReturnIf1 = ->\n  if condition\n    doSomething()\n    1\n  else\n    doSomethingElse()\n  return\nnoReturnIf2 = ->\n  if condition\n    doSomething()\n  else\n    doSomethingElse()\n    2\n  return\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "no_return.coffee",
      "date": "2014-01-20T02:05:21.286Z",
      "slug": "test-features-no-return",
      "url": "/test/features/no_return.coffee",
      "urls": [
        "/test/features/no_return.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "noReturn = ->\n  f()\n  return\nnoReturnIf1 = ->\n  if condition\n    doSomething()\n    1\n  else\n    doSomethingElse()\n  return\nnoReturnIf2 = ->\n  if condition\n    doSomething()\n  else\n    doSomethingElse()\n    2\n  return\n",
      "rendered": true,
      "contentRendered": "noReturn = ->\n  f()\n  return\nnoReturnIf1 = ->\n  if condition\n    doSomething()\n    1\n  else\n    doSomethingElse()\n  return\nnoReturnIf2 = ->\n  if condition\n    doSomething()\n  else\n    doSomethingElse()\n    2\n  return\n",
      "contentRenderedWithoutLayouts": "noReturn = ->\n  f()\n  return\nnoReturnIf1 = ->\n  if condition\n    doSomething()\n    1\n  else\n    doSomethingElse()\n  return\nnoReturnIf2 = ->\n  if condition\n    doSomething()\n  else\n    doSomethingElse()\n    2\n  return\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/no_return.js",
      "relativePath": "test/features/no_return.js",
      "basename": "no_return",
      "outBasename": "no_return",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "no_return.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/no_return.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "no_return.js",
      "relativeOutPath": "test/features/no_return.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/no_return",
      "relativeOutBase": "test/features/no_return",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:21.303Z",
      "rtime": "2014-01-20T02:05:24.968Z",
      "wtime": "2014-01-20T02:05:26.063Z",
      "exists": true,
      "encoding": "utf8",
      "source": "function noReturn() {\n  f();\n}\n\nfunction noReturnIf1() {\n  if (condition) {\n    doSomething();\n    return 1;\n  }\n  else {\n    doSomethingElse();\n  }\n}\n\nfunction noReturnIf2() {\n  if (condition) {\n    doSomething();\n  }\n  else {\n    doSomethingElse();\n    return 2;\n  }\n}\n",
      "content": "function noReturn() {\n  f();\n}\n\nfunction noReturnIf1() {\n  if (condition) {\n    doSomething();\n    return 1;\n  }\n  else {\n    doSomethingElse();\n  }\n}\n\nfunction noReturnIf2() {\n  if (condition) {\n    doSomething();\n  }\n  else {\n    doSomethingElse();\n    return 2;\n  }\n}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "no_return.js",
      "date": "2014-01-20T02:05:21.303Z",
      "slug": "test-features-no-return",
      "url": "/test/features/no_return.js",
      "urls": [
        "/test/features/no_return.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "function noReturn() {\n  f();\n}\n\nfunction noReturnIf1() {\n  if (condition) {\n    doSomething();\n    return 1;\n  }\n  else {\n    doSomethingElse();\n  }\n}\n\nfunction noReturnIf2() {\n  if (condition) {\n    doSomething();\n  }\n  else {\n    doSomethingElse();\n    return 2;\n  }\n}\n",
      "rendered": true,
      "contentRendered": "function noReturn() {\n  f();\n}\n\nfunction noReturnIf1() {\n  if (condition) {\n    doSomething();\n    return 1;\n  }\n  else {\n    doSomethingElse();\n  }\n}\n\nfunction noReturnIf2() {\n  if (condition) {\n    doSomething();\n  }\n  else {\n    doSomethingElse();\n    return 2;\n  }\n}\n",
      "contentRenderedWithoutLayouts": "function noReturn() {\n  f();\n}\n\nfunction noReturnIf1() {\n  if (condition) {\n    doSomething();\n    return 1;\n  }\n  else {\n    doSomethingElse();\n  }\n}\n\nfunction noReturnIf2() {\n  if (condition) {\n    doSomething();\n  }\n  else {\n    doSomethingElse();\n    return 2;\n  }\n}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/not.coffee",
      "relativePath": "test/features/not.coffee",
      "basename": "not",
      "outBasename": "not",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "not.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/not.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "not.coffee",
      "relativeOutPath": "test/features/not.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/not",
      "relativeOutBase": "test/features/not",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.320Z",
      "rtime": "2014-01-20T02:05:24.973Z",
      "wtime": "2014-01-20T02:05:26.069Z",
      "exists": true,
      "encoding": "utf8",
      "source": "not a\n",
      "content": "not a\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "not.coffee",
      "date": "2014-01-20T02:05:21.320Z",
      "slug": "test-features-not",
      "url": "/test/features/not.coffee",
      "urls": [
        "/test/features/not.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "not a\n",
      "rendered": true,
      "contentRendered": "not a\n",
      "contentRenderedWithoutLayouts": "not a\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/not.js",
      "relativePath": "test/features/not.js",
      "basename": "not",
      "outBasename": "not",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "not.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/not.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "not.js",
      "relativeOutPath": "test/features/not.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/not",
      "relativeOutBase": "test/features/not",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.337Z",
      "rtime": "2014-01-20T02:05:24.978Z",
      "wtime": "2014-01-20T02:05:26.076Z",
      "exists": true,
      "encoding": "utf8",
      "source": "!a",
      "content": "!a",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "not.js",
      "date": "2014-01-20T02:05:21.337Z",
      "slug": "test-features-not",
      "url": "/test/features/not.js",
      "urls": [
        "/test/features/not.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "!a",
      "rendered": true,
      "contentRendered": "!a",
      "contentRenderedWithoutLayouts": "!a",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/not_not.coffee",
      "relativePath": "test/features/not_not.coffee",
      "basename": "not_not",
      "outBasename": "not_not",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "not_not.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/not_not.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "not_not.coffee",
      "relativeOutPath": "test/features/not_not.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/not_not",
      "relativeOutBase": "test/features/not_not",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.354Z",
      "rtime": "2014-01-20T02:05:24.983Z",
      "wtime": "2014-01-20T02:05:26.080Z",
      "exists": true,
      "encoding": "utf8",
      "source": "not x\n!!x\nnot x\n!!x\nnot x\n",
      "content": "not x\n!!x\nnot x\n!!x\nnot x\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "not_not.coffee",
      "date": "2014-01-20T02:05:21.354Z",
      "slug": "test-features-not-not",
      "url": "/test/features/not_not.coffee",
      "urls": [
        "/test/features/not_not.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "not x\n!!x\nnot x\n!!x\nnot x\n",
      "rendered": true,
      "contentRendered": "not x\n!!x\nnot x\n!!x\nnot x\n",
      "contentRenderedWithoutLayouts": "not x\n!!x\nnot x\n!!x\nnot x\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/not_not.js",
      "relativePath": "test/features/not_not.js",
      "basename": "not_not",
      "outBasename": "not_not",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "not_not.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/not_not.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "not_not.js",
      "relativeOutPath": "test/features/not_not.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/not_not",
      "relativeOutBase": "test/features/not_not",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.374Z",
      "rtime": "2014-01-20T02:05:24.988Z",
      "wtime": "2014-01-20T02:05:26.084Z",
      "exists": true,
      "encoding": "utf8",
      "source": "!x;\n!!x;\n!!!x;\n!!!!x;\n!!!!!x;\n",
      "content": "!x;\n!!x;\n!!!x;\n!!!!x;\n!!!!!x;\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "not_not.js",
      "date": "2014-01-20T02:05:21.374Z",
      "slug": "test-features-not-not",
      "url": "/test/features/not_not.js",
      "urls": [
        "/test/features/not_not.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "!x;\n!!x;\n!!!x;\n!!!!x;\n!!!!!x;\n",
      "rendered": true,
      "contentRendered": "!x;\n!!x;\n!!!x;\n!!!!x;\n!!!!!x;\n",
      "contentRenderedWithoutLayouts": "!x;\n!!x;\n!!!x;\n!!!!x;\n!!!!!x;\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/object_literal_at_index.coffee",
      "relativePath": "test/features/object_literal_at_index.coffee",
      "basename": "object_literal_at_index",
      "outBasename": "object_literal_at_index",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "object_literal_at_index.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/object_literal_at_index.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "object_literal_at_index.coffee",
      "relativeOutPath": "test/features/object_literal_at_index.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/object_literal_at_index",
      "relativeOutBase": "test/features/object_literal_at_index",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.395Z",
      "rtime": "2014-01-20T02:05:24.993Z",
      "wtime": "2014-01-20T02:05:26.089Z",
      "exists": true,
      "encoding": "utf8",
      "source": "o = {}\no[{\n  a: 1\n  b: 2\n}] = 3\no[c: 4] = 5\n",
      "content": "o = {}\no[{\n  a: 1\n  b: 2\n}] = 3\no[c: 4] = 5\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "object_literal_at_index.coffee",
      "date": "2014-01-20T02:05:21.395Z",
      "slug": "test-features-object-literal-at-index",
      "url": "/test/features/object_literal_at_index.coffee",
      "urls": [
        "/test/features/object_literal_at_index.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "o = {}\no[{\n  a: 1\n  b: 2\n}] = 3\no[c: 4] = 5\n",
      "rendered": true,
      "contentRendered": "o = {}\no[{\n  a: 1\n  b: 2\n}] = 3\no[c: 4] = 5\n",
      "contentRenderedWithoutLayouts": "o = {}\no[{\n  a: 1\n  b: 2\n}] = 3\no[c: 4] = 5\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/object_literal_at_index.js",
      "relativePath": "test/features/object_literal_at_index.js",
      "basename": "object_literal_at_index",
      "outBasename": "object_literal_at_index",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "object_literal_at_index.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/object_literal_at_index.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "object_literal_at_index.js",
      "relativeOutPath": "test/features/object_literal_at_index.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/object_literal_at_index",
      "relativeOutBase": "test/features/object_literal_at_index",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.413Z",
      "rtime": "2014-01-20T02:05:24.998Z",
      "wtime": "2014-01-20T02:05:26.091Z",
      "exists": true,
      "encoding": "utf8",
      "source": "var o = {}\n\no[{a: 1, b: 2}] = 3\n\no[{c: 4}] = 5\n",
      "content": "var o = {}\n\no[{a: 1, b: 2}] = 3\n\no[{c: 4}] = 5\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "object_literal_at_index.js",
      "date": "2014-01-20T02:05:21.413Z",
      "slug": "test-features-object-literal-at-index",
      "url": "/test/features/object_literal_at_index.js",
      "urls": [
        "/test/features/object_literal_at_index.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "var o = {}\n\no[{a: 1, b: 2}] = 3\n\no[{c: 4}] = 5\n",
      "rendered": true,
      "contentRendered": "var o = {}\n\no[{a: 1, b: 2}] = 3\n\no[{c: 4}] = 5\n",
      "contentRenderedWithoutLayouts": "var o = {}\n\no[{a: 1, b: 2}] = 3\n\no[{c: 4}] = 5\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/object_literal_return.coffee",
      "relativePath": "test/features/object_literal_return.coffee",
      "basename": "object_literal_return",
      "outBasename": "object_literal_return",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "object_literal_return.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/object_literal_return.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "object_literal_return.coffee",
      "relativeOutPath": "test/features/object_literal_return.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/object_literal_return",
      "relativeOutBase": "test/features/object_literal_return",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.430Z",
      "rtime": "2014-01-20T02:05:25.003Z",
      "wtime": "2014-01-20T02:05:26.096Z",
      "exists": true,
      "encoding": "utf8",
      "source": "->\n  a: 1\n  b: 2\n",
      "content": "->\n  a: 1\n  b: 2\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "object_literal_return.coffee",
      "date": "2014-01-20T02:05:21.430Z",
      "slug": "test-features-object-literal-return",
      "url": "/test/features/object_literal_return.coffee",
      "urls": [
        "/test/features/object_literal_return.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "->\n  a: 1\n  b: 2\n",
      "rendered": true,
      "contentRendered": "->\n  a: 1\n  b: 2\n",
      "contentRenderedWithoutLayouts": "->\n  a: 1\n  b: 2\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/object_literal_return.js",
      "relativePath": "test/features/object_literal_return.js",
      "basename": "object_literal_return",
      "outBasename": "object_literal_return",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "object_literal_return.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/object_literal_return.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "object_literal_return.js",
      "relativeOutPath": "test/features/object_literal_return.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/object_literal_return",
      "relativeOutBase": "test/features/object_literal_return",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.446Z",
      "rtime": "2014-01-20T02:05:25.007Z",
      "wtime": "2014-01-20T02:05:26.102Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(function() { return { a: 1, b: 2 }; });\n",
      "content": "(function() { return { a: 1, b: 2 }; });\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "object_literal_return.js",
      "date": "2014-01-20T02:05:21.446Z",
      "slug": "test-features-object-literal-return",
      "url": "/test/features/object_literal_return.js",
      "urls": [
        "/test/features/object_literal_return.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(function() { return { a: 1, b: 2 }; });\n",
      "rendered": true,
      "contentRendered": "(function() { return { a: 1, b: 2 }; });\n",
      "contentRenderedWithoutLayouts": "(function() { return { a: 1, b: 2 }; });\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/object_literal_single.coffee",
      "relativePath": "test/features/object_literal_single.coffee",
      "basename": "object_literal_single",
      "outBasename": "object_literal_single",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "object_literal_single.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/object_literal_single.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "object_literal_single.coffee",
      "relativeOutPath": "test/features/object_literal_single.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/object_literal_single",
      "relativeOutBase": "test/features/object_literal_single",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.463Z",
      "rtime": "2014-01-20T02:05:25.012Z",
      "wtime": "2014-01-20T02:05:26.109Z",
      "exists": true,
      "encoding": "utf8",
      "source": "a: 1\n(\n  x: 2\n  b: 2\n)\n",
      "content": "a: 1\n(\n  x: 2\n  b: 2\n)\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "object_literal_single.coffee",
      "date": "2014-01-20T02:05:21.463Z",
      "slug": "test-features-object-literal-single",
      "url": "/test/features/object_literal_single.coffee",
      "urls": [
        "/test/features/object_literal_single.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "a: 1\n(\n  x: 2\n  b: 2\n)\n",
      "rendered": true,
      "contentRendered": "a: 1\n(\n  x: 2\n  b: 2\n)\n",
      "contentRenderedWithoutLayouts": "a: 1\n(\n  x: 2\n  b: 2\n)\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/object_literal_single.js",
      "relativePath": "test/features/object_literal_single.js",
      "basename": "object_literal_single",
      "outBasename": "object_literal_single",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "object_literal_single.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/object_literal_single.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "object_literal_single.js",
      "relativeOutPath": "test/features/object_literal_single.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/object_literal_single",
      "relativeOutBase": "test/features/object_literal_single",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.480Z",
      "rtime": "2014-01-20T02:05:25.017Z",
      "wtime": "2014-01-20T02:05:26.111Z",
      "exists": true,
      "encoding": "utf8",
      "source": "({a:1});\n({x:2, b:2});\n",
      "content": "({a:1});\n({x:2, b:2});\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "object_literal_single.js",
      "date": "2014-01-20T02:05:21.480Z",
      "slug": "test-features-object-literal-single",
      "url": "/test/features/object_literal_single.js",
      "urls": [
        "/test/features/object_literal_single.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "({a:1});\n({x:2, b:2});\n",
      "rendered": true,
      "contentRendered": "({a:1});\n({x:2, b:2});\n",
      "contentRenderedWithoutLayouts": "({a:1});\n({x:2, b:2});\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/object_literal_with_function.coffee",
      "relativePath": "test/features/object_literal_with_function.coffee",
      "basename": "object_literal_with_function",
      "outBasename": "object_literal_with_function",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "object_literal_with_function.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/object_literal_with_function.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "object_literal_with_function.coffee",
      "relativeOutPath": "test/features/object_literal_with_function.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/object_literal_with_function",
      "relativeOutBase": "test/features/object_literal_with_function",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.497Z",
      "rtime": "2014-01-20T02:05:25.022Z",
      "wtime": "2014-01-20T02:05:26.116Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = ->\n(\n  a: 2\n  b: 3\n)\n",
      "content": "x = ->\n(\n  a: 2\n  b: 3\n)\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "object_literal_with_function.coffee",
      "date": "2014-01-20T02:05:21.497Z",
      "slug": "test-features-object-literal-with-function",
      "url": "/test/features/object_literal_with_function.coffee",
      "urls": [
        "/test/features/object_literal_with_function.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = ->\n(\n  a: 2\n  b: 3\n)\n",
      "rendered": true,
      "contentRendered": "x = ->\n(\n  a: 2\n  b: 3\n)\n",
      "contentRenderedWithoutLayouts": "x = ->\n(\n  a: 2\n  b: 3\n)\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/object_literal_with_function.js",
      "relativePath": "test/features/object_literal_with_function.js",
      "basename": "object_literal_with_function",
      "outBasename": "object_literal_with_function",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "object_literal_with_function.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/object_literal_with_function.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "object_literal_with_function.js",
      "relativeOutPath": "test/features/object_literal_with_function.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/object_literal_with_function",
      "relativeOutBase": "test/features/object_literal_with_function",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.514Z",
      "rtime": "2014-01-20T02:05:25.027Z",
      "wtime": "2014-01-20T02:05:26.124Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = function() { }\n({a:2,b:3});\n",
      "content": "x = function() { }\n({a:2,b:3});\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "object_literal_with_function.js",
      "date": "2014-01-20T02:05:21.514Z",
      "slug": "test-features-object-literal-with-function",
      "url": "/test/features/object_literal_with_function.js",
      "urls": [
        "/test/features/object_literal_with_function.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = function() { }\n({a:2,b:3});\n",
      "rendered": true,
      "contentRendered": "x = function() { }\n({a:2,b:3});\n",
      "contentRenderedWithoutLayouts": "x = function() { }\n({a:2,b:3});\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/object_literals.coffee",
      "relativePath": "test/features/object_literals.coffee",
      "basename": "object_literals",
      "outBasename": "object_literals",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "object_literals.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/object_literals.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "object_literals.coffee",
      "relativeOutPath": "test/features/object_literals.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/object_literals",
      "relativeOutBase": "test/features/object_literals",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.530Z",
      "rtime": "2014-01-20T02:05:25.032Z",
      "wtime": "2014-01-20T02:05:26.129Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x =\n  x: 2\n  b: 2\n\n$.get\n  x: 2\n  b: 2\n  data:\n    2: \"post\"\n\n  lol: [\n    2\n    3\n  ]\n, 2\n",
      "content": "x =\n  x: 2\n  b: 2\n\n$.get\n  x: 2\n  b: 2\n  data:\n    2: \"post\"\n\n  lol: [\n    2\n    3\n  ]\n, 2\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "object_literals.coffee",
      "date": "2014-01-20T02:05:21.530Z",
      "slug": "test-features-object-literals",
      "url": "/test/features/object_literals.coffee",
      "urls": [
        "/test/features/object_literals.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x =\n  x: 2\n  b: 2\n\n$.get\n  x: 2\n  b: 2\n  data:\n    2: \"post\"\n\n  lol: [\n    2\n    3\n  ]\n, 2\n",
      "rendered": true,
      "contentRendered": "x =\n  x: 2\n  b: 2\n\n$.get\n  x: 2\n  b: 2\n  data:\n    2: \"post\"\n\n  lol: [\n    2\n    3\n  ]\n, 2\n",
      "contentRenderedWithoutLayouts": "x =\n  x: 2\n  b: 2\n\n$.get\n  x: 2\n  b: 2\n  data:\n    2: \"post\"\n\n  lol: [\n    2\n    3\n  ]\n, 2\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/object_literals.js",
      "relativePath": "test/features/object_literals.js",
      "basename": "object_literals",
      "outBasename": "object_literals",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "object_literals.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/object_literals.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "object_literals.js",
      "relativeOutPath": "test/features/object_literals.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/object_literals",
      "relativeOutBase": "test/features/object_literals",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.547Z",
      "rtime": "2014-01-20T02:05:25.037Z",
      "wtime": "2014-01-20T02:05:26.134Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = {x:2, b:2}; $.get({x:2, b:2, data: {2: 'post'}, lol: [2,3]}, 2)",
      "content": "x = {x:2, b:2}; $.get({x:2, b:2, data: {2: 'post'}, lol: [2,3]}, 2)",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "object_literals.js",
      "date": "2014-01-20T02:05:21.547Z",
      "slug": "test-features-object-literals",
      "url": "/test/features/object_literals.js",
      "urls": [
        "/test/features/object_literals.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = {x:2, b:2}; $.get({x:2, b:2, data: {2: 'post'}, lol: [2,3]}, 2)",
      "rendered": true,
      "contentRendered": "x = {x:2, b:2}; $.get({x:2, b:2, data: {2: 'post'}, lol: [2,3]}, 2)",
      "contentRenderedWithoutLayouts": "x = {x:2, b:2}; $.get({x:2, b:2, data: {2: 'post'}, lol: [2,3]}, 2)",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/or.coffee",
      "relativePath": "test/features/or.coffee",
      "basename": "or",
      "outBasename": "or",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "or.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/or.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "or.coffee",
      "relativeOutPath": "test/features/or.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/or",
      "relativeOutBase": "test/features/or",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.563Z",
      "rtime": "2014-01-20T02:05:25.042Z",
      "wtime": "2014-01-20T02:05:26.137Z",
      "exists": true,
      "encoding": "utf8",
      "source": "a = 2 or {}\n",
      "content": "a = 2 or {}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "or.coffee",
      "date": "2014-01-20T02:05:21.563Z",
      "slug": "test-features-or",
      "url": "/test/features/or.coffee",
      "urls": [
        "/test/features/or.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "a = 2 or {}\n",
      "rendered": true,
      "contentRendered": "a = 2 or {}\n",
      "contentRenderedWithoutLayouts": "a = 2 or {}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/or.js",
      "relativePath": "test/features/or.js",
      "basename": "or",
      "outBasename": "or",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "or.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/or.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "or.js",
      "relativeOutPath": "test/features/or.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/or",
      "relativeOutBase": "test/features/or",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.583Z",
      "rtime": "2014-01-20T02:05:25.047Z",
      "wtime": "2014-01-20T02:05:26.142Z",
      "exists": true,
      "encoding": "utf8",
      "source": "var a = 2 || {}",
      "content": "var a = 2 || {}",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "or.js",
      "date": "2014-01-20T02:05:21.583Z",
      "slug": "test-features-or",
      "url": "/test/features/or.js",
      "urls": [
        "/test/features/or.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "var a = 2 || {}",
      "rendered": true,
      "contentRendered": "var a = 2 || {}",
      "contentRenderedWithoutLayouts": "var a = 2 || {}",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/parenthesized_new.coffee",
      "relativePath": "test/features/parenthesized_new.coffee",
      "basename": "parenthesized_new",
      "outBasename": "parenthesized_new",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "parenthesized_new.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/parenthesized_new.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "parenthesized_new.coffee",
      "relativeOutPath": "test/features/parenthesized_new.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/parenthesized_new",
      "relativeOutBase": "test/features/parenthesized_new",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.601Z",
      "rtime": "2014-01-20T02:05:25.052Z",
      "wtime": "2014-01-20T02:05:26.146Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(new Date).getTime()\n",
      "content": "(new Date).getTime()\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "parenthesized_new.coffee",
      "date": "2014-01-20T02:05:21.601Z",
      "slug": "test-features-parenthesized-new",
      "url": "/test/features/parenthesized_new.coffee",
      "urls": [
        "/test/features/parenthesized_new.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(new Date).getTime()\n",
      "rendered": true,
      "contentRendered": "(new Date).getTime()\n",
      "contentRenderedWithoutLayouts": "(new Date).getTime()\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/parenthesized_new.js",
      "relativePath": "test/features/parenthesized_new.js",
      "basename": "parenthesized_new",
      "outBasename": "parenthesized_new",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "parenthesized_new.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/parenthesized_new.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "parenthesized_new.js",
      "relativeOutPath": "test/features/parenthesized_new.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/parenthesized_new",
      "relativeOutBase": "test/features/parenthesized_new",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.622Z",
      "rtime": "2014-01-20T02:05:25.057Z",
      "wtime": "2014-01-20T02:05:26.150Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(new Date).getTime()",
      "content": "(new Date).getTime()",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "parenthesized_new.js",
      "date": "2014-01-20T02:05:21.622Z",
      "slug": "test-features-parenthesized-new",
      "url": "/test/features/parenthesized_new.js",
      "urls": [
        "/test/features/parenthesized_new.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(new Date).getTime()",
      "rendered": true,
      "contentRendered": "(new Date).getTime()",
      "contentRenderedWithoutLayouts": "(new Date).getTime()",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/percent_d.coffee",
      "relativePath": "test/features/percent_d.coffee",
      "basename": "percent_d",
      "outBasename": "percent_d",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "percent_d.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/percent_d.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "percent_d.coffee",
      "relativeOutPath": "test/features/percent_d.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/percent_d",
      "relativeOutBase": "test/features/percent_d",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:21.647Z",
      "rtime": "2014-01-20T02:05:25.062Z",
      "wtime": "2014-01-20T02:05:26.154Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(->\n  console.log \"Listening to %d\", port\n  return\n)()\n",
      "content": "(->\n  console.log \"Listening to %d\", port\n  return\n)()\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "percent_d.coffee",
      "date": "2014-01-20T02:05:21.647Z",
      "slug": "test-features-percent-d",
      "url": "/test/features/percent_d.coffee",
      "urls": [
        "/test/features/percent_d.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(->\n  console.log \"Listening to %d\", port\n  return\n)()\n",
      "rendered": true,
      "contentRendered": "(->\n  console.log \"Listening to %d\", port\n  return\n)()\n",
      "contentRenderedWithoutLayouts": "(->\n  console.log \"Listening to %d\", port\n  return\n)()\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/percent_d.js",
      "relativePath": "test/features/percent_d.js",
      "basename": "percent_d",
      "outBasename": "percent_d",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "percent_d.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/percent_d.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "percent_d.js",
      "relativeOutPath": "test/features/percent_d.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/percent_d",
      "relativeOutBase": "test/features/percent_d",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.670Z",
      "rtime": "2014-01-20T02:05:25.071Z",
      "wtime": "2014-01-20T02:05:26.160Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(function() { console.log(\"Listening to %d\", port); })();\n",
      "content": "(function() { console.log(\"Listening to %d\", port); })();\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "percent_d.js",
      "date": "2014-01-20T02:05:21.670Z",
      "slug": "test-features-percent-d",
      "url": "/test/features/percent_d.js",
      "urls": [
        "/test/features/percent_d.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(function() { console.log(\"Listening to %d\", port); })();\n",
      "rendered": true,
      "contentRendered": "(function() { console.log(\"Listening to %d\", port); })();\n",
      "contentRenderedWithoutLayouts": "(function() { console.log(\"Listening to %d\", port); })();\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/pretty_arrays.coffee",
      "relativePath": "test/features/pretty_arrays.coffee",
      "basename": "pretty_arrays",
      "outBasename": "pretty_arrays",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "pretty_arrays.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/pretty_arrays.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "pretty_arrays.coffee",
      "relativeOutPath": "test/features/pretty_arrays.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/pretty_arrays",
      "relativeOutBase": "test/features/pretty_arrays",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.686Z",
      "rtime": "2014-01-20T02:05:25.077Z",
      "wtime": "2014-01-20T02:05:26.170Z",
      "exists": true,
      "encoding": "utf8",
      "source": "module.exports = foo:\n  bar:\n    empty: []\n    oneElement: [\"one\"]\n    mixed: [\n      1\n      2\n      3\n      \"four\"\n      \"five\"\n    ]\n    nestedArray: [\n      \"1\"\n      \"2\"\n      [\n        \"3.1\"\n        \"3.2\"\n        [\n          \"3.3.1\"\n          \"3.3.2\"\n        ]\n      ]\n      \"4\"\n      \"5\"\n    ]\n    nestedMix: [\n      {\n        k1: 1\n        k2: 2\n        k3:\n          k4a: true\n          k4b: [\n            \"i\"\n            \"ii\"\n          ]\n      }\n      \"k5\"\n      {\n        k6: 6\n        k7: 7\n      }\n      {\n        k8: 8\n        k9: 9\n      }\n      \"k10\"\n    ]",
      "content": "module.exports = foo:\n  bar:\n    empty: []\n    oneElement: [\"one\"]\n    mixed: [\n      1\n      2\n      3\n      \"four\"\n      \"five\"\n    ]\n    nestedArray: [\n      \"1\"\n      \"2\"\n      [\n        \"3.1\"\n        \"3.2\"\n        [\n          \"3.3.1\"\n          \"3.3.2\"\n        ]\n      ]\n      \"4\"\n      \"5\"\n    ]\n    nestedMix: [\n      {\n        k1: 1\n        k2: 2\n        k3:\n          k4a: true\n          k4b: [\n            \"i\"\n            \"ii\"\n          ]\n      }\n      \"k5\"\n      {\n        k6: 6\n        k7: 7\n      }\n      {\n        k8: 8\n        k9: 9\n      }\n      \"k10\"\n    ]",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "pretty_arrays.coffee",
      "date": "2014-01-20T02:05:21.686Z",
      "slug": "test-features-pretty-arrays",
      "url": "/test/features/pretty_arrays.coffee",
      "urls": [
        "/test/features/pretty_arrays.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "module.exports = foo:\n  bar:\n    empty: []\n    oneElement: [\"one\"]\n    mixed: [\n      1\n      2\n      3\n      \"four\"\n      \"five\"\n    ]\n    nestedArray: [\n      \"1\"\n      \"2\"\n      [\n        \"3.1\"\n        \"3.2\"\n        [\n          \"3.3.1\"\n          \"3.3.2\"\n        ]\n      ]\n      \"4\"\n      \"5\"\n    ]\n    nestedMix: [\n      {\n        k1: 1\n        k2: 2\n        k3:\n          k4a: true\n          k4b: [\n            \"i\"\n            \"ii\"\n          ]\n      }\n      \"k5\"\n      {\n        k6: 6\n        k7: 7\n      }\n      {\n        k8: 8\n        k9: 9\n      }\n      \"k10\"\n    ]",
      "rendered": true,
      "contentRendered": "module.exports = foo:\n  bar:\n    empty: []\n    oneElement: [\"one\"]\n    mixed: [\n      1\n      2\n      3\n      \"four\"\n      \"five\"\n    ]\n    nestedArray: [\n      \"1\"\n      \"2\"\n      [\n        \"3.1\"\n        \"3.2\"\n        [\n          \"3.3.1\"\n          \"3.3.2\"\n        ]\n      ]\n      \"4\"\n      \"5\"\n    ]\n    nestedMix: [\n      {\n        k1: 1\n        k2: 2\n        k3:\n          k4a: true\n          k4b: [\n            \"i\"\n            \"ii\"\n          ]\n      }\n      \"k5\"\n      {\n        k6: 6\n        k7: 7\n      }\n      {\n        k8: 8\n        k9: 9\n      }\n      \"k10\"\n    ]",
      "contentRenderedWithoutLayouts": "module.exports = foo:\n  bar:\n    empty: []\n    oneElement: [\"one\"]\n    mixed: [\n      1\n      2\n      3\n      \"four\"\n      \"five\"\n    ]\n    nestedArray: [\n      \"1\"\n      \"2\"\n      [\n        \"3.1\"\n        \"3.2\"\n        [\n          \"3.3.1\"\n          \"3.3.2\"\n        ]\n      ]\n      \"4\"\n      \"5\"\n    ]\n    nestedMix: [\n      {\n        k1: 1\n        k2: 2\n        k3:\n          k4a: true\n          k4b: [\n            \"i\"\n            \"ii\"\n          ]\n      }\n      \"k5\"\n      {\n        k6: 6\n        k7: 7\n      }\n      {\n        k8: 8\n        k9: 9\n      }\n      \"k10\"\n    ]",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/pretty_arrays.js",
      "relativePath": "test/features/pretty_arrays.js",
      "basename": "pretty_arrays",
      "outBasename": "pretty_arrays",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "pretty_arrays.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/pretty_arrays.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "pretty_arrays.js",
      "relativeOutPath": "test/features/pretty_arrays.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/pretty_arrays",
      "relativeOutBase": "test/features/pretty_arrays",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.706Z",
      "rtime": "2014-01-20T02:05:25.082Z",
      "wtime": "2014-01-20T02:05:26.172Z",
      "exists": true,
      "encoding": "utf8",
      "source": "module.exports = {\n    foo: {\n        bar: {\n            empty: [],\n            oneElement: [\"one\"],\n            mixed: [1,2,3,\"four\",\"five\"],\n            nestedArray: [\n                \"1\",\n                \"2\",\n                [\"3.1\", \"3.2\",[\"3.3.1\", \"3.3.2\"]],\n                \"4\",\n                \"5\"\n            ],\n            nestedMix: [\n                {\n                    k1: 1,\n                    k2: 2,\n                    k3: {\n                        'k4a':true,\n                        'k4b':['i', 'ii']\n                    }\n                },\n                \"k5\",\n                {\n                    k6: 6,\n                    k7: 7\n\n                },\n                {\n                    k8: 8,\n                    k9: 9\n\n                },\n                \"k10\"\n            ]\n        }\n    }\n};",
      "content": "module.exports = {\n    foo: {\n        bar: {\n            empty: [],\n            oneElement: [\"one\"],\n            mixed: [1,2,3,\"four\",\"five\"],\n            nestedArray: [\n                \"1\",\n                \"2\",\n                [\"3.1\", \"3.2\",[\"3.3.1\", \"3.3.2\"]],\n                \"4\",\n                \"5\"\n            ],\n            nestedMix: [\n                {\n                    k1: 1,\n                    k2: 2,\n                    k3: {\n                        'k4a':true,\n                        'k4b':['i', 'ii']\n                    }\n                },\n                \"k5\",\n                {\n                    k6: 6,\n                    k7: 7\n\n                },\n                {\n                    k8: 8,\n                    k9: 9\n\n                },\n                \"k10\"\n            ]\n        }\n    }\n};",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "pretty_arrays.js",
      "date": "2014-01-20T02:05:21.706Z",
      "slug": "test-features-pretty-arrays",
      "url": "/test/features/pretty_arrays.js",
      "urls": [
        "/test/features/pretty_arrays.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "module.exports = {\n    foo: {\n        bar: {\n            empty: [],\n            oneElement: [\"one\"],\n            mixed: [1,2,3,\"four\",\"five\"],\n            nestedArray: [\n                \"1\",\n                \"2\",\n                [\"3.1\", \"3.2\",[\"3.3.1\", \"3.3.2\"]],\n                \"4\",\n                \"5\"\n            ],\n            nestedMix: [\n                {\n                    k1: 1,\n                    k2: 2,\n                    k3: {\n                        'k4a':true,\n                        'k4b':['i', 'ii']\n                    }\n                },\n                \"k5\",\n                {\n                    k6: 6,\n                    k7: 7\n\n                },\n                {\n                    k8: 8,\n                    k9: 9\n\n                },\n                \"k10\"\n            ]\n        }\n    }\n};",
      "rendered": true,
      "contentRendered": "module.exports = {\n    foo: {\n        bar: {\n            empty: [],\n            oneElement: [\"one\"],\n            mixed: [1,2,3,\"four\",\"five\"],\n            nestedArray: [\n                \"1\",\n                \"2\",\n                [\"3.1\", \"3.2\",[\"3.3.1\", \"3.3.2\"]],\n                \"4\",\n                \"5\"\n            ],\n            nestedMix: [\n                {\n                    k1: 1,\n                    k2: 2,\n                    k3: {\n                        'k4a':true,\n                        'k4b':['i', 'ii']\n                    }\n                },\n                \"k5\",\n                {\n                    k6: 6,\n                    k7: 7\n\n                },\n                {\n                    k8: 8,\n                    k9: 9\n\n                },\n                \"k10\"\n            ]\n        }\n    }\n};",
      "contentRenderedWithoutLayouts": "module.exports = {\n    foo: {\n        bar: {\n            empty: [],\n            oneElement: [\"one\"],\n            mixed: [1,2,3,\"four\",\"five\"],\n            nestedArray: [\n                \"1\",\n                \"2\",\n                [\"3.1\", \"3.2\",[\"3.3.1\", \"3.3.2\"]],\n                \"4\",\n                \"5\"\n            ],\n            nestedMix: [\n                {\n                    k1: 1,\n                    k2: 2,\n                    k3: {\n                        'k4a':true,\n                        'k4b':['i', 'ii']\n                    }\n                },\n                \"k5\",\n                {\n                    k6: 6,\n                    k7: 7\n\n                },\n                {\n                    k8: 8,\n                    k9: 9\n\n                },\n                \"k10\"\n            ]\n        }\n    }\n};",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/prototype.coffee",
      "relativePath": "test/features/prototype.coffee",
      "basename": "prototype",
      "outBasename": "prototype",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "prototype.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/prototype.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "prototype.coffee",
      "relativeOutPath": "test/features/prototype.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/prototype",
      "relativeOutBase": "test/features/prototype",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.724Z",
      "rtime": "2014-01-20T02:05:25.088Z",
      "wtime": "2014-01-20T02:05:26.176Z",
      "exists": true,
      "encoding": "utf8",
      "source": "X:: = a: b\n@:: = a: b\nX::a = a: b\n@::b = a: b\n",
      "content": "X:: = a: b\n@:: = a: b\nX::a = a: b\n@::b = a: b\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "prototype.coffee",
      "date": "2014-01-20T02:05:21.724Z",
      "slug": "test-features-prototype",
      "url": "/test/features/prototype.coffee",
      "urls": [
        "/test/features/prototype.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "X:: = a: b\n@:: = a: b\nX::a = a: b\n@::b = a: b\n",
      "rendered": true,
      "contentRendered": "X:: = a: b\n@:: = a: b\nX::a = a: b\n@::b = a: b\n",
      "contentRenderedWithoutLayouts": "X:: = a: b\n@:: = a: b\nX::a = a: b\n@::b = a: b\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/prototype.js",
      "relativePath": "test/features/prototype.js",
      "basename": "prototype",
      "outBasename": "prototype",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "prototype.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/prototype.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "prototype.js",
      "relativeOutPath": "test/features/prototype.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/prototype",
      "relativeOutBase": "test/features/prototype",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.741Z",
      "rtime": "2014-01-20T02:05:25.093Z",
      "wtime": "2014-01-20T02:05:26.182Z",
      "exists": true,
      "encoding": "utf8",
      "source": "X.prototype = { a: b };\nthis.prototype = { a: b };\nX.prototype.a = { a: b };\nthis.prototype.b = { a: b };\n",
      "content": "X.prototype = { a: b };\nthis.prototype = { a: b };\nX.prototype.a = { a: b };\nthis.prototype.b = { a: b };\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "prototype.js",
      "date": "2014-01-20T02:05:21.741Z",
      "slug": "test-features-prototype",
      "url": "/test/features/prototype.js",
      "urls": [
        "/test/features/prototype.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "X.prototype = { a: b };\nthis.prototype = { a: b };\nX.prototype.a = { a: b };\nthis.prototype.b = { a: b };\n",
      "rendered": true,
      "contentRendered": "X.prototype = { a: b };\nthis.prototype = { a: b };\nX.prototype.a = { a: b };\nthis.prototype.b = { a: b };\n",
      "contentRenderedWithoutLayouts": "X.prototype = { a: b };\nthis.prototype = { a: b };\nX.prototype.a = { a: b };\nthis.prototype.b = { a: b };\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/reserve.coffee",
      "relativePath": "test/features/reserve.coffee",
      "basename": "reserve",
      "outBasename": "reserve",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "reserve.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/reserve.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "reserve.coffee",
      "relativeOutPath": "test/features/reserve.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/reserve",
      "relativeOutBase": "test/features/reserve",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.758Z",
      "rtime": "2014-01-20T02:05:25.098Z",
      "wtime": "2014-01-20T02:05:26.184Z",
      "exists": true,
      "encoding": "utf8",
      "source": "off_ = false\nfoo off_\n",
      "content": "off_ = false\nfoo off_\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "reserve.coffee",
      "date": "2014-01-20T02:05:21.758Z",
      "slug": "test-features-reserve",
      "url": "/test/features/reserve.coffee",
      "urls": [
        "/test/features/reserve.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "off_ = false\nfoo off_\n",
      "rendered": true,
      "contentRendered": "off_ = false\nfoo off_\n",
      "contentRenderedWithoutLayouts": "off_ = false\nfoo off_\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/reserve.js",
      "relativePath": "test/features/reserve.js",
      "basename": "reserve",
      "outBasename": "reserve",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "reserve.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/reserve.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "reserve.js",
      "relativeOutPath": "test/features/reserve.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/reserve",
      "relativeOutBase": "test/features/reserve",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.781Z",
      "rtime": "2014-01-20T02:05:25.104Z",
      "wtime": "2014-01-20T02:05:26.190Z",
      "exists": true,
      "encoding": "utf8",
      "source": "var off = false\nfoo(off)",
      "content": "var off = false\nfoo(off)",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "reserve.js",
      "date": "2014-01-20T02:05:21.781Z",
      "slug": "test-features-reserve",
      "url": "/test/features/reserve.js",
      "urls": [
        "/test/features/reserve.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "var off = false\nfoo(off)",
      "rendered": true,
      "contentRendered": "var off = false\nfoo(off)",
      "contentRenderedWithoutLayouts": "var off = false\nfoo(off)",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/return_function.coffee",
      "relativePath": "test/features/return_function.coffee",
      "basename": "return_function",
      "outBasename": "return_function",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "return_function.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/return_function.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "return_function.coffee",
      "relativeOutPath": "test/features/return_function.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/return_function",
      "relativeOutBase": "test/features/return_function",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.798Z",
      "rtime": "2014-01-20T02:05:25.109Z",
      "wtime": "2014-01-20T02:05:26.194Z",
      "exists": true,
      "encoding": "utf8",
      "source": "->\n  ->\n    2\n",
      "content": "->\n  ->\n    2\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "return_function.coffee",
      "date": "2014-01-20T02:05:21.798Z",
      "slug": "test-features-return-function",
      "url": "/test/features/return_function.coffee",
      "urls": [
        "/test/features/return_function.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "->\n  ->\n    2\n",
      "rendered": true,
      "contentRendered": "->\n  ->\n    2\n",
      "contentRenderedWithoutLayouts": "->\n  ->\n    2\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/return_function.js",
      "relativePath": "test/features/return_function.js",
      "basename": "return_function",
      "outBasename": "return_function",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "return_function.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/return_function.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "return_function.js",
      "relativeOutPath": "test/features/return_function.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/return_function",
      "relativeOutBase": "test/features/return_function",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:21.815Z",
      "rtime": "2014-01-20T02:05:25.115Z",
      "wtime": "2014-01-20T02:05:26.196Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(function() { return function() { return 2 }; })\n",
      "content": "(function() { return function() { return 2 }; })\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "return_function.js",
      "date": "2014-01-20T02:05:21.815Z",
      "slug": "test-features-return-function",
      "url": "/test/features/return_function.js",
      "urls": [
        "/test/features/return_function.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(function() { return function() { return 2 }; })\n",
      "rendered": true,
      "contentRendered": "(function() { return function() { return 2 }; })\n",
      "contentRenderedWithoutLayouts": "(function() { return function() { return 2 }; })\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/return_in_if.coffee",
      "relativePath": "test/features/return_in_if.coffee",
      "basename": "return_in_if",
      "outBasename": "return_in_if",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "return_in_if.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/return_in_if.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "return_in_if.coffee",
      "relativeOutPath": "test/features/return_in_if.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/return_in_if",
      "relativeOutBase": "test/features/return_in_if",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.832Z",
      "rtime": "2014-01-20T02:05:25.120Z",
      "wtime": "2014-01-20T02:05:26.199Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = ->\n  return 2  if true\n  b = 3\n  b\n\n",
      "content": "x = ->\n  return 2  if true\n  b = 3\n  b\n\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "return_in_if.coffee",
      "date": "2014-01-20T02:05:21.832Z",
      "slug": "test-features-return-in-if",
      "url": "/test/features/return_in_if.coffee",
      "urls": [
        "/test/features/return_in_if.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = ->\n  return 2  if true\n  b = 3\n  b\n\n",
      "rendered": true,
      "contentRendered": "x = ->\n  return 2  if true\n  b = 3\n  b\n\n",
      "contentRenderedWithoutLayouts": "x = ->\n  return 2  if true\n  b = 3\n  b\n\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/return_in_if.js",
      "relativePath": "test/features/return_in_if.js",
      "basename": "return_in_if",
      "outBasename": "return_in_if",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "return_in_if.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/return_in_if.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "return_in_if.js",
      "relativeOutPath": "test/features/return_in_if.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/return_in_if",
      "relativeOutBase": "test/features/return_in_if",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.860Z",
      "rtime": "2014-01-20T02:05:25.126Z",
      "wtime": "2014-01-20T02:05:26.208Z",
      "exists": true,
      "encoding": "utf8",
      "source": "function x() {\n  if (true) {\n    return 2;\n  }\n\n  var b = 3;\n  return b;\n}\n",
      "content": "function x() {\n  if (true) {\n    return 2;\n  }\n\n  var b = 3;\n  return b;\n}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "return_in_if.js",
      "date": "2014-01-20T02:05:21.860Z",
      "slug": "test-features-return-in-if",
      "url": "/test/features/return_in_if.js",
      "urls": [
        "/test/features/return_in_if.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "function x() {\n  if (true) {\n    return 2;\n  }\n\n  var b = 3;\n  return b;\n}\n",
      "rendered": true,
      "contentRendered": "function x() {\n  if (true) {\n    return 2;\n  }\n\n  var b = 3;\n  return b;\n}\n",
      "contentRenderedWithoutLayouts": "function x() {\n  if (true) {\n    return 2;\n  }\n\n  var b = 3;\n  return b;\n}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/return_object.coffee",
      "relativePath": "test/features/return_object.coffee",
      "basename": "return_object",
      "outBasename": "return_object",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "return_object.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/return_object.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "return_object.coffee",
      "relativeOutPath": "test/features/return_object.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/return_object",
      "relativeOutBase": "test/features/return_object",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.876Z",
      "rtime": "2014-01-20T02:05:25.131Z",
      "wtime": "2014-01-20T02:05:26.206Z",
      "exists": true,
      "encoding": "utf8",
      "source": "a = ->\n  console.log \"Hello\"\n  a: 1\n  b: 2\nb = ->\n  console.log \"Hello\"\n  a: 1\nc = ->\n  a: 1\n  b: 2\nd = ->\n  c: 3\n  (\n    a: 1\n    b: 2\n  )\n",
      "content": "a = ->\n  console.log \"Hello\"\n  a: 1\n  b: 2\nb = ->\n  console.log \"Hello\"\n  a: 1\nc = ->\n  a: 1\n  b: 2\nd = ->\n  c: 3\n  (\n    a: 1\n    b: 2\n  )\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "return_object.coffee",
      "date": "2014-01-20T02:05:21.876Z",
      "slug": "test-features-return-object",
      "url": "/test/features/return_object.coffee",
      "urls": [
        "/test/features/return_object.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "a = ->\n  console.log \"Hello\"\n  a: 1\n  b: 2\nb = ->\n  console.log \"Hello\"\n  a: 1\nc = ->\n  a: 1\n  b: 2\nd = ->\n  c: 3\n  (\n    a: 1\n    b: 2\n  )\n",
      "rendered": true,
      "contentRendered": "a = ->\n  console.log \"Hello\"\n  a: 1\n  b: 2\nb = ->\n  console.log \"Hello\"\n  a: 1\nc = ->\n  a: 1\n  b: 2\nd = ->\n  c: 3\n  (\n    a: 1\n    b: 2\n  )\n",
      "contentRenderedWithoutLayouts": "a = ->\n  console.log \"Hello\"\n  a: 1\n  b: 2\nb = ->\n  console.log \"Hello\"\n  a: 1\nc = ->\n  a: 1\n  b: 2\nd = ->\n  c: 3\n  (\n    a: 1\n    b: 2\n  )\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/return_object.js",
      "relativePath": "test/features/return_object.js",
      "basename": "return_object",
      "outBasename": "return_object",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "return_object.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/return_object.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "return_object.js",
      "relativeOutPath": "test/features/return_object.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/return_object",
      "relativeOutBase": "test/features/return_object",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.891Z",
      "rtime": "2014-01-20T02:05:25.136Z",
      "wtime": "2014-01-20T02:05:26.218Z",
      "exists": true,
      "encoding": "utf8",
      "source": "function a() {\n  console.log(\"Hello\");\n  return { a: 1, b: 2 };\n}\nfunction b() {\n  console.log(\"Hello\");\n  return { a: 1 };\n}\nfunction c() {\n  return { a: 1, b: 2 };\n}\nfunction d() {\n  ({ c: 3 });\n  return { a: 1, b: 2 };\n}\n",
      "content": "function a() {\n  console.log(\"Hello\");\n  return { a: 1, b: 2 };\n}\nfunction b() {\n  console.log(\"Hello\");\n  return { a: 1 };\n}\nfunction c() {\n  return { a: 1, b: 2 };\n}\nfunction d() {\n  ({ c: 3 });\n  return { a: 1, b: 2 };\n}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "return_object.js",
      "date": "2014-01-20T02:05:21.891Z",
      "slug": "test-features-return-object",
      "url": "/test/features/return_object.js",
      "urls": [
        "/test/features/return_object.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "function a() {\n  console.log(\"Hello\");\n  return { a: 1, b: 2 };\n}\nfunction b() {\n  console.log(\"Hello\");\n  return { a: 1 };\n}\nfunction c() {\n  return { a: 1, b: 2 };\n}\nfunction d() {\n  ({ c: 3 });\n  return { a: 1, b: 2 };\n}\n",
      "rendered": true,
      "contentRendered": "function a() {\n  console.log(\"Hello\");\n  return { a: 1, b: 2 };\n}\nfunction b() {\n  console.log(\"Hello\");\n  return { a: 1 };\n}\nfunction c() {\n  return { a: 1, b: 2 };\n}\nfunction d() {\n  ({ c: 3 });\n  return { a: 1, b: 2 };\n}\n",
      "contentRenderedWithoutLayouts": "function a() {\n  console.log(\"Hello\");\n  return { a: 1, b: 2 };\n}\nfunction b() {\n  console.log(\"Hello\");\n  return { a: 1 };\n}\nfunction c() {\n  return { a: 1, b: 2 };\n}\nfunction d() {\n  ({ c: 3 });\n  return { a: 1, b: 2 };\n}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/return_object_parenthesize.coffee",
      "relativePath": "test/features/return_object_parenthesize.coffee",
      "basename": "return_object_parenthesize",
      "outBasename": "return_object_parenthesize",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "return_object_parenthesize.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/return_object_parenthesize.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "return_object_parenthesize.coffee",
      "relativeOutPath": "test/features/return_object_parenthesize.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/return_object_parenthesize",
      "relativeOutBase": "test/features/return_object_parenthesize",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:21.907Z",
      "rtime": "2014-01-20T02:05:25.142Z",
      "wtime": "2014-01-20T02:05:26.223Z",
      "exists": true,
      "encoding": "utf8",
      "source": "parenthesized = ->\n  return (\n    a: 1\n    b: 2\n  )\n  a()\n  return\nnot_parenthesized = ->\n  return a: 1\n  a()\n  return\nparenthesized_b = ->\n  if something()\n    a: 1\n    b: 2\nparenthesized_c = ->\n  if something()\n    return (\n      a: 1\n      b: 2\n    )\n  a()\n  return\n",
      "content": "parenthesized = ->\n  return (\n    a: 1\n    b: 2\n  )\n  a()\n  return\nnot_parenthesized = ->\n  return a: 1\n  a()\n  return\nparenthesized_b = ->\n  if something()\n    a: 1\n    b: 2\nparenthesized_c = ->\n  if something()\n    return (\n      a: 1\n      b: 2\n    )\n  a()\n  return\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "return_object_parenthesize.coffee",
      "date": "2014-01-20T02:05:21.907Z",
      "slug": "test-features-return-object-parenthesize",
      "url": "/test/features/return_object_parenthesize.coffee",
      "urls": [
        "/test/features/return_object_parenthesize.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "parenthesized = ->\n  return (\n    a: 1\n    b: 2\n  )\n  a()\n  return\nnot_parenthesized = ->\n  return a: 1\n  a()\n  return\nparenthesized_b = ->\n  if something()\n    a: 1\n    b: 2\nparenthesized_c = ->\n  if something()\n    return (\n      a: 1\n      b: 2\n    )\n  a()\n  return\n",
      "rendered": true,
      "contentRendered": "parenthesized = ->\n  return (\n    a: 1\n    b: 2\n  )\n  a()\n  return\nnot_parenthesized = ->\n  return a: 1\n  a()\n  return\nparenthesized_b = ->\n  if something()\n    a: 1\n    b: 2\nparenthesized_c = ->\n  if something()\n    return (\n      a: 1\n      b: 2\n    )\n  a()\n  return\n",
      "contentRenderedWithoutLayouts": "parenthesized = ->\n  return (\n    a: 1\n    b: 2\n  )\n  a()\n  return\nnot_parenthesized = ->\n  return a: 1\n  a()\n  return\nparenthesized_b = ->\n  if something()\n    a: 1\n    b: 2\nparenthesized_c = ->\n  if something()\n    return (\n      a: 1\n      b: 2\n    )\n  a()\n  return\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/return_object_parenthesize.js",
      "relativePath": "test/features/return_object_parenthesize.js",
      "basename": "return_object_parenthesize",
      "outBasename": "return_object_parenthesize",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "return_object_parenthesize.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/return_object_parenthesize.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "return_object_parenthesize.js",
      "relativeOutPath": "test/features/return_object_parenthesize.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/return_object_parenthesize",
      "relativeOutBase": "test/features/return_object_parenthesize",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.923Z",
      "rtime": "2014-01-20T02:05:25.147Z",
      "wtime": "2014-01-20T02:05:26.227Z",
      "exists": true,
      "encoding": "utf8",
      "source": "function parenthesized() {\n  return { a: 1, b: 2 };\n  a();\n}\nfunction not_parenthesized() {\n  return { a: 1 };\n  a();\n}\nfunction parenthesized_b() {\n  if (something()) {\n    return { a: 1, b: 2 };\n  }\n}\nfunction parenthesized_c() {\n  if (something()) {\n    return { a: 1, b: 2 };\n  }\n  a();\n}\n",
      "content": "function parenthesized() {\n  return { a: 1, b: 2 };\n  a();\n}\nfunction not_parenthesized() {\n  return { a: 1 };\n  a();\n}\nfunction parenthesized_b() {\n  if (something()) {\n    return { a: 1, b: 2 };\n  }\n}\nfunction parenthesized_c() {\n  if (something()) {\n    return { a: 1, b: 2 };\n  }\n  a();\n}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "return_object_parenthesize.js",
      "date": "2014-01-20T02:05:21.923Z",
      "slug": "test-features-return-object-parenthesize",
      "url": "/test/features/return_object_parenthesize.js",
      "urls": [
        "/test/features/return_object_parenthesize.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "function parenthesized() {\n  return { a: 1, b: 2 };\n  a();\n}\nfunction not_parenthesized() {\n  return { a: 1 };\n  a();\n}\nfunction parenthesized_b() {\n  if (something()) {\n    return { a: 1, b: 2 };\n  }\n}\nfunction parenthesized_c() {\n  if (something()) {\n    return { a: 1, b: 2 };\n  }\n  a();\n}\n",
      "rendered": true,
      "contentRendered": "function parenthesized() {\n  return { a: 1, b: 2 };\n  a();\n}\nfunction not_parenthesized() {\n  return { a: 1 };\n  a();\n}\nfunction parenthesized_b() {\n  if (something()) {\n    return { a: 1, b: 2 };\n  }\n}\nfunction parenthesized_c() {\n  if (something()) {\n    return { a: 1, b: 2 };\n  }\n  a();\n}\n",
      "contentRenderedWithoutLayouts": "function parenthesized() {\n  return { a: 1, b: 2 };\n  a();\n}\nfunction not_parenthesized() {\n  return { a: 1 };\n  a();\n}\nfunction parenthesized_b() {\n  if (something()) {\n    return { a: 1, b: 2 };\n  }\n}\nfunction parenthesized_c() {\n  if (something()) {\n    return { a: 1, b: 2 };\n  }\n  a();\n}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/returns.coffee",
      "relativePath": "test/features/returns.coffee",
      "basename": "returns",
      "outBasename": "returns",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "returns.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/returns.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "returns.coffee",
      "relativeOutPath": "test/features/returns.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/returns",
      "relativeOutBase": "test/features/returns",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:21.939Z",
      "rtime": "2014-01-20T02:05:25.152Z",
      "wtime": "2014-01-20T02:05:26.232Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = ->\n  if foo\n    return 1\n    true\n  else\n    return 2\n    false\ny = ->\n  return 100\n  200\nz = ->\n  switch foo\n    when X\n      return 1\n      2\n    when Y\n      return 3\n      4\n    else\n      return 5\n      6\n",
      "content": "x = ->\n  if foo\n    return 1\n    true\n  else\n    return 2\n    false\ny = ->\n  return 100\n  200\nz = ->\n  switch foo\n    when X\n      return 1\n      2\n    when Y\n      return 3\n      4\n    else\n      return 5\n      6\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "returns.coffee",
      "date": "2014-01-20T02:05:21.939Z",
      "slug": "test-features-returns",
      "url": "/test/features/returns.coffee",
      "urls": [
        "/test/features/returns.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = ->\n  if foo\n    return 1\n    true\n  else\n    return 2\n    false\ny = ->\n  return 100\n  200\nz = ->\n  switch foo\n    when X\n      return 1\n      2\n    when Y\n      return 3\n      4\n    else\n      return 5\n      6\n",
      "rendered": true,
      "contentRendered": "x = ->\n  if foo\n    return 1\n    true\n  else\n    return 2\n    false\ny = ->\n  return 100\n  200\nz = ->\n  switch foo\n    when X\n      return 1\n      2\n    when Y\n      return 3\n      4\n    else\n      return 5\n      6\n",
      "contentRenderedWithoutLayouts": "x = ->\n  if foo\n    return 1\n    true\n  else\n    return 2\n    false\ny = ->\n  return 100\n  200\nz = ->\n  switch foo\n    when X\n      return 1\n      2\n    when Y\n      return 3\n      4\n    else\n      return 5\n      6\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/returns.js",
      "relativePath": "test/features/returns.js",
      "basename": "returns",
      "outBasename": "returns",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "returns.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/returns.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "returns.js",
      "relativeOutPath": "test/features/returns.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/returns",
      "relativeOutBase": "test/features/returns",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.955Z",
      "rtime": "2014-01-20T02:05:25.158Z",
      "wtime": "2014-01-20T02:05:26.236Z",
      "exists": true,
      "encoding": "utf8",
      "source": "function x() {\n    if (foo) {\n        return 1;\n        return true;\n    } else {\n        return 2;\n        return false;\n    }\n}\n\nfunction y() {\n  return 100;\n  return 200;\n}\n\nfunction z() {\n  switch (foo) {\n    case X:\n      return 1;\n      return 2;\n    case Y:\n      return 3;\n      return 4;\n    default:\n      return 5;\n      return 6;\n  }\n}\n",
      "content": "function x() {\n    if (foo) {\n        return 1;\n        return true;\n    } else {\n        return 2;\n        return false;\n    }\n}\n\nfunction y() {\n  return 100;\n  return 200;\n}\n\nfunction z() {\n  switch (foo) {\n    case X:\n      return 1;\n      return 2;\n    case Y:\n      return 3;\n      return 4;\n    default:\n      return 5;\n      return 6;\n  }\n}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "returns.js",
      "date": "2014-01-20T02:05:21.955Z",
      "slug": "test-features-returns",
      "url": "/test/features/returns.js",
      "urls": [
        "/test/features/returns.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "function x() {\n    if (foo) {\n        return 1;\n        return true;\n    } else {\n        return 2;\n        return false;\n    }\n}\n\nfunction y() {\n  return 100;\n  return 200;\n}\n\nfunction z() {\n  switch (foo) {\n    case X:\n      return 1;\n      return 2;\n    case Y:\n      return 3;\n      return 4;\n    default:\n      return 5;\n      return 6;\n  }\n}\n",
      "rendered": true,
      "contentRendered": "function x() {\n    if (foo) {\n        return 1;\n        return true;\n    } else {\n        return 2;\n        return false;\n    }\n}\n\nfunction y() {\n  return 100;\n  return 200;\n}\n\nfunction z() {\n  switch (foo) {\n    case X:\n      return 1;\n      return 2;\n    case Y:\n      return 3;\n      return 4;\n    default:\n      return 5;\n      return 6;\n  }\n}\n",
      "contentRenderedWithoutLayouts": "function x() {\n    if (foo) {\n        return 1;\n        return true;\n    } else {\n        return 2;\n        return false;\n    }\n}\n\nfunction y() {\n  return 100;\n  return 200;\n}\n\nfunction z() {\n  switch (foo) {\n    case X:\n      return 1;\n      return 2;\n    case Y:\n      return 3;\n      return 4;\n    default:\n      return 5;\n      return 6;\n  }\n}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/settimeout.coffee",
      "relativePath": "test/features/settimeout.coffee",
      "basename": "settimeout",
      "outBasename": "settimeout",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "settimeout.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/settimeout.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "settimeout.coffee",
      "relativeOutPath": "test/features/settimeout.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/settimeout",
      "relativeOutBase": "test/features/settimeout",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:21.971Z",
      "rtime": "2014-01-20T02:05:25.163Z",
      "wtime": "2014-01-20T02:05:26.240Z",
      "exists": true,
      "encoding": "utf8",
      "source": "setTimeout (->\n  foo()\n), 500\nalert setTimeout(->\n  foo()\n, 500)\ncall ->\n  foo()\n",
      "content": "setTimeout (->\n  foo()\n), 500\nalert setTimeout(->\n  foo()\n, 500)\ncall ->\n  foo()\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "settimeout.coffee",
      "date": "2014-01-20T02:05:21.971Z",
      "slug": "test-features-settimeout",
      "url": "/test/features/settimeout.coffee",
      "urls": [
        "/test/features/settimeout.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "setTimeout (->\n  foo()\n), 500\nalert setTimeout(->\n  foo()\n, 500)\ncall ->\n  foo()\n",
      "rendered": true,
      "contentRendered": "setTimeout (->\n  foo()\n), 500\nalert setTimeout(->\n  foo()\n, 500)\ncall ->\n  foo()\n",
      "contentRenderedWithoutLayouts": "setTimeout (->\n  foo()\n), 500\nalert setTimeout(->\n  foo()\n, 500)\ncall ->\n  foo()\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/settimeout.js",
      "relativePath": "test/features/settimeout.js",
      "basename": "settimeout",
      "outBasename": "settimeout",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "settimeout.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/settimeout.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "settimeout.js",
      "relativeOutPath": "test/features/settimeout.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/settimeout",
      "relativeOutBase": "test/features/settimeout",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:21.987Z",
      "rtime": "2014-01-20T02:05:25.169Z",
      "wtime": "2014-01-20T02:05:26.244Z",
      "exists": true,
      "encoding": "utf8",
      "source": "setTimeout(function() { return foo() }, 500);\nalert(setTimeout(function() { return foo() }, 500));\ncall(function() { return foo() });\n",
      "content": "setTimeout(function() { return foo() }, 500);\nalert(setTimeout(function() { return foo() }, 500));\ncall(function() { return foo() });\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "settimeout.js",
      "date": "2014-01-20T02:05:21.987Z",
      "slug": "test-features-settimeout",
      "url": "/test/features/settimeout.js",
      "urls": [
        "/test/features/settimeout.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "setTimeout(function() { return foo() }, 500);\nalert(setTimeout(function() { return foo() }, 500));\ncall(function() { return foo() });\n",
      "rendered": true,
      "contentRendered": "setTimeout(function() { return foo() }, 500);\nalert(setTimeout(function() { return foo() }, 500));\ncall(function() { return foo() });\n",
      "contentRenderedWithoutLayouts": "setTimeout(function() { return foo() }, 500);\nalert(setTimeout(function() { return foo() }, 500));\ncall(function() { return foo() });\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/simple_addition.coffee",
      "relativePath": "test/features/simple_addition.coffee",
      "basename": "simple_addition",
      "outBasename": "simple_addition",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "simple_addition.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/simple_addition.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "simple_addition.coffee",
      "relativeOutPath": "test/features/simple_addition.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/simple_addition",
      "relativeOutBase": "test/features/simple_addition",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.003Z",
      "rtime": "2014-01-20T02:05:25.174Z",
      "wtime": "2014-01-20T02:05:26.246Z",
      "exists": true,
      "encoding": "utf8",
      "source": "a = (8 + 2 + 2)\n2\n",
      "content": "a = (8 + 2 + 2)\n2\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "simple_addition.coffee",
      "date": "2014-01-20T02:05:22.003Z",
      "slug": "test-features-simple-addition",
      "url": "/test/features/simple_addition.coffee",
      "urls": [
        "/test/features/simple_addition.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "a = (8 + 2 + 2)\n2\n",
      "rendered": true,
      "contentRendered": "a = (8 + 2 + 2)\n2\n",
      "contentRenderedWithoutLayouts": "a = (8 + 2 + 2)\n2\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/simple_addition.js",
      "relativePath": "test/features/simple_addition.js",
      "basename": "simple_addition",
      "outBasename": "simple_addition",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "simple_addition.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/simple_addition.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "simple_addition.js",
      "relativeOutPath": "test/features/simple_addition.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/simple_addition",
      "relativeOutBase": "test/features/simple_addition",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.019Z",
      "rtime": "2014-01-20T02:05:25.180Z",
      "wtime": "2014-01-20T02:05:26.253Z",
      "exists": true,
      "encoding": "utf8",
      "source": "var a = (8+2+2);2",
      "content": "var a = (8+2+2);2",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "simple_addition.js",
      "date": "2014-01-20T02:05:22.019Z",
      "slug": "test-features-simple-addition",
      "url": "/test/features/simple_addition.js",
      "urls": [
        "/test/features/simple_addition.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "var a = (8+2+2);2",
      "rendered": true,
      "contentRendered": "var a = (8+2+2);2",
      "contentRenderedWithoutLayouts": "var a = (8+2+2);2",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/single_line_else.coffee",
      "relativePath": "test/features/single_line_else.coffee",
      "basename": "single_line_else",
      "outBasename": "single_line_else",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "single_line_else.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/single_line_else.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "single_line_else.coffee",
      "relativeOutPath": "test/features/single_line_else.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/single_line_else",
      "relativeOutBase": "test/features/single_line_else",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.035Z",
      "rtime": "2014-01-20T02:05:25.185Z",
      "wtime": "2014-01-20T02:05:26.257Z",
      "exists": true,
      "encoding": "utf8",
      "source": "if (x isnt 2) and (2)\n  2\n  2\nelse\n  true\n",
      "content": "if (x isnt 2) and (2)\n  2\n  2\nelse\n  true\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "single_line_else.coffee",
      "date": "2014-01-20T02:05:22.035Z",
      "slug": "test-features-single-line-else",
      "url": "/test/features/single_line_else.coffee",
      "urls": [
        "/test/features/single_line_else.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "if (x isnt 2) and (2)\n  2\n  2\nelse\n  true\n",
      "rendered": true,
      "contentRendered": "if (x isnt 2) and (2)\n  2\n  2\nelse\n  true\n",
      "contentRenderedWithoutLayouts": "if (x isnt 2) and (2)\n  2\n  2\nelse\n  true\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/single_line_else.js",
      "relativePath": "test/features/single_line_else.js",
      "basename": "single_line_else",
      "outBasename": "single_line_else",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "single_line_else.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/single_line_else.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "single_line_else.js",
      "relativeOutPath": "test/features/single_line_else.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/single_line_else",
      "relativeOutBase": "test/features/single_line_else",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.051Z",
      "rtime": "2014-01-20T02:05:25.191Z",
      "wtime": "2014-01-20T02:05:26.261Z",
      "exists": true,
      "encoding": "utf8",
      "source": "if ((x != 2) && (2)) { 2;2 } else true\n",
      "content": "if ((x != 2) && (2)) { 2;2 } else true\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "single_line_else.js",
      "date": "2014-01-20T02:05:22.051Z",
      "slug": "test-features-single-line-else",
      "url": "/test/features/single_line_else.js",
      "urls": [
        "/test/features/single_line_else.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "if ((x != 2) && (2)) { 2;2 } else true\n",
      "rendered": true,
      "contentRendered": "if ((x != 2) && (2)) { 2;2 } else true\n",
      "contentRenderedWithoutLayouts": "if ((x != 2) && (2)) { 2;2 } else true\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/single_line_if.coffee",
      "relativePath": "test/features/single_line_if.coffee",
      "basename": "single_line_if",
      "outBasename": "single_line_if",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "single_line_if.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/single_line_if.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "single_line_if.coffee",
      "relativeOutPath": "test/features/single_line_if.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/single_line_if",
      "relativeOutBase": "test/features/single_line_if",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.066Z",
      "rtime": "2014-01-20T02:05:25.196Z",
      "wtime": "2014-01-20T02:05:26.269Z",
      "exists": true,
      "encoding": "utf8",
      "source": "2  if x\n",
      "content": "2  if x\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "single_line_if.coffee",
      "date": "2014-01-20T02:05:22.066Z",
      "slug": "test-features-single-line-if",
      "url": "/test/features/single_line_if.coffee",
      "urls": [
        "/test/features/single_line_if.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "2  if x\n",
      "rendered": true,
      "contentRendered": "2  if x\n",
      "contentRenderedWithoutLayouts": "2  if x\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/single_line_if.js",
      "relativePath": "test/features/single_line_if.js",
      "basename": "single_line_if",
      "outBasename": "single_line_if",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "single_line_if.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/single_line_if.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "single_line_if.js",
      "relativeOutPath": "test/features/single_line_if.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/single_line_if",
      "relativeOutBase": "test/features/single_line_if",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.082Z",
      "rtime": "2014-01-20T02:05:25.202Z",
      "wtime": "2014-01-20T02:05:26.275Z",
      "exists": true,
      "encoding": "utf8",
      "source": "if (x) { 2 }",
      "content": "if (x) { 2 }",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "single_line_if.js",
      "date": "2014-01-20T02:05:22.082Z",
      "slug": "test-features-single-line-if",
      "url": "/test/features/single_line_if.js",
      "urls": [
        "/test/features/single_line_if.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "if (x) { 2 }",
      "rendered": true,
      "contentRendered": "if (x) { 2 }",
      "contentRenderedWithoutLayouts": "if (x) { 2 }",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/single_line_while.coffee",
      "relativePath": "test/features/single_line_while.coffee",
      "basename": "single_line_while",
      "outBasename": "single_line_while",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "single_line_while.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/single_line_while.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "single_line_while.coffee",
      "relativeOutPath": "test/features/single_line_while.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/single_line_while",
      "relativeOutBase": "test/features/single_line_while",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.099Z",
      "rtime": "2014-01-20T02:05:25.207Z",
      "wtime": "2014-01-20T02:05:26.280Z",
      "exists": true,
      "encoding": "utf8",
      "source": "foo()  while something\nwhile something\n  foo()\n  bar()\nfoo()  until something\nuntil something\n  foo()\n  bar()\n",
      "content": "foo()  while something\nwhile something\n  foo()\n  bar()\nfoo()  until something\nuntil something\n  foo()\n  bar()\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "single_line_while.coffee",
      "date": "2014-01-20T02:05:22.099Z",
      "slug": "test-features-single-line-while",
      "url": "/test/features/single_line_while.coffee",
      "urls": [
        "/test/features/single_line_while.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "foo()  while something\nwhile something\n  foo()\n  bar()\nfoo()  until something\nuntil something\n  foo()\n  bar()\n",
      "rendered": true,
      "contentRendered": "foo()  while something\nwhile something\n  foo()\n  bar()\nfoo()  until something\nuntil something\n  foo()\n  bar()\n",
      "contentRenderedWithoutLayouts": "foo()  while something\nwhile something\n  foo()\n  bar()\nfoo()  until something\nuntil something\n  foo()\n  bar()\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/single_line_while.js",
      "relativePath": "test/features/single_line_while.js",
      "basename": "single_line_while",
      "outBasename": "single_line_while",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "single_line_while.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/single_line_while.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "single_line_while.js",
      "relativeOutPath": "test/features/single_line_while.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/single_line_while",
      "relativeOutBase": "test/features/single_line_while",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.123Z",
      "rtime": "2014-01-20T02:05:25.214Z",
      "wtime": "2014-01-20T02:05:26.287Z",
      "exists": true,
      "encoding": "utf8",
      "source": "while (something) { foo(); }\nwhile (something) { foo(); bar(); }\nwhile (!something) { foo(); }\nwhile (!something) { foo(); bar(); }\n",
      "content": "while (something) { foo(); }\nwhile (something) { foo(); bar(); }\nwhile (!something) { foo(); }\nwhile (!something) { foo(); bar(); }\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "single_line_while.js",
      "date": "2014-01-20T02:05:22.123Z",
      "slug": "test-features-single-line-while",
      "url": "/test/features/single_line_while.js",
      "urls": [
        "/test/features/single_line_while.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "while (something) { foo(); }\nwhile (something) { foo(); bar(); }\nwhile (!something) { foo(); }\nwhile (!something) { foo(); bar(); }\n",
      "rendered": true,
      "contentRendered": "while (something) { foo(); }\nwhile (something) { foo(); bar(); }\nwhile (!something) { foo(); }\nwhile (!something) { foo(); bar(); }\n",
      "contentRenderedWithoutLayouts": "while (something) { foo(); }\nwhile (something) { foo(); bar(); }\nwhile (!something) { foo(); }\nwhile (!something) { foo(); bar(); }\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/single_quotes.coffee",
      "relativePath": "test/features/single_quotes.coffee",
      "basename": "single_quotes",
      "outBasename": "single_quotes",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "single_quotes.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/single_quotes.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "single_quotes.coffee",
      "relativeOutPath": "test/features/single_quotes.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/single_quotes",
      "relativeOutBase": "test/features/single_quotes",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.140Z",
      "rtime": "2014-01-20T02:05:25.222Z",
      "wtime": "2014-01-20T02:05:26.290Z",
      "exists": true,
      "encoding": "utf8",
      "source": "foo = 'bar'\nobj =\n  key: 'value'\n  escape: 'rock\\'n roll \"escaped\" strings'\n  array: [\n    'one'\n    2\n    'tree'\n  ]\n  mixed: 'hello' + foo\n  'empty foo bar': ''\n  'js-has-no-string-formatting': '#{foo}' + '#{foo}'\n",
      "content": "foo = 'bar'\nobj =\n  key: 'value'\n  escape: 'rock\\'n roll \"escaped\" strings'\n  array: [\n    'one'\n    2\n    'tree'\n  ]\n  mixed: 'hello' + foo\n  'empty foo bar': ''\n  'js-has-no-string-formatting': '#{foo}' + '#{foo}'\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "single_quotes.coffee",
      "date": "2014-01-20T02:05:22.140Z",
      "slug": "test-features-single-quotes",
      "url": "/test/features/single_quotes.coffee",
      "urls": [
        "/test/features/single_quotes.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "foo = 'bar'\nobj =\n  key: 'value'\n  escape: 'rock\\'n roll \"escaped\" strings'\n  array: [\n    'one'\n    2\n    'tree'\n  ]\n  mixed: 'hello' + foo\n  'empty foo bar': ''\n  'js-has-no-string-formatting': '#{foo}' + '#{foo}'\n",
      "rendered": true,
      "contentRendered": "foo = 'bar'\nobj =\n  key: 'value'\n  escape: 'rock\\'n roll \"escaped\" strings'\n  array: [\n    'one'\n    2\n    'tree'\n  ]\n  mixed: 'hello' + foo\n  'empty foo bar': ''\n  'js-has-no-string-formatting': '#{foo}' + '#{foo}'\n",
      "contentRenderedWithoutLayouts": "foo = 'bar'\nobj =\n  key: 'value'\n  escape: 'rock\\'n roll \"escaped\" strings'\n  array: [\n    'one'\n    2\n    'tree'\n  ]\n  mixed: 'hello' + foo\n  'empty foo bar': ''\n  'js-has-no-string-formatting': '#{foo}' + '#{foo}'\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/single_quotes.js",
      "relativePath": "test/features/single_quotes.js",
      "basename": "single_quotes",
      "outBasename": "single_quotes",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "single_quotes.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/single_quotes.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "single_quotes.js",
      "relativeOutPath": "test/features/single_quotes.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/single_quotes",
      "relativeOutBase": "test/features/single_quotes",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.156Z",
      "rtime": "2014-01-20T02:05:25.234Z",
      "wtime": "2014-01-20T02:05:26.301Z",
      "exists": true,
      "encoding": "utf8",
      "source": "// OPTIONS: {\"single_quotes\": true}\nvar foo = 'bar';\n\nvar obj = {\n    key: \"value\",\n    escape: 'rock\\'n roll \"escaped\" strings',\n    \"array\": [\"one\", 2, 'tree'],\n    'mixed': \"hello\" + foo,\n    'empty foo bar': '',\n    \"js-has-no-string-formatting\": \"#{foo}\" + '#{foo}'\n\n};",
      "content": "// OPTIONS: {\"single_quotes\": true}\nvar foo = 'bar';\n\nvar obj = {\n    key: \"value\",\n    escape: 'rock\\'n roll \"escaped\" strings',\n    \"array\": [\"one\", 2, 'tree'],\n    'mixed': \"hello\" + foo,\n    'empty foo bar': '',\n    \"js-has-no-string-formatting\": \"#{foo}\" + '#{foo}'\n\n};",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "single_quotes.js",
      "date": "2014-01-20T02:05:22.156Z",
      "slug": "test-features-single-quotes",
      "url": "/test/features/single_quotes.js",
      "urls": [
        "/test/features/single_quotes.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "// OPTIONS: {\"single_quotes\": true}\nvar foo = 'bar';\n\nvar obj = {\n    key: \"value\",\n    escape: 'rock\\'n roll \"escaped\" strings',\n    \"array\": [\"one\", 2, 'tree'],\n    'mixed': \"hello\" + foo,\n    'empty foo bar': '',\n    \"js-has-no-string-formatting\": \"#{foo}\" + '#{foo}'\n\n};",
      "rendered": true,
      "contentRendered": "// OPTIONS: {\"single_quotes\": true}\nvar foo = 'bar';\n\nvar obj = {\n    key: \"value\",\n    escape: 'rock\\'n roll \"escaped\" strings',\n    \"array\": [\"one\", 2, 'tree'],\n    'mixed': \"hello\" + foo,\n    'empty foo bar': '',\n    \"js-has-no-string-formatting\": \"#{foo}\" + '#{foo}'\n\n};",
      "contentRenderedWithoutLayouts": "// OPTIONS: {\"single_quotes\": true}\nvar foo = 'bar';\n\nvar obj = {\n    key: \"value\",\n    escape: 'rock\\'n roll \"escaped\" strings',\n    \"array\": [\"one\", 2, 'tree'],\n    'mixed': \"hello\" + foo,\n    'empty foo bar': '',\n    \"js-has-no-string-formatting\": \"#{foo}\" + '#{foo}'\n\n};",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/single_return.coffee",
      "relativePath": "test/features/single_return.coffee",
      "basename": "single_return",
      "outBasename": "single_return",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "single_return.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/single_return.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "single_return.coffee",
      "relativeOutPath": "test/features/single_return.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/single_return",
      "relativeOutBase": "test/features/single_return",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.177Z",
      "rtime": "2014-01-20T02:05:25.241Z",
      "wtime": "2014-01-20T02:05:26.304Z",
      "exists": true,
      "encoding": "utf8",
      "source": "->\n  return\n",
      "content": "->\n  return\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "single_return.coffee",
      "date": "2014-01-20T02:05:22.177Z",
      "slug": "test-features-single-return",
      "url": "/test/features/single_return.coffee",
      "urls": [
        "/test/features/single_return.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "->\n  return\n",
      "rendered": true,
      "contentRendered": "->\n  return\n",
      "contentRenderedWithoutLayouts": "->\n  return\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/single_return.js",
      "relativePath": "test/features/single_return.js",
      "basename": "single_return",
      "outBasename": "single_return",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "single_return.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/single_return.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "single_return.js",
      "relativeOutPath": "test/features/single_return.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/single_return",
      "relativeOutBase": "test/features/single_return",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.193Z",
      "rtime": "2014-01-20T02:05:25.248Z",
      "wtime": "2014-01-20T02:05:26.310Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(function() { return; });",
      "content": "(function() { return; });",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "single_return.js",
      "date": "2014-01-20T02:05:22.193Z",
      "slug": "test-features-single-return",
      "url": "/test/features/single_return.js",
      "urls": [
        "/test/features/single_return.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(function() { return; });",
      "rendered": true,
      "contentRendered": "(function() { return; });",
      "contentRenderedWithoutLayouts": "(function() { return; });",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/switch.coffee",
      "relativePath": "test/features/switch.coffee",
      "basename": "switch",
      "outBasename": "switch",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "switch.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/switch.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "switch.coffee",
      "relativeOutPath": "test/features/switch.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/switch",
      "relativeOutBase": "test/features/switch",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.209Z",
      "rtime": "2014-01-20T02:05:25.255Z",
      "wtime": "2014-01-20T02:05:26.314Z",
      "exists": true,
      "encoding": "utf8",
      "source": "switch x\n  when 2\n    a\n  when 3\n    b\n  else\n    x\nswitch x\n  when 2, 3\n    b\n  else\n    x\n",
      "content": "switch x\n  when 2\n    a\n  when 3\n    b\n  else\n    x\nswitch x\n  when 2, 3\n    b\n  else\n    x\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "switch.coffee",
      "date": "2014-01-20T02:05:22.209Z",
      "slug": "test-features-switch",
      "url": "/test/features/switch.coffee",
      "urls": [
        "/test/features/switch.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "switch x\n  when 2\n    a\n  when 3\n    b\n  else\n    x\nswitch x\n  when 2, 3\n    b\n  else\n    x\n",
      "rendered": true,
      "contentRendered": "switch x\n  when 2\n    a\n  when 3\n    b\n  else\n    x\nswitch x\n  when 2, 3\n    b\n  else\n    x\n",
      "contentRenderedWithoutLayouts": "switch x\n  when 2\n    a\n  when 3\n    b\n  else\n    x\nswitch x\n  when 2, 3\n    b\n  else\n    x\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/switch.js",
      "relativePath": "test/features/switch.js",
      "basename": "switch",
      "outBasename": "switch",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "switch.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/switch.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "switch.js",
      "relativeOutPath": "test/features/switch.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/switch",
      "relativeOutBase": "test/features/switch",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.224Z",
      "rtime": "2014-01-20T02:05:25.265Z",
      "wtime": "2014-01-20T02:05:26.317Z",
      "exists": true,
      "encoding": "utf8",
      "source": "switch (x) { case 2: a; break; case 3: b; break; default: x; }\nswitch (x) { case 2: case 3: b; break; default: x; }",
      "content": "switch (x) { case 2: a; break; case 3: b; break; default: x; }\nswitch (x) { case 2: case 3: b; break; default: x; }",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "switch.js",
      "date": "2014-01-20T02:05:22.224Z",
      "slug": "test-features-switch",
      "url": "/test/features/switch.js",
      "urls": [
        "/test/features/switch.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "switch (x) { case 2: a; break; case 3: b; break; default: x; }\nswitch (x) { case 2: case 3: b; break; default: x; }",
      "rendered": true,
      "contentRendered": "switch (x) { case 2: a; break; case 3: b; break; default: x; }\nswitch (x) { case 2: case 3: b; break; default: x; }",
      "contentRenderedWithoutLayouts": "switch (x) { case 2: a; break; case 3: b; break; default: x; }\nswitch (x) { case 2: case 3: b; break; default: x; }",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/ternary.coffee",
      "relativePath": "test/features/ternary.coffee",
      "basename": "ternary",
      "outBasename": "ternary",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "ternary.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/ternary.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "ternary.coffee",
      "relativeOutPath": "test/features/ternary.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/ternary",
      "relativeOutBase": "test/features/ternary",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.240Z",
      "rtime": "2014-01-20T02:05:25.271Z",
      "wtime": "2014-01-20T02:05:26.322Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(if a then b else c)\n",
      "content": "(if a then b else c)\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "ternary.coffee",
      "date": "2014-01-20T02:05:22.240Z",
      "slug": "test-features-ternary",
      "url": "/test/features/ternary.coffee",
      "urls": [
        "/test/features/ternary.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(if a then b else c)\n",
      "rendered": true,
      "contentRendered": "(if a then b else c)\n",
      "contentRenderedWithoutLayouts": "(if a then b else c)\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/ternary.js",
      "relativePath": "test/features/ternary.js",
      "basename": "ternary",
      "outBasename": "ternary",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "ternary.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/ternary.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "ternary.js",
      "relativeOutPath": "test/features/ternary.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/ternary",
      "relativeOutBase": "test/features/ternary",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.258Z",
      "rtime": "2014-01-20T02:05:25.280Z",
      "wtime": "2014-01-20T02:05:26.330Z",
      "exists": true,
      "encoding": "utf8",
      "source": "a?b:c",
      "content": "a?b:c",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "ternary.js",
      "date": "2014-01-20T02:05:22.258Z",
      "slug": "test-features-ternary",
      "url": "/test/features/ternary.js",
      "urls": [
        "/test/features/ternary.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "a?b:c",
      "rendered": true,
      "contentRendered": "a?b:c",
      "contentRenderedWithoutLayouts": "a?b:c",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/this_attribute.coffee",
      "relativePath": "test/features/this_attribute.coffee",
      "basename": "this_attribute",
      "outBasename": "this_attribute",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "this_attribute.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/this_attribute.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "this_attribute.coffee",
      "relativeOutPath": "test/features/this_attribute.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/this_attribute",
      "relativeOutBase": "test/features/this_attribute",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.276Z",
      "rtime": "2014-01-20T02:05:25.290Z",
      "wtime": "2014-01-20T02:05:26.335Z",
      "exists": true,
      "encoding": "utf8",
      "source": "->\n  @foo\n",
      "content": "->\n  @foo\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "this_attribute.coffee",
      "date": "2014-01-20T02:05:22.276Z",
      "slug": "test-features-this-attribute",
      "url": "/test/features/this_attribute.coffee",
      "urls": [
        "/test/features/this_attribute.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "->\n  @foo\n",
      "rendered": true,
      "contentRendered": "->\n  @foo\n",
      "contentRenderedWithoutLayouts": "->\n  @foo\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/this_attribute.js",
      "relativePath": "test/features/this_attribute.js",
      "basename": "this_attribute",
      "outBasename": "this_attribute",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "this_attribute.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/this_attribute.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "this_attribute.js",
      "relativeOutPath": "test/features/this_attribute.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/this_attribute",
      "relativeOutBase": "test/features/this_attribute",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.297Z",
      "rtime": "2014-01-20T02:05:25.297Z",
      "wtime": "2014-01-20T02:05:26.339Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(function() {\n  return this.foo;\n})\n\n",
      "content": "(function() {\n  return this.foo;\n})\n\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "this_attribute.js",
      "date": "2014-01-20T02:05:22.297Z",
      "slug": "test-features-this-attribute",
      "url": "/test/features/this_attribute.js",
      "urls": [
        "/test/features/this_attribute.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(function() {\n  return this.foo;\n})\n\n",
      "rendered": true,
      "contentRendered": "(function() {\n  return this.foo;\n})\n\n",
      "contentRenderedWithoutLayouts": "(function() {\n  return this.foo;\n})\n\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/this_keyword.coffee",
      "relativePath": "test/features/this_keyword.coffee",
      "basename": "this_keyword",
      "outBasename": "this_keyword",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "this_keyword.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/this_keyword.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "this_keyword.coffee",
      "relativeOutPath": "test/features/this_keyword.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/this_keyword",
      "relativeOutBase": "test/features/this_keyword",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.315Z",
      "rtime": "2014-01-20T02:05:25.303Z",
      "wtime": "2014-01-20T02:05:26.343Z",
      "exists": true,
      "encoding": "utf8",
      "source": "->\n  this\n",
      "content": "->\n  this\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "this_keyword.coffee",
      "date": "2014-01-20T02:05:22.315Z",
      "slug": "test-features-this-keyword",
      "url": "/test/features/this_keyword.coffee",
      "urls": [
        "/test/features/this_keyword.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "->\n  this\n",
      "rendered": true,
      "contentRendered": "->\n  this\n",
      "contentRenderedWithoutLayouts": "->\n  this\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/this_keyword.js",
      "relativePath": "test/features/this_keyword.js",
      "basename": "this_keyword",
      "outBasename": "this_keyword",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "this_keyword.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/this_keyword.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "this_keyword.js",
      "relativeOutPath": "test/features/this_keyword.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/this_keyword",
      "relativeOutBase": "test/features/this_keyword",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.331Z",
      "rtime": "2014-01-20T02:05:25.313Z",
      "wtime": "2014-01-20T02:05:26.347Z",
      "exists": true,
      "encoding": "utf8",
      "source": "(function() {\n  return this;\n})\n\n",
      "content": "(function() {\n  return this;\n})\n\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "this_keyword.js",
      "date": "2014-01-20T02:05:22.331Z",
      "slug": "test-features-this-keyword",
      "url": "/test/features/this_keyword.js",
      "urls": [
        "/test/features/this_keyword.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "(function() {\n  return this;\n})\n\n",
      "rendered": true,
      "contentRendered": "(function() {\n  return this;\n})\n\n",
      "contentRenderedWithoutLayouts": "(function() {\n  return this;\n})\n\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/throw.coffee",
      "relativePath": "test/features/throw.coffee",
      "basename": "throw",
      "outBasename": "throw",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "throw.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/throw.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "throw.coffee",
      "relativeOutPath": "test/features/throw.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/throw",
      "relativeOutBase": "test/features/throw",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.347Z",
      "rtime": "2014-01-20T02:05:25.321Z",
      "wtime": "2014-01-20T02:05:26.352Z",
      "exists": true,
      "encoding": "utf8",
      "source": "try\n  throw 2\ncatch x\n  alert x\n",
      "content": "try\n  throw 2\ncatch x\n  alert x\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "throw.coffee",
      "date": "2014-01-20T02:05:22.347Z",
      "slug": "test-features-throw",
      "url": "/test/features/throw.coffee",
      "urls": [
        "/test/features/throw.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "try\n  throw 2\ncatch x\n  alert x\n",
      "rendered": true,
      "contentRendered": "try\n  throw 2\ncatch x\n  alert x\n",
      "contentRenderedWithoutLayouts": "try\n  throw 2\ncatch x\n  alert x\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/throw.js",
      "relativePath": "test/features/throw.js",
      "basename": "throw",
      "outBasename": "throw",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "throw.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/throw.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "throw.js",
      "relativeOutPath": "test/features/throw.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/throw",
      "relativeOutBase": "test/features/throw",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.362Z",
      "rtime": "2014-01-20T02:05:25.326Z",
      "wtime": "2014-01-20T02:05:26.356Z",
      "exists": true,
      "encoding": "utf8",
      "source": "try {\nthrow 2;} catch(x) { alert (x); }\n",
      "content": "try {\nthrow 2;} catch(x) { alert (x); }\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "throw.js",
      "date": "2014-01-20T02:05:22.362Z",
      "slug": "test-features-throw",
      "url": "/test/features/throw.js",
      "urls": [
        "/test/features/throw.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "try {\nthrow 2;} catch(x) { alert (x); }\n",
      "rendered": true,
      "contentRendered": "try {\nthrow 2;} catch(x) { alert (x); }\n",
      "contentRenderedWithoutLayouts": "try {\nthrow 2;} catch(x) { alert (x); }\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/unary.coffee",
      "relativePath": "test/features/unary.coffee",
      "basename": "unary",
      "outBasename": "unary",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "unary.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/unary.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "unary.coffee",
      "relativeOutPath": "test/features/unary.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/unary",
      "relativeOutBase": "test/features/unary",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.380Z",
      "rtime": "2014-01-20T02:05:25.332Z",
      "wtime": "2014-01-20T02:05:26.360Z",
      "exists": true,
      "encoding": "utf8",
      "source": "-1\n+1\n+1 - 1\n+1 - 1\n~2 - 2\n~2 + -1\na = ~2\n",
      "content": "-1\n+1\n+1 - 1\n+1 - 1\n~2 - 2\n~2 + -1\na = ~2\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "unary.coffee",
      "date": "2014-01-20T02:05:22.380Z",
      "slug": "test-features-unary",
      "url": "/test/features/unary.coffee",
      "urls": [
        "/test/features/unary.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "-1\n+1\n+1 - 1\n+1 - 1\n~2 - 2\n~2 + -1\na = ~2\n",
      "rendered": true,
      "contentRendered": "-1\n+1\n+1 - 1\n+1 - 1\n~2 - 2\n~2 + -1\na = ~2\n",
      "contentRenderedWithoutLayouts": "-1\n+1\n+1 - 1\n+1 - 1\n~2 - 2\n~2 + -1\na = ~2\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/unary.js",
      "relativePath": "test/features/unary.js",
      "basename": "unary",
      "outBasename": "unary",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "unary.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/unary.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "unary.js",
      "relativeOutPath": "test/features/unary.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/unary",
      "relativeOutBase": "test/features/unary",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.397Z",
      "rtime": "2014-01-20T02:05:25.337Z",
      "wtime": "2014-01-20T02:05:26.366Z",
      "exists": true,
      "encoding": "utf8",
      "source": "-1;\n+1;\n+1 - 1;\n+1 -1;\n~2 - 2;\n~2+-1;\na =~ 2;\n",
      "content": "-1;\n+1;\n+1 - 1;\n+1 -1;\n~2 - 2;\n~2+-1;\na =~ 2;\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "unary.js",
      "date": "2014-01-20T02:05:22.397Z",
      "slug": "test-features-unary",
      "url": "/test/features/unary.js",
      "urls": [
        "/test/features/unary.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "-1;\n+1;\n+1 - 1;\n+1 -1;\n~2 - 2;\n~2+-1;\na =~ 2;\n",
      "rendered": true,
      "contentRendered": "-1;\n+1;\n+1 - 1;\n+1 -1;\n~2 - 2;\n~2+-1;\na =~ 2;\n",
      "contentRenderedWithoutLayouts": "-1;\n+1;\n+1 - 1;\n+1 -1;\n~2 - 2;\n~2+-1;\na =~ 2;\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/undefined.coffee",
      "relativePath": "test/features/undefined.coffee",
      "basename": "undefined",
      "outBasename": "undefined",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "undefined.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/undefined.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "undefined.coffee",
      "relativeOutPath": "test/features/undefined.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/undefined",
      "relativeOutBase": "test/features/undefined",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.417Z",
      "rtime": "2014-01-20T02:05:25.343Z",
      "wtime": "2014-01-20T02:05:26.371Z",
      "exists": true,
      "encoding": "utf8",
      "source": "`undefined`\n",
      "content": "`undefined`\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "undefined.coffee",
      "date": "2014-01-20T02:05:22.417Z",
      "slug": "test-features-undefined",
      "url": "/test/features/undefined.coffee",
      "urls": [
        "/test/features/undefined.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "`undefined`\n",
      "rendered": true,
      "contentRendered": "`undefined`\n",
      "contentRenderedWithoutLayouts": "`undefined`\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/undefined.js",
      "relativePath": "test/features/undefined.js",
      "basename": "undefined",
      "outBasename": "undefined",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "undefined.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/undefined.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "undefined.js",
      "relativeOutPath": "test/features/undefined.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/undefined",
      "relativeOutBase": "test/features/undefined",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.434Z",
      "rtime": "2014-01-20T02:05:25.348Z",
      "wtime": "2014-01-20T02:05:26.375Z",
      "exists": true,
      "encoding": "utf8",
      "source": "undefined\n",
      "content": "undefined\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "undefined.js",
      "date": "2014-01-20T02:05:22.434Z",
      "slug": "test-features-undefined",
      "url": "/test/features/undefined.js",
      "urls": [
        "/test/features/undefined.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "undefined\n",
      "rendered": true,
      "contentRendered": "undefined\n",
      "contentRenderedWithoutLayouts": "undefined\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/unless_bug.coffee",
      "relativePath": "test/features/unless_bug.coffee",
      "basename": "unless_bug",
      "outBasename": "unless_bug",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "unless_bug.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/unless_bug.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "unless_bug.coffee",
      "relativeOutPath": "test/features/unless_bug.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/unless_bug",
      "relativeOutBase": "test/features/unless_bug",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-02T23:00:53.000Z",
      "mtime": "2014-01-20T02:05:22.451Z",
      "rtime": "2014-01-20T02:05:25.354Z",
      "wtime": "2014-01-20T02:05:26.376Z",
      "exists": true,
      "encoding": "utf8",
      "source": "if true\n  foo()\nelse\n  bar()\nA()  if a\nunless b\n  notB()\nelse if c\n  C()\nelse unless d\n  notD()\nelse\n  foobar()",
      "content": "if true\n  foo()\nelse\n  bar()\nA()  if a\nunless b\n  notB()\nelse if c\n  C()\nelse unless d\n  notD()\nelse\n  foobar()",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "unless_bug.coffee",
      "date": "2014-01-20T02:05:22.451Z",
      "slug": "test-features-unless-bug",
      "url": "/test/features/unless_bug.coffee",
      "urls": [
        "/test/features/unless_bug.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "if true\n  foo()\nelse\n  bar()\nA()  if a\nunless b\n  notB()\nelse if c\n  C()\nelse unless d\n  notD()\nelse\n  foobar()",
      "rendered": true,
      "contentRendered": "if true\n  foo()\nelse\n  bar()\nA()  if a\nunless b\n  notB()\nelse if c\n  C()\nelse unless d\n  notD()\nelse\n  foobar()",
      "contentRenderedWithoutLayouts": "if true\n  foo()\nelse\n  bar()\nA()  if a\nunless b\n  notB()\nelse if c\n  C()\nelse unless d\n  notD()\nelse\n  foobar()",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/unless_bug.js",
      "relativePath": "test/features/unless_bug.js",
      "basename": "unless_bug",
      "outBasename": "unless_bug",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "unless_bug.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/unless_bug.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "unless_bug.js",
      "relativeOutPath": "test/features/unless_bug.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/unless_bug",
      "relativeOutBase": "test/features/unless_bug",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-01-02T23:00:53.000Z",
      "mtime": "2014-01-20T02:05:22.467Z",
      "rtime": "2014-01-20T02:05:25.359Z",
      "wtime": "2014-01-20T02:05:26.380Z",
      "exists": true,
      "encoding": "utf8",
      "source": "if (true)\n foo();\nelse {\n bar();\n}\nif (a)\n  A();\nif (!b)\n  notB();\nelse if (c)\n  C();\nelse if (!d)\n  notD();\nelse {\n  foobar();\n}",
      "content": "if (true)\n foo();\nelse {\n bar();\n}\nif (a)\n  A();\nif (!b)\n  notB();\nelse if (c)\n  C();\nelse if (!d)\n  notD();\nelse {\n  foobar();\n}",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "unless_bug.js",
      "date": "2014-01-20T02:05:22.467Z",
      "slug": "test-features-unless-bug",
      "url": "/test/features/unless_bug.js",
      "urls": [
        "/test/features/unless_bug.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "if (true)\n foo();\nelse {\n bar();\n}\nif (a)\n  A();\nif (!b)\n  notB();\nelse if (c)\n  C();\nelse if (!d)\n  notD();\nelse {\n  foobar();\n}",
      "rendered": true,
      "contentRendered": "if (true)\n foo();\nelse {\n bar();\n}\nif (a)\n  A();\nif (!b)\n  notB();\nelse if (c)\n  C();\nelse if (!d)\n  notD();\nelse {\n  foobar();\n}",
      "contentRenderedWithoutLayouts": "if (true)\n foo();\nelse {\n bar();\n}\nif (a)\n  A();\nif (!b)\n  notB();\nelse if (c)\n  C();\nelse if (!d)\n  notD();\nelse {\n  foobar();\n}",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/unusual_identifiers.coffee",
      "relativePath": "test/features/unusual_identifiers.coffee",
      "basename": "unusual_identifiers",
      "outBasename": "unusual_identifiers",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "unusual_identifiers.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/unusual_identifiers.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "unusual_identifiers.coffee",
      "relativeOutPath": "test/features/unusual_identifiers.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/unusual_identifiers",
      "relativeOutBase": "test/features/unusual_identifiers",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.483Z",
      "rtime": "2014-01-20T02:05:25.364Z",
      "wtime": "2014-01-20T02:05:26.386Z",
      "exists": true,
      "encoding": "utf8",
      "source": "hash =\n  a: b\n  \"a.a\": b\n  \"a#a\": b\n  \"a a\": b\n  0: b\n  \"0.a\": b\n  $: b\n  $$: b\n  $a: b\n  \"$a b\": b\n",
      "content": "hash =\n  a: b\n  \"a.a\": b\n  \"a#a\": b\n  \"a a\": b\n  0: b\n  \"0.a\": b\n  $: b\n  $$: b\n  $a: b\n  \"$a b\": b\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "unusual_identifiers.coffee",
      "date": "2014-01-20T02:05:22.483Z",
      "slug": "test-features-unusual-identifiers",
      "url": "/test/features/unusual_identifiers.coffee",
      "urls": [
        "/test/features/unusual_identifiers.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "hash =\n  a: b\n  \"a.a\": b\n  \"a#a\": b\n  \"a a\": b\n  0: b\n  \"0.a\": b\n  $: b\n  $$: b\n  $a: b\n  \"$a b\": b\n",
      "rendered": true,
      "contentRendered": "hash =\n  a: b\n  \"a.a\": b\n  \"a#a\": b\n  \"a a\": b\n  0: b\n  \"0.a\": b\n  $: b\n  $$: b\n  $a: b\n  \"$a b\": b\n",
      "contentRenderedWithoutLayouts": "hash =\n  a: b\n  \"a.a\": b\n  \"a#a\": b\n  \"a a\": b\n  0: b\n  \"0.a\": b\n  $: b\n  $$: b\n  $a: b\n  \"$a b\": b\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/unusual_identifiers.js",
      "relativePath": "test/features/unusual_identifiers.js",
      "basename": "unusual_identifiers",
      "outBasename": "unusual_identifiers",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "unusual_identifiers.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/unusual_identifiers.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "unusual_identifiers.js",
      "relativeOutPath": "test/features/unusual_identifiers.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/unusual_identifiers",
      "relativeOutBase": "test/features/unusual_identifiers",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.499Z",
      "rtime": "2014-01-20T02:05:25.370Z",
      "wtime": "2014-01-20T02:05:26.389Z",
      "exists": true,
      "encoding": "utf8",
      "source": "// OPTIONS: {\"single_quotes\": false}\nvar hash = {\n    a: b,\n    'a.a': b,\n    'a#a': b,\n    'a a': b,\n    0: b,\n    '0.a': b,\n    $: b,\n    $$: b,\n    $a: b,\n    \"$a b\": b\n};\n",
      "content": "// OPTIONS: {\"single_quotes\": false}\nvar hash = {\n    a: b,\n    'a.a': b,\n    'a#a': b,\n    'a a': b,\n    0: b,\n    '0.a': b,\n    $: b,\n    $$: b,\n    $a: b,\n    \"$a b\": b\n};\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "unusual_identifiers.js",
      "date": "2014-01-20T02:05:22.499Z",
      "slug": "test-features-unusual-identifiers",
      "url": "/test/features/unusual_identifiers.js",
      "urls": [
        "/test/features/unusual_identifiers.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "// OPTIONS: {\"single_quotes\": false}\nvar hash = {\n    a: b,\n    'a.a': b,\n    'a#a': b,\n    'a a': b,\n    0: b,\n    '0.a': b,\n    $: b,\n    $$: b,\n    $a: b,\n    \"$a b\": b\n};\n",
      "rendered": true,
      "contentRendered": "// OPTIONS: {\"single_quotes\": false}\nvar hash = {\n    a: b,\n    'a.a': b,\n    'a#a': b,\n    'a a': b,\n    0: b,\n    '0.a': b,\n    $: b,\n    $$: b,\n    $a: b,\n    \"$a b\": b\n};\n",
      "contentRenderedWithoutLayouts": "// OPTIONS: {\"single_quotes\": false}\nvar hash = {\n    a: b,\n    'a.a': b,\n    'a#a': b,\n    'a a': b,\n    0: b,\n    '0.a': b,\n    $: b,\n    $$: b,\n    $a: b,\n    \"$a b\": b\n};\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/var.coffee",
      "relativePath": "test/features/var.coffee",
      "basename": "var",
      "outBasename": "var",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "var.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/var.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "var.coffee",
      "relativeOutPath": "test/features/var.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/var",
      "relativeOutBase": "test/features/var",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.515Z",
      "rtime": "2014-01-20T02:05:25.375Z",
      "wtime": "2014-01-20T02:05:26.393Z",
      "exists": true,
      "encoding": "utf8",
      "source": "x = 2\ny = undefined\nf = ->\n  y\n",
      "content": "x = 2\ny = undefined\nf = ->\n  y\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "var.coffee",
      "date": "2014-01-20T02:05:22.515Z",
      "slug": "test-features-var",
      "url": "/test/features/var.coffee",
      "urls": [
        "/test/features/var.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "x = 2\ny = undefined\nf = ->\n  y\n",
      "rendered": true,
      "contentRendered": "x = 2\ny = undefined\nf = ->\n  y\n",
      "contentRenderedWithoutLayouts": "x = 2\ny = undefined\nf = ->\n  y\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/var.js",
      "relativePath": "test/features/var.js",
      "basename": "var",
      "outBasename": "var",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "var.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/var.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "var.js",
      "relativeOutPath": "test/features/var.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/var",
      "relativeOutBase": "test/features/var",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.531Z",
      "rtime": "2014-01-20T02:05:25.381Z",
      "wtime": "2014-01-20T02:05:26.396Z",
      "exists": true,
      "encoding": "utf8",
      "source": "var x = 2;\nvar y;\nvar f = function() { return y };\n",
      "content": "var x = 2;\nvar y;\nvar f = function() { return y };\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "var.js",
      "date": "2014-01-20T02:05:22.531Z",
      "slug": "test-features-var",
      "url": "/test/features/var.js",
      "urls": [
        "/test/features/var.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "var x = 2;\nvar y;\nvar f = function() { return y };\n",
      "rendered": true,
      "contentRendered": "var x = 2;\nvar y;\nvar f = function() { return y };\n",
      "contentRenderedWithoutLayouts": "var x = 2;\nvar y;\nvar f = function() { return y };\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/while.coffee",
      "relativePath": "test/features/while.coffee",
      "basename": "while",
      "outBasename": "while",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "while.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/while.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "while.coffee",
      "relativeOutPath": "test/features/while.coffee",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/while",
      "relativeOutBase": "test/features/while",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.547Z",
      "rtime": "2014-01-20T02:05:25.386Z",
      "wtime": "2014-01-20T02:05:26.402Z",
      "exists": true,
      "encoding": "utf8",
      "source": "alert 1  until a\n",
      "content": "alert 1  until a\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "while.coffee",
      "date": "2014-01-20T02:05:22.547Z",
      "slug": "test-features-while",
      "url": "/test/features/while.coffee",
      "urls": [
        "/test/features/while.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "alert 1  until a\n",
      "rendered": true,
      "contentRendered": "alert 1  until a\n",
      "contentRenderedWithoutLayouts": "alert 1  until a\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features/while.js",
      "relativePath": "test/features/while.js",
      "basename": "while",
      "outBasename": "while",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "while.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/features",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features/while.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/features",
      "outFilename": "while.js",
      "relativeOutPath": "test/features/while.js",
      "relativeDirPath": "test/features",
      "relativeOutDirPath": "test/features",
      "relativeBase": "test/features/while",
      "relativeOutBase": "test/features/while",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.564Z",
      "rtime": "2014-01-20T02:05:25.392Z",
      "wtime": "2014-01-20T02:05:26.406Z",
      "exists": true,
      "encoding": "utf8",
      "source": "while (!a) { alert(1); }\n",
      "content": "while (!a) { alert(1); }\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "while.js",
      "date": "2014-01-20T02:05:22.564Z",
      "slug": "test-features-while",
      "url": "/test/features/while.js",
      "urls": [
        "/test/features/while.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "while (!a) { alert(1); }\n",
      "rendered": true,
      "contentRendered": "while (!a) { alert(1); }\n",
      "contentRenderedWithoutLayouts": "while (!a) { alert(1); }\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending/assignment_condition.coffee",
      "relativePath": "test/pending/assignment_condition.coffee",
      "basename": "assignment_condition",
      "outBasename": "assignment_condition",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "assignment_condition.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending/assignment_condition.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending",
      "outFilename": "assignment_condition.coffee",
      "relativeOutPath": "test/pending/assignment_condition.coffee",
      "relativeDirPath": "test/pending",
      "relativeOutDirPath": "test/pending",
      "relativeBase": "test/pending/assignment_condition",
      "relativeOutBase": "test/pending/assignment_condition",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:22.581Z",
      "rtime": "2014-01-20T02:05:25.397Z",
      "wtime": "2014-01-20T02:05:26.407Z",
      "exists": true,
      "encoding": "utf8",
      "source": "if (options = arguments[i])?\n  for x of y\n    2 + 2\n    3 + 3\n",
      "content": "if (options = arguments[i])?\n  for x of y\n    2 + 2\n    3 + 3\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "assignment_condition.coffee",
      "date": "2014-01-20T02:05:22.581Z",
      "slug": "test-pending-assignment-condition",
      "url": "/test/pending/assignment_condition.coffee",
      "urls": [
        "/test/pending/assignment_condition.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "if (options = arguments[i])?\n  for x of y\n    2 + 2\n    3 + 3\n",
      "rendered": true,
      "contentRendered": "if (options = arguments[i])?\n  for x of y\n    2 + 2\n    3 + 3\n",
      "contentRenderedWithoutLayouts": "if (options = arguments[i])?\n  for x of y\n    2 + 2\n    3 + 3\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending/assignment_condition.js",
      "relativePath": "test/pending/assignment_condition.js",
      "basename": "assignment_condition",
      "outBasename": "assignment_condition",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "assignment_condition.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending/assignment_condition.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending",
      "outFilename": "assignment_condition.js",
      "relativeOutPath": "test/pending/assignment_condition.js",
      "relativeDirPath": "test/pending",
      "relativeOutDirPath": "test/pending",
      "relativeBase": "test/pending/assignment_condition",
      "relativeOutBase": "test/pending/assignment_condition",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:22.598Z",
      "rtime": "2014-01-20T02:05:25.402Z",
      "wtime": "2014-01-20T02:05:26.412Z",
      "exists": true,
      "encoding": "utf8",
      "source": "if ( (options = arguments[ i ]) != null ) { for (x in y) { 2 + 2; 3 + 3; } }",
      "content": "if ( (options = arguments[ i ]) != null ) { for (x in y) { 2 + 2; 3 + 3; } }",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "assignment_condition.js",
      "date": "2014-01-20T02:05:22.598Z",
      "slug": "test-pending-assignment-condition",
      "url": "/test/pending/assignment_condition.js",
      "urls": [
        "/test/pending/assignment_condition.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "if ( (options = arguments[ i ]) != null ) { for (x in y) { 2 + 2; 3 + 3; } }",
      "rendered": true,
      "contentRendered": "if ( (options = arguments[ i ]) != null ) { for (x in y) { 2 + 2; 3 + 3; } }",
      "contentRenderedWithoutLayouts": "if ( (options = arguments[ i ]) != null ) { for (x in y) { 2 + 2; 3 + 3; } }",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "0": "1",
      "1": " ",
      "2": "c",
      "3": "o",
      "4": "m",
      "5": "m",
      "6": "e",
      "7": "n",
      "8": "t",
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending/comments.coffee",
      "relativePath": "test/pending/comments.coffee",
      "basename": "comments",
      "outBasename": "comments",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "comments.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending/comments.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending",
      "outFilename": "comments.coffee",
      "relativeOutPath": "test/pending/comments.coffee",
      "relativeDirPath": "test/pending",
      "relativeOutDirPath": "test/pending",
      "relativeBase": "test/pending/comments",
      "relativeOutBase": "test/pending/comments",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.619Z",
      "rtime": "2014-01-20T02:05:25.408Z",
      "wtime": "2014-01-20T02:05:26.418Z",
      "exists": true,
      "encoding": "utf8",
      "source": "###\n1 comment\n###\n# 2 comment\na = 2;  # 3 comment \nb = 3;  # 4 comment\nd = 5;  # 5 comment \n",
      "content": "# 2 comment\na = 2;  # 3 comment \nb = 3;  # 4 comment\nd = 5;  # 5 comment",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "comments.coffee",
      "date": "2014-01-20T02:05:22.619Z",
      "slug": "test-pending-comments",
      "url": "/test/pending/comments.coffee",
      "urls": [
        "/test/pending/comments.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": "1 comment",
      "parser": "yaml",
      "body": "# 2 comment\na = 2;  # 3 comment \nb = 3;  # 4 comment\nd = 5;  # 5 comment",
      "rendered": true,
      "contentRendered": "# 2 comment\na = 2;  # 3 comment \nb = 3;  # 4 comment\nd = 5;  # 5 comment",
      "contentRenderedWithoutLayouts": "# 2 comment\na = 2;  # 3 comment \nb = 3;  # 4 comment\nd = 5;  # 5 comment",
      "renderSingleExtensions": false,
      "meta": {
        "0": "1",
        "1": " ",
        "2": "c",
        "3": "o",
        "4": "m",
        "5": "m",
        "6": "e",
        "7": "n",
        "8": "t"
      }
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending/comments.js",
      "relativePath": "test/pending/comments.js",
      "basename": "comments",
      "outBasename": "comments",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "comments.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending/comments.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending",
      "outFilename": "comments.js",
      "relativeOutPath": "test/pending/comments.js",
      "relativeDirPath": "test/pending",
      "relativeOutDirPath": "test/pending",
      "relativeBase": "test/pending/comments",
      "relativeOutBase": "test/pending/comments",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.643Z",
      "rtime": "2014-01-20T02:05:25.413Z",
      "wtime": "2014-01-20T02:05:26.426Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/* 1 comment */\n// 2 comment\na = 3;  /* 3 comment */\nb = 4;  // 4 comment\nd = /* 5 comment */ 5;\n\n// something more difficult\n\nvar a = 9, // l9\n    b = 10; // l10\n\nswitch (x) {            // l12\n  case 2: a; break;     // l13\n  case 3: b; break;     // l14\n  default: x;           // l15\n}\n\n\n//l18\nswitch (x) {     // l19\n  case 2:        // l20\n  case 3: b;     // l21\n    break;       // l22\n  default: x; }  // l23\n",
      "content": "/* 1 comment */\n// 2 comment\na = 3;  /* 3 comment */\nb = 4;  // 4 comment\nd = /* 5 comment */ 5;\n\n// something more difficult\n\nvar a = 9, // l9\n    b = 10; // l10\n\nswitch (x) {            // l12\n  case 2: a; break;     // l13\n  case 3: b; break;     // l14\n  default: x;           // l15\n}\n\n\n//l18\nswitch (x) {     // l19\n  case 2:        // l20\n  case 3: b;     // l21\n    break;       // l22\n  default: x; }  // l23\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "comments.js",
      "date": "2014-01-20T02:05:22.643Z",
      "slug": "test-pending-comments",
      "url": "/test/pending/comments.js",
      "urls": [
        "/test/pending/comments.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "/* 1 comment */\n// 2 comment\na = 3;  /* 3 comment */\nb = 4;  // 4 comment\nd = /* 5 comment */ 5;\n\n// something more difficult\n\nvar a = 9, // l9\n    b = 10; // l10\n\nswitch (x) {            // l12\n  case 2: a; break;     // l13\n  case 3: b; break;     // l14\n  default: x;           // l15\n}\n\n\n//l18\nswitch (x) {     // l19\n  case 2:        // l20\n  case 3: b;     // l21\n    break;       // l22\n  default: x; }  // l23\n",
      "rendered": true,
      "contentRendered": "/* 1 comment */\n// 2 comment\na = 3;  /* 3 comment */\nb = 4;  // 4 comment\nd = /* 5 comment */ 5;\n\n// something more difficult\n\nvar a = 9, // l9\n    b = 10; // l10\n\nswitch (x) {            // l12\n  case 2: a; break;     // l13\n  case 3: b; break;     // l14\n  default: x;           // l15\n}\n\n\n//l18\nswitch (x) {     // l19\n  case 2:        // l20\n  case 3: b;     // l21\n    break;       // l22\n  default: x; }  // l23\n",
      "contentRenderedWithoutLayouts": "/* 1 comment */\n// 2 comment\na = 3;  /* 3 comment */\nb = 4;  // 4 comment\nd = /* 5 comment */ 5;\n\n// something more difficult\n\nvar a = 9, // l9\n    b = 10; // l10\n\nswitch (x) {            // l12\n  case 2: a; break;     // l13\n  case 3: b; break;     // l14\n  default: x;           // l15\n}\n\n\n//l18\nswitch (x) {     // l19\n  case 2:        // l20\n  case 3: b;     // l21\n    break;       // l22\n  default: x; }  // l23\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending/empty_function_with_postfix_if.coffee",
      "relativePath": "test/pending/empty_function_with_postfix_if.coffee",
      "basename": "empty_function_with_postfix_if",
      "outBasename": "empty_function_with_postfix_if",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "empty_function_with_postfix_if.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending/empty_function_with_postfix_if.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending",
      "outFilename": "empty_function_with_postfix_if.coffee",
      "relativeOutPath": "test/pending/empty_function_with_postfix_if.coffee",
      "relativeDirPath": "test/pending",
      "relativeOutDirPath": "test/pending",
      "relativeBase": "test/pending/empty_function_with_postfix_if",
      "relativeOutBase": "test/pending/empty_function_with_postfix_if",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:22.662Z",
      "rtime": "2014-01-20T02:05:25.419Z",
      "wtime": "2014-01-20T02:05:26.431Z",
      "exists": true,
      "encoding": "utf8",
      "source": "window.console = log: (->) unless window.console\n",
      "content": "window.console = log: (->) unless window.console\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "empty_function_with_postfix_if.coffee",
      "date": "2014-01-20T02:05:22.662Z",
      "slug": "test-pending-empty-function-with-postfix-if",
      "url": "/test/pending/empty_function_with_postfix_if.coffee",
      "urls": [
        "/test/pending/empty_function_with_postfix_if.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "window.console = log: (->) unless window.console\n",
      "rendered": true,
      "contentRendered": "window.console = log: (->) unless window.console\n",
      "contentRenderedWithoutLayouts": "window.console = log: (->) unless window.console\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending/empty_function_with_postfix_if.js",
      "relativePath": "test/pending/empty_function_with_postfix_if.js",
      "basename": "empty_function_with_postfix_if",
      "outBasename": "empty_function_with_postfix_if",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "empty_function_with_postfix_if.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending/empty_function_with_postfix_if.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending",
      "outFilename": "empty_function_with_postfix_if.js",
      "relativeOutPath": "test/pending/empty_function_with_postfix_if.js",
      "relativeDirPath": "test/pending",
      "relativeOutDirPath": "test/pending",
      "relativeBase": "test/pending/empty_function_with_postfix_if",
      "relativeOutBase": "test/pending/empty_function_with_postfix_if",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-01-17T09:23:22.000Z",
      "mtime": "2014-01-20T02:05:22.688Z",
      "rtime": "2014-01-20T02:05:25.424Z",
      "wtime": "2014-01-20T02:05:26.438Z",
      "exists": true,
      "encoding": "utf8",
      "source": "if (!window.console) window.console = { log: function(){} }\n",
      "content": "if (!window.console) window.console = { log: function(){} }\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "empty_function_with_postfix_if.js",
      "date": "2014-01-20T02:05:22.688Z",
      "slug": "test-pending-empty-function-with-postfix-if",
      "url": "/test/pending/empty_function_with_postfix_if.js",
      "urls": [
        "/test/pending/empty_function_with_postfix_if.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "if (!window.console) window.console = { log: function(){} }\n",
      "rendered": true,
      "contentRendered": "if (!window.console) window.console = { log: function(){} }\n",
      "contentRenderedWithoutLayouts": "if (!window.console) window.console = { log: function(){} }\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending/no_return_switch.coffee",
      "relativePath": "test/pending/no_return_switch.coffee",
      "basename": "no_return_switch",
      "outBasename": "no_return_switch",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "no_return_switch.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending/no_return_switch.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending",
      "outFilename": "no_return_switch.coffee",
      "relativeOutPath": "test/pending/no_return_switch.coffee",
      "relativeDirPath": "test/pending",
      "relativeOutDirPath": "test/pending",
      "relativeBase": "test/pending/no_return_switch",
      "relativeOutBase": "test/pending/no_return_switch",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:22.711Z",
      "rtime": "2014-01-20T02:05:25.429Z",
      "wtime": "2014-01-20T02:05:26.440Z",
      "exists": true,
      "encoding": "utf8",
      "source": "switchWithReturn = ->\n  switch day\n    when \"Mon\"\n      then work\n    when \"Tue\"\n      then relax\n    else\n      iceFishing\nswitchWithoutReturn = ->\n  switch day\n    when \"Mon\"\n      then return work\n    when \"Tue\"\n      then relax\n    else\n      return iceFishing\n  return\n",
      "content": "switchWithReturn = ->\n  switch day\n    when \"Mon\"\n      then work\n    when \"Tue\"\n      then relax\n    else\n      iceFishing\nswitchWithoutReturn = ->\n  switch day\n    when \"Mon\"\n      then return work\n    when \"Tue\"\n      then relax\n    else\n      return iceFishing\n  return\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "no_return_switch.coffee",
      "date": "2014-01-20T02:05:22.711Z",
      "slug": "test-pending-no-return-switch",
      "url": "/test/pending/no_return_switch.coffee",
      "urls": [
        "/test/pending/no_return_switch.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "switchWithReturn = ->\n  switch day\n    when \"Mon\"\n      then work\n    when \"Tue\"\n      then relax\n    else\n      iceFishing\nswitchWithoutReturn = ->\n  switch day\n    when \"Mon\"\n      then return work\n    when \"Tue\"\n      then relax\n    else\n      return iceFishing\n  return\n",
      "rendered": true,
      "contentRendered": "switchWithReturn = ->\n  switch day\n    when \"Mon\"\n      then work\n    when \"Tue\"\n      then relax\n    else\n      iceFishing\nswitchWithoutReturn = ->\n  switch day\n    when \"Mon\"\n      then return work\n    when \"Tue\"\n      then relax\n    else\n      return iceFishing\n  return\n",
      "contentRenderedWithoutLayouts": "switchWithReturn = ->\n  switch day\n    when \"Mon\"\n      then work\n    when \"Tue\"\n      then relax\n    else\n      iceFishing\nswitchWithoutReturn = ->\n  switch day\n    when \"Mon\"\n      then return work\n    when \"Tue\"\n      then relax\n    else\n      return iceFishing\n  return\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending/no_return_switch.js",
      "relativePath": "test/pending/no_return_switch.js",
      "basename": "no_return_switch",
      "outBasename": "no_return_switch",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "no_return_switch.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending/no_return_switch.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending",
      "outFilename": "no_return_switch.js",
      "relativeOutPath": "test/pending/no_return_switch.js",
      "relativeDirPath": "test/pending",
      "relativeOutDirPath": "test/pending",
      "relativeBase": "test/pending/no_return_switch",
      "relativeOutBase": "test/pending/no_return_switch",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-01-16T08:46:35.000Z",
      "mtime": "2014-01-20T02:05:22.736Z",
      "rtime": "2014-01-20T02:05:25.435Z",
      "wtime": "2014-01-20T02:05:26.443Z",
      "exists": true,
      "encoding": "utf8",
      "source": "function switchWithReturn() {\n  switch (day) {\n    case \"Mon\":\n      return work;\n      break;\n    case \"Tue\":\n      return relax;\n      break;\n    default:\n      return iceFishing\n  }\n}\n\nfunction switchWithoutReturn() {\n  switch (day) {\n    case \"Mon\":\n      return work;\n      break;\n    case \"Tue\":\n      relax;\n      break;\n    default:\n      return iceFishing\n  }\n}\n",
      "content": "function switchWithReturn() {\n  switch (day) {\n    case \"Mon\":\n      return work;\n      break;\n    case \"Tue\":\n      return relax;\n      break;\n    default:\n      return iceFishing\n  }\n}\n\nfunction switchWithoutReturn() {\n  switch (day) {\n    case \"Mon\":\n      return work;\n      break;\n    case \"Tue\":\n      relax;\n      break;\n    default:\n      return iceFishing\n  }\n}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "no_return_switch.js",
      "date": "2014-01-20T02:05:22.736Z",
      "slug": "test-pending-no-return-switch",
      "url": "/test/pending/no_return_switch.js",
      "urls": [
        "/test/pending/no_return_switch.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "function switchWithReturn() {\n  switch (day) {\n    case \"Mon\":\n      return work;\n      break;\n    case \"Tue\":\n      return relax;\n      break;\n    default:\n      return iceFishing\n  }\n}\n\nfunction switchWithoutReturn() {\n  switch (day) {\n    case \"Mon\":\n      return work;\n      break;\n    case \"Tue\":\n      relax;\n      break;\n    default:\n      return iceFishing\n  }\n}\n",
      "rendered": true,
      "contentRendered": "function switchWithReturn() {\n  switch (day) {\n    case \"Mon\":\n      return work;\n      break;\n    case \"Tue\":\n      return relax;\n      break;\n    default:\n      return iceFishing\n  }\n}\n\nfunction switchWithoutReturn() {\n  switch (day) {\n    case \"Mon\":\n      return work;\n      break;\n    case \"Tue\":\n      relax;\n      break;\n    default:\n      return iceFishing\n  }\n}\n",
      "contentRenderedWithoutLayouts": "function switchWithReturn() {\n  switch (day) {\n    case \"Mon\":\n      return work;\n      break;\n    case \"Tue\":\n      return relax;\n      break;\n    default:\n      return iceFishing\n  }\n}\n\nfunction switchWithoutReturn() {\n  switch (day) {\n    case \"Mon\":\n      return work;\n      break;\n    case \"Tue\":\n      relax;\n      break;\n    default:\n      return iceFishing\n  }\n}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending/reserved_words.coffee",
      "relativePath": "test/pending/reserved_words.coffee",
      "basename": "reserved_words",
      "outBasename": "reserved_words",
      "extension": "coffee",
      "outExtension": "coffee",
      "extensions": [
        "coffee"
      ],
      "filename": "reserved_words.coffee",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending/reserved_words.coffee",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending",
      "outFilename": "reserved_words.coffee",
      "relativeOutPath": "test/pending/reserved_words.coffee",
      "relativeDirPath": "test/pending",
      "relativeOutDirPath": "test/pending",
      "relativeBase": "test/pending/reserved_words",
      "relativeOutBase": "test/pending/reserved_words",
      "contentType": "application/octet-stream",
      "outContentType": "application/octet-stream",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.754Z",
      "rtime": "2014-01-20T02:05:25.440Z",
      "wtime": "2014-01-20T02:05:26.445Z",
      "exists": true,
      "encoding": "utf8",
      "source": "off = 2\nwindow = 2\n((window, undefined) ->\n  console.log off\n) window\n\n",
      "content": "off = 2\nwindow = 2\n((window, undefined) ->\n  console.log off\n) window\n\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "reserved_words.coffee",
      "date": "2014-01-20T02:05:22.754Z",
      "slug": "test-pending-reserved-words",
      "url": "/test/pending/reserved_words.coffee",
      "urls": [
        "/test/pending/reserved_words.coffee"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "off = 2\nwindow = 2\n((window, undefined) ->\n  console.log off\n) window\n\n",
      "rendered": true,
      "contentRendered": "off = 2\nwindow = 2\n((window, undefined) ->\n  console.log off\n) window\n\n",
      "contentRenderedWithoutLayouts": "off = 2\nwindow = 2\n((window, undefined) ->\n  console.log off\n) window\n\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending/reserved_words.js",
      "relativePath": "test/pending/reserved_words.js",
      "basename": "reserved_words",
      "outBasename": "reserved_words",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "reserved_words.js",
      "fullDirPath": "/Users/awilhelm/dev/js2coffee/master/src/documents/test/pending",
      "outPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending/reserved_words.js",
      "outDirPath": "/Users/awilhelm/dev/js2coffee/master/out/test/pending",
      "outFilename": "reserved_words.js",
      "relativeOutPath": "test/pending/reserved_words.js",
      "relativeDirPath": "test/pending",
      "relativeOutDirPath": "test/pending",
      "relativeBase": "test/pending/reserved_words",
      "relativeOutBase": "test/pending/reserved_words",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2013-11-13T13:13:48.000Z",
      "mtime": "2014-01-20T02:05:22.770Z",
      "rtime": "2014-01-20T02:05:25.446Z",
      "wtime": "2014-01-20T02:05:26.447Z",
      "exists": true,
      "encoding": "utf8",
      "source": "//TODO: any coffee keywords can't be used like 'off' and 'on'\n// so throw exception or convert into raw js mode? \nvar off = 2;\nwindow = 2;\n(function (window, undefined) { console.log(off); })(window);\n",
      "content": "//TODO: any coffee keywords can't be used like 'off' and 'on'\n// so throw exception or convert into raw js mode? \nvar off = 2;\nwindow = 2;\n(function (window, undefined) { console.log(off); })(window);\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "reserved_words.js",
      "date": "2014-01-20T02:05:22.770Z",
      "slug": "test-pending-reserved-words",
      "url": "/test/pending/reserved_words.js",
      "urls": [
        "/test/pending/reserved_words.js"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "//TODO: any coffee keywords can't be used like 'off' and 'on'\n// so throw exception or convert into raw js mode? \nvar off = 2;\nwindow = 2;\n(function (window, undefined) { console.log(off); })(window);\n",
      "rendered": true,
      "contentRendered": "//TODO: any coffee keywords can't be used like 'off' and 'on'\n// so throw exception or convert into raw js mode? \nvar off = 2;\nwindow = 2;\n(function (window, undefined) { console.log(off); })(window);\n",
      "contentRenderedWithoutLayouts": "//TODO: any coffee keywords can't be used like 'off' and 'on'\n// so throw exception or convert into raw js mode? \nvar off = 2;\nwindow = 2;\n(function (window, undefined) { console.log(off); })(window);\n",
      "renderSingleExtensions": false,
      "meta": {}
    }
  ]
}